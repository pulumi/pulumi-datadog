# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ApmRetentionFilterFilterArgs',
    'ChildOrganizationApiKeyArgs',
    'ChildOrganizationApplicationKeyArgs',
    'ChildOrganizationSettingArgs',
    'ChildOrganizationSettingSamlArgs',
    'ChildOrganizationSettingSamlAutocreateUsersDomainArgs',
    'ChildOrganizationSettingSamlIdpInitiatedLoginArgs',
    'ChildOrganizationSettingSamlStrictModeArgs',
    'ChildOrganizationUserArgs',
    'CloudConfigurationRuleFilterArgs',
    'DashboardListDashItemArgs',
    'DashboardTemplateVariableArgs',
    'DashboardTemplateVariablePresetArgs',
    'DashboardTemplateVariablePresetTemplateVariableArgs',
    'DashboardWidgetArgs',
    'DashboardWidgetAlertGraphDefinitionArgs',
    'DashboardWidgetAlertValueDefinitionArgs',
    'DashboardWidgetApmQueryArgs',
    'DashboardWidgetApmQueryComputeQueryArgs',
    'DashboardWidgetApmQueryGroupByArgs',
    'DashboardWidgetApmQueryGroupBySortQueryArgs',
    'DashboardWidgetApmQueryMultiComputeArgs',
    'DashboardWidgetChangeDefinitionArgs',
    'DashboardWidgetChangeDefinitionCustomLinkArgs',
    'DashboardWidgetChangeDefinitionRequestArgs',
    'DashboardWidgetChangeDefinitionRequestFormulaArgs',
    'DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetChangeDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetChangeDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetChangeDefinitionRequestProcessQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetCheckStatusDefinitionArgs',
    'DashboardWidgetDistributionDefinitionArgs',
    'DashboardWidgetDistributionDefinitionRequestArgs',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQueryArgs',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs',
    'DashboardWidgetDistributionDefinitionRequestProcessQueryArgs',
    'DashboardWidgetDistributionDefinitionRequestStyleArgs',
    'DashboardWidgetEventStreamDefinitionArgs',
    'DashboardWidgetEventTimelineDefinitionArgs',
    'DashboardWidgetFreeTextDefinitionArgs',
    'DashboardWidgetGeomapDefinitionArgs',
    'DashboardWidgetGeomapDefinitionCustomLinkArgs',
    'DashboardWidgetGeomapDefinitionRequestArgs',
    'DashboardWidgetGeomapDefinitionRequestFormulaArgs',
    'DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetGeomapDefinitionStyleArgs',
    'DashboardWidgetGeomapDefinitionViewArgs',
    'DashboardWidgetGroupDefinitionArgs',
    'DashboardWidgetGroupDefinitionWidgetArgs',
    'DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs',
    'DashboardWidgetHeatmapDefinitionArgs',
    'DashboardWidgetHeatmapDefinitionCustomLinkArgs',
    'DashboardWidgetHeatmapDefinitionEventArgs',
    'DashboardWidgetHeatmapDefinitionRequestArgs',
    'DashboardWidgetHeatmapDefinitionRequestFormulaArgs',
    'DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetHeatmapDefinitionRequestStyleArgs',
    'DashboardWidgetHeatmapDefinitionYaxisArgs',
    'DashboardWidgetHostmapDefinitionArgs',
    'DashboardWidgetHostmapDefinitionCustomLinkArgs',
    'DashboardWidgetHostmapDefinitionRequestArgs',
    'DashboardWidgetHostmapDefinitionRequestFillArgs',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeArgs',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs',
    'DashboardWidgetHostmapDefinitionStyleArgs',
    'DashboardWidgetIframeDefinitionArgs',
    'DashboardWidgetImageDefinitionArgs',
    'DashboardWidgetListStreamDefinitionArgs',
    'DashboardWidgetListStreamDefinitionRequestArgs',
    'DashboardWidgetListStreamDefinitionRequestColumnArgs',
    'DashboardWidgetListStreamDefinitionRequestQueryArgs',
    'DashboardWidgetListStreamDefinitionRequestQuerySortArgs',
    'DashboardWidgetLogQueryArgs',
    'DashboardWidgetLogQueryComputeQueryArgs',
    'DashboardWidgetLogQueryGroupByArgs',
    'DashboardWidgetLogQueryGroupBySortQueryArgs',
    'DashboardWidgetLogQueryMultiComputeArgs',
    'DashboardWidgetLogStreamDefinitionArgs',
    'DashboardWidgetLogStreamDefinitionSortArgs',
    'DashboardWidgetManageStatusDefinitionArgs',
    'DashboardWidgetNoteDefinitionArgs',
    'DashboardWidgetPowerpackDefinitionArgs',
    'DashboardWidgetPowerpackDefinitionTemplateVariablesArgs',
    'DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs',
    'DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs',
    'DashboardWidgetQueryTableDefinitionArgs',
    'DashboardWidgetQueryTableDefinitionCustomLinkArgs',
    'DashboardWidgetQueryTableDefinitionRequestArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetQueryTableDefinitionRequestFormulaArgs',
    'DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetQueryValueDefinitionArgs',
    'DashboardWidgetQueryValueDefinitionCustomLinkArgs',
    'DashboardWidgetQueryValueDefinitionRequestArgs',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetQueryValueDefinitionRequestFormulaArgs',
    'DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs',
    'DashboardWidgetRumQueryArgs',
    'DashboardWidgetRumQueryComputeQueryArgs',
    'DashboardWidgetRumQueryGroupByArgs',
    'DashboardWidgetRumQueryGroupBySortQueryArgs',
    'DashboardWidgetRumQueryMultiComputeArgs',
    'DashboardWidgetRunWorkflowDefinitionArgs',
    'DashboardWidgetRunWorkflowDefinitionCustomLinkArgs',
    'DashboardWidgetRunWorkflowDefinitionInputArgs',
    'DashboardWidgetScatterplotDefinitionArgs',
    'DashboardWidgetScatterplotDefinitionCustomLinkArgs',
    'DashboardWidgetScatterplotDefinitionRequestArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestXArgs',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs',
    'DashboardWidgetScatterplotDefinitionRequestYArgs',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs',
    'DashboardWidgetScatterplotDefinitionXaxisArgs',
    'DashboardWidgetScatterplotDefinitionYaxisArgs',
    'DashboardWidgetSecurityQueryArgs',
    'DashboardWidgetSecurityQueryComputeQueryArgs',
    'DashboardWidgetSecurityQueryGroupByArgs',
    'DashboardWidgetSecurityQueryGroupBySortQueryArgs',
    'DashboardWidgetSecurityQueryMultiComputeArgs',
    'DashboardWidgetServiceLevelObjectiveDefinitionArgs',
    'DashboardWidgetServicemapDefinitionArgs',
    'DashboardWidgetServicemapDefinitionCustomLinkArgs',
    'DashboardWidgetSloListDefinitionArgs',
    'DashboardWidgetSloListDefinitionRequestArgs',
    'DashboardWidgetSloListDefinitionRequestQueryArgs',
    'DashboardWidgetSloListDefinitionRequestQuerySortArgs',
    'DashboardWidgetSplitGraphDefinitionArgs',
    'DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs',
    'DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs',
    'DashboardWidgetSunburstDefinitionArgs',
    'DashboardWidgetSunburstDefinitionCustomLinkArgs',
    'DashboardWidgetSunburstDefinitionLegendInlineArgs',
    'DashboardWidgetSunburstDefinitionLegendTableArgs',
    'DashboardWidgetSunburstDefinitionRequestArgs',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs',
    'DashboardWidgetSunburstDefinitionRequestFormulaArgs',
    'DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs',
    'DashboardWidgetSunburstDefinitionRequestProcessQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetSunburstDefinitionRequestStyleArgs',
    'DashboardWidgetTimeseriesDefinitionArgs',
    'DashboardWidgetTimeseriesDefinitionCustomLinkArgs',
    'DashboardWidgetTimeseriesDefinitionEventArgs',
    'DashboardWidgetTimeseriesDefinitionMarkerArgs',
    'DashboardWidgetTimeseriesDefinitionRequestArgs',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaArgs',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetTimeseriesDefinitionRequestMetadataArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetTimeseriesDefinitionRequestStyleArgs',
    'DashboardWidgetTimeseriesDefinitionRightYaxisArgs',
    'DashboardWidgetTimeseriesDefinitionYaxisArgs',
    'DashboardWidgetToplistDefinitionArgs',
    'DashboardWidgetToplistDefinitionCustomLinkArgs',
    'DashboardWidgetToplistDefinitionRequestArgs',
    'DashboardWidgetToplistDefinitionRequestAuditQueryArgs',
    'DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs',
    'DashboardWidgetToplistDefinitionRequestConditionalFormatArgs',
    'DashboardWidgetToplistDefinitionRequestFormulaArgs',
    'DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetToplistDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetToplistDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetToplistDefinitionRequestProcessQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetToplistDefinitionRequestStyleArgs',
    'DashboardWidgetTopologyMapDefinitionArgs',
    'DashboardWidgetTopologyMapDefinitionCustomLinkArgs',
    'DashboardWidgetTopologyMapDefinitionRequestArgs',
    'DashboardWidgetTopologyMapDefinitionRequestQueryArgs',
    'DashboardWidgetTraceServiceDefinitionArgs',
    'DashboardWidgetTreemapDefinitionArgs',
    'DashboardWidgetTreemapDefinitionRequestArgs',
    'DashboardWidgetTreemapDefinitionRequestFormulaArgs',
    'DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs',
    'DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs',
    'DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs',
    'DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs',
    'DashboardWidgetWidgetLayoutArgs',
    'DowntimeRecurrenceArgs',
    'DowntimeScheduleMonitorIdentifierArgs',
    'DowntimeScheduleOneTimeScheduleArgs',
    'DowntimeScheduleRecurringScheduleArgs',
    'DowntimeScheduleRecurringScheduleRecurrenceArgs',
    'IpAllowlistEntryArgs',
    'LogsArchiveAzureArchiveArgs',
    'LogsArchiveGcsArchiveArgs',
    'LogsArchiveS3ArchiveArgs',
    'LogsCustomPipelineFilterArgs',
    'LogsCustomPipelineProcessorArgs',
    'LogsCustomPipelineProcessorArithmeticProcessorArgs',
    'LogsCustomPipelineProcessorAttributeRemapperArgs',
    'LogsCustomPipelineProcessorCategoryProcessorArgs',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryArgs',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs',
    'LogsCustomPipelineProcessorDateRemapperArgs',
    'LogsCustomPipelineProcessorGeoIpParserArgs',
    'LogsCustomPipelineProcessorGrokParserArgs',
    'LogsCustomPipelineProcessorGrokParserGrokArgs',
    'LogsCustomPipelineProcessorLookupProcessorArgs',
    'LogsCustomPipelineProcessorMessageRemapperArgs',
    'LogsCustomPipelineProcessorPipelineArgs',
    'LogsCustomPipelineProcessorPipelineFilterArgs',
    'LogsCustomPipelineProcessorPipelineProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs',
    'LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs',
    'LogsCustomPipelineProcessorServiceRemapperArgs',
    'LogsCustomPipelineProcessorStatusRemapperArgs',
    'LogsCustomPipelineProcessorStringBuilderProcessorArgs',
    'LogsCustomPipelineProcessorTraceIdRemapperArgs',
    'LogsCustomPipelineProcessorUrlParserArgs',
    'LogsCustomPipelineProcessorUserAgentParserArgs',
    'LogsIndexDailyLimitResetArgs',
    'LogsIndexExclusionFilterArgs',
    'LogsIndexExclusionFilterFilterArgs',
    'LogsIndexFilterArgs',
    'LogsMetricComputeArgs',
    'LogsMetricFilterArgs',
    'LogsMetricGroupByArgs',
    'MetricTagConfigurationAggregationArgs',
    'MonitorConfigPolicyTagPolicyArgs',
    'MonitorMonitorThresholdWindowsArgs',
    'MonitorMonitorThresholdsArgs',
    'MonitorSchedulingOptionArgs',
    'MonitorSchedulingOptionCustomScheduleArgs',
    'MonitorSchedulingOptionCustomScheduleRecurrenceArgs',
    'MonitorSchedulingOptionEvaluationWindowArgs',
    'MonitorVariablesArgs',
    'MonitorVariablesEventQueryArgs',
    'MonitorVariablesEventQueryComputeArgs',
    'MonitorVariablesEventQueryGroupByArgs',
    'MonitorVariablesEventQueryGroupBySortArgs',
    'MonitorVariablesEventQuerySearchArgs',
    'OrganizationSettingsSettingsArgs',
    'OrganizationSettingsSettingsSamlArgs',
    'OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs',
    'OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs',
    'OrganizationSettingsSettingsSamlStrictModeArgs',
    'PowerpackLayoutArgs',
    'PowerpackTemplateVariableArgs',
    'PowerpackWidgetArgs',
    'PowerpackWidgetAlertGraphDefinitionArgs',
    'PowerpackWidgetAlertValueDefinitionArgs',
    'PowerpackWidgetChangeDefinitionArgs',
    'PowerpackWidgetChangeDefinitionCustomLinkArgs',
    'PowerpackWidgetChangeDefinitionRequestArgs',
    'PowerpackWidgetChangeDefinitionRequestApmQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetChangeDefinitionRequestFormulaArgs',
    'PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetChangeDefinitionRequestLogQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetChangeDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestRumQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetCheckStatusDefinitionArgs',
    'PowerpackWidgetDistributionDefinitionArgs',
    'PowerpackWidgetDistributionDefinitionRequestArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmStatsQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetDistributionDefinitionRequestStyleArgs',
    'PowerpackWidgetEventStreamDefinitionArgs',
    'PowerpackWidgetEventTimelineDefinitionArgs',
    'PowerpackWidgetFreeTextDefinitionArgs',
    'PowerpackWidgetGeomapDefinitionArgs',
    'PowerpackWidgetGeomapDefinitionCustomLinkArgs',
    'PowerpackWidgetGeomapDefinitionRequestArgs',
    'PowerpackWidgetGeomapDefinitionRequestFormulaArgs',
    'PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetGeomapDefinitionStyleArgs',
    'PowerpackWidgetGeomapDefinitionViewArgs',
    'PowerpackWidgetHeatmapDefinitionArgs',
    'PowerpackWidgetHeatmapDefinitionCustomLinkArgs',
    'PowerpackWidgetHeatmapDefinitionEventArgs',
    'PowerpackWidgetHeatmapDefinitionRequestArgs',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaArgs',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetHeatmapDefinitionRequestStyleArgs',
    'PowerpackWidgetHeatmapDefinitionYaxisArgs',
    'PowerpackWidgetHostmapDefinitionArgs',
    'PowerpackWidgetHostmapDefinitionCustomLinkArgs',
    'PowerpackWidgetHostmapDefinitionRequestArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs',
    'PowerpackWidgetHostmapDefinitionStyleArgs',
    'PowerpackWidgetIframeDefinitionArgs',
    'PowerpackWidgetImageDefinitionArgs',
    'PowerpackWidgetListStreamDefinitionArgs',
    'PowerpackWidgetListStreamDefinitionRequestArgs',
    'PowerpackWidgetListStreamDefinitionRequestColumnArgs',
    'PowerpackWidgetListStreamDefinitionRequestQueryArgs',
    'PowerpackWidgetListStreamDefinitionRequestQuerySortArgs',
    'PowerpackWidgetLogStreamDefinitionArgs',
    'PowerpackWidgetLogStreamDefinitionSortArgs',
    'PowerpackWidgetManageStatusDefinitionArgs',
    'PowerpackWidgetNoteDefinitionArgs',
    'PowerpackWidgetQueryTableDefinitionArgs',
    'PowerpackWidgetQueryTableDefinitionCustomLinkArgs',
    'PowerpackWidgetQueryTableDefinitionRequestArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs',
    'PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaArgs',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionArgs',
    'PowerpackWidgetQueryValueDefinitionCustomLinkArgs',
    'PowerpackWidgetQueryValueDefinitionRequestArgs',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaArgs',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs',
    'PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs',
    'PowerpackWidgetRunWorkflowDefinitionArgs',
    'PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs',
    'PowerpackWidgetRunWorkflowDefinitionInputArgs',
    'PowerpackWidgetScatterplotDefinitionArgs',
    'PowerpackWidgetScatterplotDefinitionCustomLinkArgs',
    'PowerpackWidgetScatterplotDefinitionRequestArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs',
    'PowerpackWidgetScatterplotDefinitionXaxisArgs',
    'PowerpackWidgetScatterplotDefinitionYaxisArgs',
    'PowerpackWidgetServiceLevelObjectiveDefinitionArgs',
    'PowerpackWidgetServicemapDefinitionArgs',
    'PowerpackWidgetServicemapDefinitionCustomLinkArgs',
    'PowerpackWidgetSloListDefinitionArgs',
    'PowerpackWidgetSloListDefinitionRequestArgs',
    'PowerpackWidgetSloListDefinitionRequestQueryArgs',
    'PowerpackWidgetSloListDefinitionRequestQuerySortArgs',
    'PowerpackWidgetSunburstDefinitionArgs',
    'PowerpackWidgetSunburstDefinitionCustomLinkArgs',
    'PowerpackWidgetSunburstDefinitionLegendInlineArgs',
    'PowerpackWidgetSunburstDefinitionLegendTableArgs',
    'PowerpackWidgetSunburstDefinitionRequestArgs',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestFormulaArgs',
    'PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetSunburstDefinitionRequestStyleArgs',
    'PowerpackWidgetTimeseriesDefinitionArgs',
    'PowerpackWidgetTimeseriesDefinitionCustomLinkArgs',
    'PowerpackWidgetTimeseriesDefinitionEventArgs',
    'PowerpackWidgetTimeseriesDefinitionMarkerArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetTimeseriesDefinitionRequestStyleArgs',
    'PowerpackWidgetTimeseriesDefinitionRightYaxisArgs',
    'PowerpackWidgetTimeseriesDefinitionYaxisArgs',
    'PowerpackWidgetToplistDefinitionArgs',
    'PowerpackWidgetToplistDefinitionCustomLinkArgs',
    'PowerpackWidgetToplistDefinitionRequestArgs',
    'PowerpackWidgetToplistDefinitionRequestApmQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs',
    'PowerpackWidgetToplistDefinitionRequestFormulaArgs',
    'PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetToplistDefinitionRequestLogQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestProcessQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestRumQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs',
    'PowerpackWidgetToplistDefinitionRequestStyleArgs',
    'PowerpackWidgetTopologyMapDefinitionArgs',
    'PowerpackWidgetTopologyMapDefinitionCustomLinkArgs',
    'PowerpackWidgetTopologyMapDefinitionRequestArgs',
    'PowerpackWidgetTopologyMapDefinitionRequestQueryArgs',
    'PowerpackWidgetTraceServiceDefinitionArgs',
    'PowerpackWidgetTreemapDefinitionArgs',
    'PowerpackWidgetTreemapDefinitionRequestArgs',
    'PowerpackWidgetTreemapDefinitionRequestFormulaArgs',
    'PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs',
    'PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs',
    'PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs',
    'PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs',
    'PowerpackWidgetWidgetLayoutArgs',
    'RestrictionPolicyBindingArgs',
    'RolePermissionArgs',
    'SecurityMonitoringDefaultRuleCaseArgs',
    'SecurityMonitoringDefaultRuleFilterArgs',
    'SecurityMonitoringDefaultRuleOptionsArgs',
    'SecurityMonitoringFilterExclusionFilterArgs',
    'SecurityMonitoringRuleCaseArgs',
    'SecurityMonitoringRuleFilterArgs',
    'SecurityMonitoringRuleOptionsArgs',
    'SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs',
    'SecurityMonitoringRuleOptionsNewValueOptionsArgs',
    'SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs',
    'SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs',
    'SecurityMonitoringRuleQueryArgs',
    'SecurityMonitoringRuleQueryAgentRuleArgs',
    'SecurityMonitoringRuleSignalQueryArgs',
    'SecurityMonitoringRuleThirdPartyCaseArgs',
    'SensitiveDataScannerGroupFilterArgs',
    'SensitiveDataScannerRuleIncludedKeywordConfigurationArgs',
    'SensitiveDataScannerRuleTextReplacementArgs',
    'ServiceLevelObjectiveQueryArgs',
    'ServiceLevelObjectiveSliSpecificationArgs',
    'ServiceLevelObjectiveSliSpecificationTimeSliceArgs',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs',
    'ServiceLevelObjectiveThresholdArgs',
    'SpansMetricComputeArgs',
    'SpansMetricFilterArgs',
    'SpansMetricGroupByArgs',
    'SyntheticsGlobalVariableOptionsArgs',
    'SyntheticsGlobalVariableOptionsTotpParametersArgs',
    'SyntheticsGlobalVariableParseTestOptionsArgs',
    'SyntheticsGlobalVariableParseTestOptionsParserArgs',
    'SyntheticsPrivateLocationMetadataArgs',
    'SyntheticsTestApiStepArgs',
    'SyntheticsTestApiStepAssertionArgs',
    'SyntheticsTestApiStepAssertionTargetjsonpathArgs',
    'SyntheticsTestApiStepAssertionTargetxpathArgs',
    'SyntheticsTestApiStepExtractedValueArgs',
    'SyntheticsTestApiStepExtractedValueParserArgs',
    'SyntheticsTestApiStepRequestBasicauthArgs',
    'SyntheticsTestApiStepRequestClientCertificateArgs',
    'SyntheticsTestApiStepRequestClientCertificateCertArgs',
    'SyntheticsTestApiStepRequestClientCertificateKeyArgs',
    'SyntheticsTestApiStepRequestDefinitionArgs',
    'SyntheticsTestApiStepRequestProxyArgs',
    'SyntheticsTestApiStepRetryArgs',
    'SyntheticsTestAssertionArgs',
    'SyntheticsTestAssertionTargetjsonpathArgs',
    'SyntheticsTestAssertionTargetxpathArgs',
    'SyntheticsTestBrowserStepArgs',
    'SyntheticsTestBrowserStepParamsArgs',
    'SyntheticsTestBrowserStepParamsElementUserLocatorArgs',
    'SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs',
    'SyntheticsTestBrowserStepParamsVariableArgs',
    'SyntheticsTestBrowserVariableArgs',
    'SyntheticsTestConfigVariableArgs',
    'SyntheticsTestOptionsListArgs',
    'SyntheticsTestOptionsListCiArgs',
    'SyntheticsTestOptionsListMonitorOptionsArgs',
    'SyntheticsTestOptionsListRetryArgs',
    'SyntheticsTestOptionsListRumSettingsArgs',
    'SyntheticsTestOptionsListSchedulingArgs',
    'SyntheticsTestOptionsListSchedulingTimeframeArgs',
    'SyntheticsTestRequestBasicauthArgs',
    'SyntheticsTestRequestClientCertificateArgs',
    'SyntheticsTestRequestClientCertificateCertArgs',
    'SyntheticsTestRequestClientCertificateKeyArgs',
    'SyntheticsTestRequestDefinitionArgs',
    'SyntheticsTestRequestProxyArgs',
]

@pulumi.input_type
class ApmRetentionFilterFilterArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The search query - following the span search syntax. Defaults to `"*"`.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query - following the span search syntax. Defaults to `"*"`.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class ChildOrganizationApiKeyArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: API key.
        :param pulumi.Input[str] name: Name of your API key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of your API key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ChildOrganizationApplicationKeyArgs:
    def __init__(__self__, *,
                 hash: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hash: Hash of an application key.
        :param pulumi.Input[str] name: Name of an application key.
        :param pulumi.Input[str] owner: Owner of an application key.
        """
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[str]]:
        """
        Hash of an application key.
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of an application key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of an application key.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)


@pulumi.input_type
class ChildOrganizationSettingArgs:
    def __init__(__self__, *,
                 private_widget_share: Optional[pulumi.Input[bool]] = None,
                 saml_autocreate_access_role: Optional[pulumi.Input[str]] = None,
                 saml_autocreate_users_domains: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlAutocreateUsersDomainArgs']]]] = None,
                 saml_can_be_enabled: Optional[pulumi.Input[bool]] = None,
                 saml_idp_endpoint: Optional[pulumi.Input[str]] = None,
                 saml_idp_initiated_logins: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlIdpInitiatedLoginArgs']]]] = None,
                 saml_idp_metadata_uploaded: Optional[pulumi.Input[bool]] = None,
                 saml_login_url: Optional[pulumi.Input[str]] = None,
                 saml_strict_modes: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlStrictModeArgs']]]] = None,
                 samls: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlArgs']]]] = None):
        """
        :param pulumi.Input[bool] private_widget_share: Whether or not the organization users can share widgets outside of Datadog.
        :param pulumi.Input[str] saml_autocreate_access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        :param pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlAutocreateUsersDomainArgs']]] saml_autocreate_users_domains: List of domains where the SAML automated user creation is enabled.
        :param pulumi.Input[bool] saml_can_be_enabled: Whether or not SAML can be enabled for this organization.
        :param pulumi.Input[str] saml_idp_endpoint: Identity provider endpoint for SAML authentication.
        :param pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlIdpInitiatedLoginArgs']]] saml_idp_initiated_logins: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param pulumi.Input[bool] saml_idp_metadata_uploaded: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param pulumi.Input[str] saml_login_url: URL for SAML logging.
        :param pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlStrictModeArgs']]] saml_strict_modes: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        :param pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlArgs']]] samls: SAML properties
        """
        if private_widget_share is not None:
            pulumi.set(__self__, "private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            pulumi.set(__self__, "saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_autocreate_users_domains is not None:
            pulumi.set(__self__, "saml_autocreate_users_domains", saml_autocreate_users_domains)
        if saml_can_be_enabled is not None:
            pulumi.set(__self__, "saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            pulumi.set(__self__, "saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_initiated_logins is not None:
            pulumi.set(__self__, "saml_idp_initiated_logins", saml_idp_initiated_logins)
        if saml_idp_metadata_uploaded is not None:
            pulumi.set(__self__, "saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            pulumi.set(__self__, "saml_login_url", saml_login_url)
        if saml_strict_modes is not None:
            pulumi.set(__self__, "saml_strict_modes", saml_strict_modes)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the organization users can share widgets outside of Datadog.
        """
        return pulumi.get(self, "private_widget_share")

    @private_widget_share.setter
    def private_widget_share(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_widget_share", value)

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[pulumi.Input[str]]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        """
        return pulumi.get(self, "saml_autocreate_access_role")

    @saml_autocreate_access_role.setter
    def saml_autocreate_access_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_autocreate_access_role", value)

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlAutocreateUsersDomainArgs']]]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "saml_autocreate_users_domains")

    @saml_autocreate_users_domains.setter
    def saml_autocreate_users_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlAutocreateUsersDomainArgs']]]]):
        pulumi.set(self, "saml_autocreate_users_domains", value)

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML can be enabled for this organization.
        """
        return pulumi.get(self, "saml_can_be_enabled")

    @saml_can_be_enabled.setter
    def saml_can_be_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "saml_can_be_enabled", value)

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Identity provider endpoint for SAML authentication.
        """
        return pulumi.get(self, "saml_idp_endpoint")

    @saml_idp_endpoint.setter
    def saml_idp_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_idp_endpoint", value)

    @property
    @pulumi.getter(name="samlIdpInitiatedLogins")
    def saml_idp_initiated_logins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlIdpInitiatedLoginArgs']]]]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_initiated_logins")

    @saml_idp_initiated_logins.setter
    def saml_idp_initiated_logins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlIdpInitiatedLoginArgs']]]]):
        pulumi.set(self, "saml_idp_initiated_logins", value)

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @saml_idp_metadata_uploaded.setter
    def saml_idp_metadata_uploaded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "saml_idp_metadata_uploaded", value)

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for SAML logging.
        """
        return pulumi.get(self, "saml_login_url")

    @saml_login_url.setter
    def saml_login_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_login_url", value)

    @property
    @pulumi.getter(name="samlStrictModes")
    def saml_strict_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlStrictModeArgs']]]]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "saml_strict_modes")

    @saml_strict_modes.setter
    def saml_strict_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlStrictModeArgs']]]]):
        pulumi.set(self, "saml_strict_modes", value)

    @property
    @pulumi.getter
    def samls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlArgs']]]]:
        """
        SAML properties
        """
        return pulumi.get(self, "samls")

    @samls.setter
    def samls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChildOrganizationSettingSamlArgs']]]]):
        pulumi.set(self, "samls", value)


@pulumi.input_type
class ChildOrganizationSettingSamlArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML is enabled for this organization.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ChildOrganizationSettingSamlAutocreateUsersDomainArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: List of domains where the SAML automated user creation is enabled.
        :param pulumi.Input[bool] enabled: Whether or not the automated user creation based on SAML domain is enabled.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the automated user creation based on SAML domain is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ChildOrganizationSettingSamlIdpInitiatedLoginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ChildOrganizationSettingSamlStrictModeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ChildOrganizationUserArgs:
    def __init__(__self__, *,
                 access_role: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
        :param pulumi.Input[str] email: The new email of the user.
        :param pulumi.Input[str] name: The name of the user.
        """
        if access_role is not None:
            pulumi.set(__self__, "access_role", access_role)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="accessRole")
    def access_role(self) -> Optional[pulumi.Input[str]]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
        """
        return pulumi.get(self, "access_role")

    @access_role.setter
    def access_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_role", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The new email of the user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CloudConfigurationRuleFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The type of filtering action. Valid values are `require`, `suppress`.
        :param pulumi.Input[str] query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardListDashItemArgs:
    def __init__(__self__, *,
                 dash_id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dash_id: The ID of the dashboard to add
        :param pulumi.Input[str] type: The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        pulumi.set(__self__, "dash_id", dash_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> pulumi.Input[str]:
        """
        The ID of the dashboard to add
        """
        return pulumi.get(self, "dash_id")

    @dash_id.setter
    def dash_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dash_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 available_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default: Optional[pulumi.Input[str]] = None,
                 defaults: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] available_values: The list of values that the template variable drop-down is be limited to
        :param pulumi.Input[str] default: The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] defaults: One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        :param pulumi.Input[str] prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        if available_values is not None:
            pulumi.set(__self__, "available_values", available_values)
        if default is not None:
            warnings.warn("""Use `defaults` instead.""", DeprecationWarning)
            pulumi.log.warn("""default is deprecated: Use `defaults` instead.""")
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="availableValues")
    def available_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of values that the template variable drop-down is be limited to
        """
        return pulumi.get(self, "available_values")

    @available_values.setter
    def available_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "available_values", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `defaults` instead.""")
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def defaults(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        """
        return pulumi.get(self, "defaults")

    @defaults.setter
    def defaults(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "defaults", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class DashboardTemplateVariablePresetArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 template_variables: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the preset.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]] template_variables: The template variable names and assumed values under the given preset
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the preset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]]:
        """
        The template variable names and assumed values under the given preset
        """
        return pulumi.get(self, "template_variables")

    @template_variables.setter
    def template_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardTemplateVariablePresetTemplateVariableArgs']]]]):
        pulumi.set(self, "template_variables", value)


@pulumi.input_type
class DashboardTemplateVariablePresetTemplateVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the template variable
        :param pulumi.Input[str] value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            warnings.warn("""Use `values` instead.""", DeprecationWarning)
            pulumi.log.warn("""value is deprecated: Use `values` instead.""")
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the template variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `values` instead.""")
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DashboardWidgetArgs:
    def __init__(__self__, *,
                 alert_graph_definition: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']] = None,
                 alert_value_definition: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']] = None,
                 change_definition: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']] = None,
                 check_status_definition: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']] = None,
                 distribution_definition: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']] = None,
                 event_stream_definition: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']] = None,
                 event_timeline_definition: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']] = None,
                 free_text_definition: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']] = None,
                 geomap_definition: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']] = None,
                 group_definition: Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']] = None,
                 heatmap_definition: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']] = None,
                 hostmap_definition: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 iframe_definition: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']] = None,
                 image_definition: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']] = None,
                 list_stream_definition: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']] = None,
                 log_stream_definition: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']] = None,
                 manage_status_definition: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']] = None,
                 note_definition: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']] = None,
                 powerpack_definition: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']] = None,
                 run_workflow_definition: Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']] = None,
                 service_level_objective_definition: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']] = None,
                 servicemap_definition: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']] = None,
                 slo_list_definition: Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']] = None,
                 split_graph_definition: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']] = None,
                 sunburst_definition: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']] = None,
                 topology_map_definition: Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']] = None,
                 trace_service_definition: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']] = None,
                 treemap_definition: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']] = None,
                 widget_layout: Optional[pulumi.Input['DashboardWidgetWidgetLayoutArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs'] alert_graph_definition: The definition for a Alert Graph widget.
        :param pulumi.Input['DashboardWidgetAlertValueDefinitionArgs'] alert_value_definition: The definition for a Alert Value widget.
        :param pulumi.Input['DashboardWidgetChangeDefinitionArgs'] change_definition: The definition for a Change widget.
        :param pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs'] check_status_definition: The definition for a Check Status widget.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionArgs'] distribution_definition: The definition for a Distribution widget.
        :param pulumi.Input['DashboardWidgetEventStreamDefinitionArgs'] event_stream_definition: The definition for a Event Stream widget.
        :param pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs'] event_timeline_definition: The definition for a Event Timeline widget.
        :param pulumi.Input['DashboardWidgetFreeTextDefinitionArgs'] free_text_definition: The definition for a Free Text widget.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionArgs'] geomap_definition: The definition for a Geomap widget.
        :param pulumi.Input['DashboardWidgetGroupDefinitionArgs'] group_definition: The definition for a Group widget.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionArgs'] heatmap_definition: The definition for a Heatmap widget.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionArgs'] hostmap_definition: The definition for a Hostmap widget.
        :param pulumi.Input[int] id: The ID of the widget.
        :param pulumi.Input['DashboardWidgetIframeDefinitionArgs'] iframe_definition: The definition for an Iframe widget.
        :param pulumi.Input['DashboardWidgetImageDefinitionArgs'] image_definition: The definition for an Image widget
        :param pulumi.Input['DashboardWidgetListStreamDefinitionArgs'] list_stream_definition: The definition for a List Stream widget.
        :param pulumi.Input['DashboardWidgetLogStreamDefinitionArgs'] log_stream_definition: The definition for an Log Stream widget.
        :param pulumi.Input['DashboardWidgetManageStatusDefinitionArgs'] manage_status_definition: The definition for an Manage Status widget.
        :param pulumi.Input['DashboardWidgetNoteDefinitionArgs'] note_definition: The definition for a Note widget.
        :param pulumi.Input['DashboardWidgetPowerpackDefinitionArgs'] powerpack_definition: The definition for a Powerpack widget.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionArgs'] query_table_definition: The definition for a Query Table widget.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionArgs'] query_value_definition: The definition for a Query Value widget.
        :param pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs'] run_workflow_definition: The definition for a Run Workflow widget.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionArgs'] scatterplot_definition: The definition for a Scatterplot widget.
        :param pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs'] service_level_objective_definition: The definition for a Service Level Objective widget.
        :param pulumi.Input['DashboardWidgetServicemapDefinitionArgs'] servicemap_definition: The definition for a Service Map widget.
        :param pulumi.Input['DashboardWidgetSloListDefinitionArgs'] slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs'] split_graph_definition: The definition for a Split Graph widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionArgs'] sunburst_definition: The definition for a Sunburst widget.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs'] timeseries_definition: The definition for a Timeseries widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionArgs'] toplist_definition: The definition for a Toplist widget.
        :param pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs'] topology_map_definition: The definition for a Topology Map widget.
        :param pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs'] trace_service_definition: The definition for a Trace Service widget.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionArgs'] treemap_definition: The definition for a Treemap widget.
        :param pulumi.Input['DashboardWidgetWidgetLayoutArgs'] widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if group_definition is not None:
            pulumi.set(__self__, "group_definition", group_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if powerpack_definition is not None:
            pulumi.set(__self__, "powerpack_definition", powerpack_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if split_graph_definition is not None:
            pulumi.set(__self__, "split_graph_definition", split_graph_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @alert_graph_definition.setter
    def alert_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]):
        pulumi.set(self, "alert_graph_definition", value)

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @alert_value_definition.setter
    def alert_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]):
        pulumi.set(self, "alert_value_definition", value)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @check_status_definition.setter
    def check_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]):
        pulumi.set(self, "check_status_definition", value)

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @distribution_definition.setter
    def distribution_definition(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]):
        pulumi.set(self, "distribution_definition", value)

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @event_stream_definition.setter
    def event_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]):
        pulumi.set(self, "event_stream_definition", value)

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @event_timeline_definition.setter
    def event_timeline_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]):
        pulumi.set(self, "event_timeline_definition", value)

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @free_text_definition.setter
    def free_text_definition(self, value: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]):
        pulumi.set(self, "free_text_definition", value)

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @geomap_definition.setter
    def geomap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]):
        pulumi.set(self, "geomap_definition", value)

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']]:
        """
        The definition for a Group widget.
        """
        return pulumi.get(self, "group_definition")

    @group_definition.setter
    def group_definition(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionArgs']]):
        pulumi.set(self, "group_definition", value)

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @heatmap_definition.setter
    def heatmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]):
        pulumi.set(self, "heatmap_definition", value)

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @hostmap_definition.setter
    def hostmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]):
        pulumi.set(self, "hostmap_definition", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @iframe_definition.setter
    def iframe_definition(self, value: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]):
        pulumi.set(self, "iframe_definition", value)

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @image_definition.setter
    def image_definition(self, value: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]):
        pulumi.set(self, "image_definition", value)

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']]:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @list_stream_definition.setter
    def list_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']]):
        pulumi.set(self, "list_stream_definition", value)

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @log_stream_definition.setter
    def log_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]):
        pulumi.set(self, "log_stream_definition", value)

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @manage_status_definition.setter
    def manage_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]):
        pulumi.set(self, "manage_status_definition", value)

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @note_definition.setter
    def note_definition(self, value: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]):
        pulumi.set(self, "note_definition", value)

    @property
    @pulumi.getter(name="powerpackDefinition")
    def powerpack_definition(self) -> Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']]:
        """
        The definition for a Powerpack widget.
        """
        return pulumi.get(self, "powerpack_definition")

    @powerpack_definition.setter
    def powerpack_definition(self, value: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']]):
        pulumi.set(self, "powerpack_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']]:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @run_workflow_definition.setter
    def run_workflow_definition(self, value: Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']]):
        pulumi.set(self, "run_workflow_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @service_level_objective_definition.setter
    def service_level_objective_definition(self, value: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]):
        pulumi.set(self, "service_level_objective_definition", value)

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @servicemap_definition.setter
    def servicemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]):
        pulumi.set(self, "servicemap_definition", value)

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']]:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @slo_list_definition.setter
    def slo_list_definition(self, value: Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']]):
        pulumi.set(self, "slo_list_definition", value)

    @property
    @pulumi.getter(name="splitGraphDefinition")
    def split_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']]:
        """
        The definition for a Split Graph widget.
        """
        return pulumi.get(self, "split_graph_definition")

    @split_graph_definition.setter
    def split_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']]):
        pulumi.set(self, "split_graph_definition", value)

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @sunburst_definition.setter
    def sunburst_definition(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]):
        pulumi.set(self, "sunburst_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']]:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @topology_map_definition.setter
    def topology_map_definition(self, value: Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']]):
        pulumi.set(self, "topology_map_definition", value)

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @trace_service_definition.setter
    def trace_service_definition(self, value: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]):
        pulumi.set(self, "trace_service_definition", value)

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @treemap_definition.setter
    def treemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]):
        pulumi.set(self, "treemap_definition", value)

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional[pulumi.Input['DashboardWidgetWidgetLayoutArgs']]:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")

    @widget_layout.setter
    def widget_layout(self, value: Optional[pulumi.Input['DashboardWidgetWidgetLayoutArgs']]):
        pulumi.set(self, "widget_layout", value)


@pulumi.input_type
class DashboardWidgetAlertGraphDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 viz_type: pulumi.Input[str],
                 live_span: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alert_id: The ID of the monitor used by the widget.
        :param pulumi.Input[str] viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> pulumi.Input[str]:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @viz_type.setter
    def viz_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz_type", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetAlertValueDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 precision: Optional[pulumi.Input[int]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alert_id: The ID of the monitor used by the widget.
        :param pulumi.Input[int] precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input[str] unit: The unit for the value displayed in the widget.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


@pulumi.input_type
class DashboardWidgetApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaArgs']]]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_dir: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 show_present: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input[str] change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param pulumi.Input[str] compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param pulumi.Input[bool] increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param pulumi.Input[str] order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input[bool] show_present: If set to `true`, displays the current value.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @order_dir.setter
    def order_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_dir", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")

    @show_present.setter
    def show_present(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_present", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetCheckStatusDefinitionArgs:
    def __init__(__self__, *,
                 check: pulumi.Input[str],
                 grouping: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check: The check to use in the widget.
        :param pulumi.Input[str] grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param pulumi.Input[str] group: The check group to use in the widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags to use in the widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> pulumi.Input[str]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: pulumi.Input[str]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter
    def grouping(self) -> pulumi.Input[str]:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @grouping.setter
    def grouping(self, value: pulumi.Input[str]):
        pulumi.set(self, "grouping", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionArgs:
    def __init__(__self__, *,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 apm_stats_query: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryArgs']]:
        return pulumi.get(self, "apm_stats_query")

    @apm_stats_query.setter
    def apm_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryArgs']]):
        pulumi.set(self, "apm_stats_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQueryArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 primary_tag: pulumi.Input[str],
                 row_type: pulumi.Input[str],
                 service: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: The environment name.
        :param pulumi.Input[str] name: The operation name associated with the service.
        :param pulumi.Input[str] primary_tag: The organization's host group name and value.
        :param pulumi.Input[str] row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param pulumi.Input[str] service: The service name.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]] columns: Column properties used by the front end for display.
        :param pulumi.Input[str] resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> pulumi.Input[str]:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @primary_tag.setter
    def primary_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_tag", value)

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> pulumi.Input[str]:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @row_type.setter
    def row_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_type", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The column name.
        :param pulumi.Input[str] alias: A user-assigned alias for the column.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetDistributionDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetEventStreamDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetEventTimelineDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetFreeTextDefinitionArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 text_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: The text to display in the widget.
        :param pulumi.Input[str] color: The color of the text in the widget.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionArgs:
    def __init__(__self__, *,
                 view: pulumi.Input['DashboardWidgetGeomapDefinitionViewArgs'],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestArgs']]]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DashboardWidgetGeomapDefinitionViewArgs'] view: The view of the world that the map should render.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param pulumi.Input['DashboardWidgetGeomapDefinitionStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> pulumi.Input['DashboardWidgetGeomapDefinitionViewArgs']:
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: pulumi.Input['DashboardWidgetGeomapDefinitionViewArgs']):
        pulumi.set(self, "view", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        """
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionStyleArgs:
    def __init__(__self__, *,
                 palette: pulumi.Input[str],
                 palette_flip: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] palette: The color palette to apply to the widget.
        :param pulumi.Input[bool] palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply to the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> pulumi.Input[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: pulumi.Input[bool]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class DashboardWidgetGeomapDefinitionViewArgs:
    def __init__(__self__, *,
                 focus: pulumi.Input[str]):
        """
        :param pulumi.Input[str] focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> pulumi.Input[str]:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")

    @focus.setter
    def focus(self, value: pulumi.Input[str]):
        pulumi.set(self, "focus", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionArgs:
    def __init__(__self__, *,
                 layout_type: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 banner_img: Optional[pulumi.Input[str]] = None,
                 show_title: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 widgets: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]]] = None):
        """
        :param pulumi.Input[str] layout_type: The layout type of the group. Valid values are `ordered`.
        :param pulumi.Input[str] background_color: The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        :param pulumi.Input[str] banner_img: The image URL to display as a banner for the group.
        :param pulumi.Input[bool] show_title: Whether to show the title or not. Defaults to `true`.
        :param pulumi.Input[str] title: The title of the group.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]] widgets: The list of widgets in this group.
        """
        pulumi.set(__self__, "layout_type", layout_type)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if banner_img is not None:
            pulumi.set(__self__, "banner_img", banner_img)
        if show_title is not None:
            pulumi.set(__self__, "show_title", show_title)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if widgets is not None:
            pulumi.set(__self__, "widgets", widgets)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> pulumi.Input[str]:
        """
        The layout type of the group. Valid values are `ordered`.
        """
        return pulumi.get(self, "layout_type")

    @layout_type.setter
    def layout_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "layout_type", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="bannerImg")
    def banner_img(self) -> Optional[pulumi.Input[str]]:
        """
        The image URL to display as a banner for the group.
        """
        return pulumi.get(self, "banner_img")

    @banner_img.setter
    def banner_img(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "banner_img", value)

    @property
    @pulumi.getter(name="showTitle")
    def show_title(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the title or not. Defaults to `true`.
        """
        return pulumi.get(self, "show_title")

    @show_title.setter
    def show_title(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_title", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the group.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def widgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]]]:
        """
        The list of widgets in this group.
        """
        return pulumi.get(self, "widgets")

    @widgets.setter
    def widgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetGroupDefinitionWidgetArgs']]]]):
        pulumi.set(self, "widgets", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetArgs:
    def __init__(__self__, *,
                 alert_graph_definition: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']] = None,
                 alert_value_definition: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']] = None,
                 change_definition: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']] = None,
                 check_status_definition: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']] = None,
                 distribution_definition: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']] = None,
                 event_stream_definition: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']] = None,
                 event_timeline_definition: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']] = None,
                 free_text_definition: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']] = None,
                 geomap_definition: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']] = None,
                 heatmap_definition: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']] = None,
                 hostmap_definition: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 iframe_definition: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']] = None,
                 image_definition: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']] = None,
                 list_stream_definition: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']] = None,
                 log_stream_definition: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']] = None,
                 manage_status_definition: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']] = None,
                 note_definition: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']] = None,
                 powerpack_definition: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']] = None,
                 run_workflow_definition: Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']] = None,
                 service_level_objective_definition: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']] = None,
                 servicemap_definition: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']] = None,
                 slo_list_definition: Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']] = None,
                 split_graph_definition: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']] = None,
                 sunburst_definition: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']] = None,
                 topology_map_definition: Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']] = None,
                 trace_service_definition: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']] = None,
                 treemap_definition: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']] = None,
                 widget_layout: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs'] alert_graph_definition: The definition for a Alert Graph widget.
        :param pulumi.Input['DashboardWidgetAlertValueDefinitionArgs'] alert_value_definition: The definition for a Alert Value widget.
        :param pulumi.Input['DashboardWidgetChangeDefinitionArgs'] change_definition: The definition for a Change widget.
        :param pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs'] check_status_definition: The definition for a Check Status widget.
        :param pulumi.Input['DashboardWidgetDistributionDefinitionArgs'] distribution_definition: The definition for a Distribution widget.
        :param pulumi.Input['DashboardWidgetEventStreamDefinitionArgs'] event_stream_definition: The definition for a Event Stream widget.
        :param pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs'] event_timeline_definition: The definition for a Event Timeline widget.
        :param pulumi.Input['DashboardWidgetFreeTextDefinitionArgs'] free_text_definition: The definition for a Free Text widget.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionArgs'] geomap_definition: The definition for a Geomap widget.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionArgs'] heatmap_definition: The definition for a Heatmap widget.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionArgs'] hostmap_definition: The definition for a Hostmap widget.
        :param pulumi.Input[int] id: The ID of the widget.
        :param pulumi.Input['DashboardWidgetIframeDefinitionArgs'] iframe_definition: The definition for an Iframe widget.
        :param pulumi.Input['DashboardWidgetImageDefinitionArgs'] image_definition: The definition for an Image widget
        :param pulumi.Input['DashboardWidgetListStreamDefinitionArgs'] list_stream_definition: The definition for a List Stream widget.
        :param pulumi.Input['DashboardWidgetLogStreamDefinitionArgs'] log_stream_definition: The definition for an Log Stream widget.
        :param pulumi.Input['DashboardWidgetManageStatusDefinitionArgs'] manage_status_definition: The definition for an Manage Status widget.
        :param pulumi.Input['DashboardWidgetNoteDefinitionArgs'] note_definition: The definition for a Note widget.
        :param pulumi.Input['DashboardWidgetPowerpackDefinitionArgs'] powerpack_definition: The definition for a Powerpack widget.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionArgs'] query_table_definition: The definition for a Query Table widget.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionArgs'] query_value_definition: The definition for a Query Value widget.
        :param pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs'] run_workflow_definition: The definition for a Run Workflow widget.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionArgs'] scatterplot_definition: The definition for a Scatterplot widget.
        :param pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs'] service_level_objective_definition: The definition for a Service Level Objective widget.
        :param pulumi.Input['DashboardWidgetServicemapDefinitionArgs'] servicemap_definition: The definition for a Service Map widget.
        :param pulumi.Input['DashboardWidgetSloListDefinitionArgs'] slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs'] split_graph_definition: The definition for a Split Graph widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionArgs'] sunburst_definition: The definition for a Sunburst widget.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs'] timeseries_definition: The definition for a Timeseries widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionArgs'] toplist_definition: The definition for a Toplist widget.
        :param pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs'] topology_map_definition: The definition for a Topology Map widget.
        :param pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs'] trace_service_definition: The definition for a Trace Service widget.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionArgs'] treemap_definition: The definition for a Treemap widget.
        :param pulumi.Input['DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs'] widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if powerpack_definition is not None:
            pulumi.set(__self__, "powerpack_definition", powerpack_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if split_graph_definition is not None:
            pulumi.set(__self__, "split_graph_definition", split_graph_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @alert_graph_definition.setter
    def alert_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertGraphDefinitionArgs']]):
        pulumi.set(self, "alert_graph_definition", value)

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @alert_value_definition.setter
    def alert_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetAlertValueDefinitionArgs']]):
        pulumi.set(self, "alert_value_definition", value)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @check_status_definition.setter
    def check_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetCheckStatusDefinitionArgs']]):
        pulumi.set(self, "check_status_definition", value)

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @distribution_definition.setter
    def distribution_definition(self, value: Optional[pulumi.Input['DashboardWidgetDistributionDefinitionArgs']]):
        pulumi.set(self, "distribution_definition", value)

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @event_stream_definition.setter
    def event_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventStreamDefinitionArgs']]):
        pulumi.set(self, "event_stream_definition", value)

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @event_timeline_definition.setter
    def event_timeline_definition(self, value: Optional[pulumi.Input['DashboardWidgetEventTimelineDefinitionArgs']]):
        pulumi.set(self, "event_timeline_definition", value)

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @free_text_definition.setter
    def free_text_definition(self, value: Optional[pulumi.Input['DashboardWidgetFreeTextDefinitionArgs']]):
        pulumi.set(self, "free_text_definition", value)

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @geomap_definition.setter
    def geomap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]):
        pulumi.set(self, "geomap_definition", value)

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @heatmap_definition.setter
    def heatmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionArgs']]):
        pulumi.set(self, "heatmap_definition", value)

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @hostmap_definition.setter
    def hostmap_definition(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionArgs']]):
        pulumi.set(self, "hostmap_definition", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @iframe_definition.setter
    def iframe_definition(self, value: Optional[pulumi.Input['DashboardWidgetIframeDefinitionArgs']]):
        pulumi.set(self, "iframe_definition", value)

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @image_definition.setter
    def image_definition(self, value: Optional[pulumi.Input['DashboardWidgetImageDefinitionArgs']]):
        pulumi.set(self, "image_definition", value)

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']]:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @list_stream_definition.setter
    def list_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionArgs']]):
        pulumi.set(self, "list_stream_definition", value)

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @log_stream_definition.setter
    def log_stream_definition(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionArgs']]):
        pulumi.set(self, "log_stream_definition", value)

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @manage_status_definition.setter
    def manage_status_definition(self, value: Optional[pulumi.Input['DashboardWidgetManageStatusDefinitionArgs']]):
        pulumi.set(self, "manage_status_definition", value)

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @note_definition.setter
    def note_definition(self, value: Optional[pulumi.Input['DashboardWidgetNoteDefinitionArgs']]):
        pulumi.set(self, "note_definition", value)

    @property
    @pulumi.getter(name="powerpackDefinition")
    def powerpack_definition(self) -> Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']]:
        """
        The definition for a Powerpack widget.
        """
        return pulumi.get(self, "powerpack_definition")

    @powerpack_definition.setter
    def powerpack_definition(self, value: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionArgs']]):
        pulumi.set(self, "powerpack_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']]:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @run_workflow_definition.setter
    def run_workflow_definition(self, value: Optional[pulumi.Input['DashboardWidgetRunWorkflowDefinitionArgs']]):
        pulumi.set(self, "run_workflow_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @service_level_objective_definition.setter
    def service_level_objective_definition(self, value: Optional[pulumi.Input['DashboardWidgetServiceLevelObjectiveDefinitionArgs']]):
        pulumi.set(self, "service_level_objective_definition", value)

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @servicemap_definition.setter
    def servicemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetServicemapDefinitionArgs']]):
        pulumi.set(self, "servicemap_definition", value)

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']]:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @slo_list_definition.setter
    def slo_list_definition(self, value: Optional[pulumi.Input['DashboardWidgetSloListDefinitionArgs']]):
        pulumi.set(self, "slo_list_definition", value)

    @property
    @pulumi.getter(name="splitGraphDefinition")
    def split_graph_definition(self) -> Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']]:
        """
        The definition for a Split Graph widget.
        """
        return pulumi.get(self, "split_graph_definition")

    @split_graph_definition.setter
    def split_graph_definition(self, value: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionArgs']]):
        pulumi.set(self, "split_graph_definition", value)

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @sunburst_definition.setter
    def sunburst_definition(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]):
        pulumi.set(self, "sunburst_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']]:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @topology_map_definition.setter
    def topology_map_definition(self, value: Optional[pulumi.Input['DashboardWidgetTopologyMapDefinitionArgs']]):
        pulumi.set(self, "topology_map_definition", value)

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @trace_service_definition.setter
    def trace_service_definition(self, value: Optional[pulumi.Input['DashboardWidgetTraceServiceDefinitionArgs']]):
        pulumi.set(self, "trace_service_definition", value)

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @treemap_definition.setter
    def treemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]):
        pulumi.set(self, "treemap_definition", value)

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs']]:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")

    @widget_layout.setter
    def widget_layout(self, value: Optional[pulumi.Input['DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs']]):
        pulumi.set(self, "widget_layout", value)


@pulumi.input_type
class DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[int],
                 width: pulumi.Input[int],
                 x: pulumi.Input[int],
                 y: pulumi.Input[int],
                 is_column_break: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] height: The height of the widget.
        :param pulumi.Input[int] width: The width of the widget.
        :param pulumi.Input[int] x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param pulumi.Input[int] y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param pulumi.Input[bool] is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[int]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[int]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[int]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[int]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[int]:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[int]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[int]:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[int]):
        pulumi.set(self, "y", value)

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")

    @is_column_break.setter
    def is_column_break(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_column_break", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionCustomLinkArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] q: The event query to use in the widget.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetHeatmapDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionCustomLinkArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_group_hosts: Optional[pulumi.Input[bool]] = None,
                 no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The list of tags to group nodes by.
        :param pulumi.Input[bool] no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param pulumi.Input[bool] no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param pulumi.Input[str] node_type: The type of node used. Valid values are `host`, `container`.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of tags to filter nodes by.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @no_group_hosts.setter
    def no_group_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_group_hosts", value)

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @no_metric_hosts.setter
    def no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_metric_hosts", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 fills: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]] = None,
                 sizes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @fills.setter
    def fills(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillArgs']]]]):
        pulumi.set(self, "fills", value)

    @property
    @pulumi.getter
    def sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")

    @sizes.setter
    def sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeArgs']]]]):
        pulumi.set(self, "sizes", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetHostmapDefinitionStyleArgs:
    def __init__(__self__, *,
                 fill_max: Optional[pulumi.Input[str]] = None,
                 fill_min: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_flip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] fill_max: The max value to use to color the map.
        :param pulumi.Input[str] fill_min: The min value to use to color the map.
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        :param pulumi.Input[bool] palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[pulumi.Input[str]]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @fill_max.setter
    def fill_max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_max", value)

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[pulumi.Input[str]]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @fill_min.setter
    def fill_min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_min", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class DashboardWidgetIframeDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The URL to use as a data source for the widget.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class DashboardWidgetImageDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 has_background: Optional[pulumi.Input[bool]] = None,
                 has_border: Optional[pulumi.Input[bool]] = None,
                 horizontal_align: Optional[pulumi.Input[str]] = None,
                 margin: Optional[pulumi.Input[str]] = None,
                 sizing: Optional[pulumi.Input[str]] = None,
                 url_dark_theme: Optional[pulumi.Input[str]] = None,
                 vertical_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to use as a data source for the widget.
        :param pulumi.Input[bool] has_background: Whether to display a background or not. Defaults to `true`.
        :param pulumi.Input[bool] has_border: Whether to display a border or not. Defaults to `true`.
        :param pulumi.Input[str] horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param pulumi.Input[str] sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param pulumi.Input[str] url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param pulumi.Input[str] vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "url", url)
        if has_background is not None:
            pulumi.set(__self__, "has_background", has_background)
        if has_border is not None:
            pulumi.set(__self__, "has_border", has_border)
        if horizontal_align is not None:
            pulumi.set(__self__, "horizontal_align", horizontal_align)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if url_dark_theme is not None:
            pulumi.set(__self__, "url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to display a background or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_background")

    @has_background.setter
    def has_background(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_background", value)

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to display a border or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_border")

    @has_border.setter
    def has_border(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_border", value)

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @horizontal_align.setter
    def horizontal_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "horizontal_align", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def sizing(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @sizing.setter
    def sizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing", value)

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[pulumi.Input[str]]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @url_dark_theme.setter
    def url_dark_theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_dark_theme", value)

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")

    @vertical_align.setter
    def vertical_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_align", value)


@pulumi.input_type
class DashboardWidgetListStreamDefinitionArgs:
    def __init__(__self__, *,
                 requests: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestArgs']]],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestArgs']]] requests: Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title. Default is 16.
        """
        pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestArgs']]]:
        """
        Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestArgs']]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetListStreamDefinitionRequestArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestColumnArgs']]],
                 query: pulumi.Input['DashboardWidgetListStreamDefinitionRequestQueryArgs'],
                 response_format: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestColumnArgs']]] columns: Widget columns.
        :param pulumi.Input['DashboardWidgetListStreamDefinitionRequestQueryArgs'] query: Updated list stream widget.
        :param pulumi.Input[str] response_format: Widget response format. Valid values are `event_list`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestColumnArgs']]]:
        """
        Widget columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetListStreamDefinitionRequestColumnArgs']]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input['DashboardWidgetListStreamDefinitionRequestQueryArgs']:
        """
        Updated list stream widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input['DashboardWidgetListStreamDefinitionRequestQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> pulumi.Input[str]:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")

    @response_format.setter
    def response_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "response_format", value)


@pulumi.input_type
class DashboardWidgetListStreamDefinitionRequestColumnArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 width: pulumi.Input[str]):
        """
        :param pulumi.Input[str] field: Widget column field.
        :param pulumi.Input[str] width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[str]:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[str]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class DashboardWidgetListStreamDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionRequestQuerySortArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`.
        :param pulumi.Input[str] event_size: Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: List of indexes.
        :param pulumi.Input[str] query_string: Widget query.
        :param pulumi.Input['DashboardWidgetListStreamDefinitionRequestQuerySortArgs'] sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "data_source", data_source)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of indexes.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetListStreamDefinitionRequestQuerySortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetListStreamDefinitionRequestQuerySortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetListStreamDefinitionRequestQuerySortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetLogStreamDefinitionArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 message_display: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 show_date_column: Optional[pulumi.Input[bool]] = None,
                 show_message_column: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[bool] show_date_column: If the date column should be displayed.
        :param pulumi.Input[bool] show_message_column: If the message column should be displayed.
        :param pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs'] sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[pulumi.Input[str]]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @message_display.setter
    def message_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_display", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @show_date_column.setter
    def show_date_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_date_column", value)

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @show_message_column.setter
    def show_message_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_message_column", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetLogStreamDefinitionSortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetLogStreamDefinitionSortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetManageStatusDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 color_preference: Optional[pulumi.Input[str]] = None,
                 display_format: Optional[pulumi.Input[str]] = None,
                 hide_zero_counts: Optional[pulumi.Input[bool]] = None,
                 show_last_triggered: Optional[pulumi.Input[bool]] = None,
                 show_priority: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 summary_type: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param pulumi.Input[str] display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param pulumi.Input[bool] hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param pulumi.Input[bool] show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param pulumi.Input[bool] show_priority: Whether to show the priorities column.
        :param pulumi.Input[str] sort: The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        :param pulumi.Input[str] summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if show_priority is not None:
            pulumi.set(__self__, "show_priority", show_priority)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @color_preference.setter
    def color_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_preference", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @hide_zero_counts.setter
    def hide_zero_counts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_zero_counts", value)

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @show_last_triggered.setter
    def show_last_triggered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_last_triggered", value)

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @show_priority.setter
    def show_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_priority", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[pulumi.Input[str]]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @summary_type.setter
    def summary_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetNoteDefinitionArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 has_padding: Optional[pulumi.Input[bool]] = None,
                 show_tick: Optional[pulumi.Input[bool]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 tick_edge: Optional[pulumi.Input[str]] = None,
                 tick_pos: Optional[pulumi.Input[str]] = None,
                 vertical_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The content of the note.
        :param pulumi.Input[str] background_color: The background color of the note.
        :param pulumi.Input[str] font_size: The size of the text.
        :param pulumi.Input[bool] has_padding: Whether to add padding or not. Defaults to `true`.
        :param pulumi.Input[bool] show_tick: Whether to show a tick or not.
        :param pulumi.Input[str] text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param pulumi.Input[str] tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param pulumi.Input[str] vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if has_padding is not None:
            pulumi.set(__self__, "has_padding", has_padding)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color of the note.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to add padding or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_padding")

    @has_padding.setter
    def has_padding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_padding", value)

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @show_tick.setter
    def show_tick(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_tick", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[pulumi.Input[str]]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @tick_edge.setter
    def tick_edge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_edge", value)

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[pulumi.Input[str]]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @tick_pos.setter
    def tick_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_pos", value)

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")

    @vertical_align.setter
    def vertical_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_align", value)


@pulumi.input_type
class DashboardWidgetPowerpackDefinitionArgs:
    def __init__(__self__, *,
                 powerpack_id: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 banner_img: Optional[pulumi.Input[str]] = None,
                 show_title: Optional[pulumi.Input[bool]] = None,
                 template_variables: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] powerpack_id: UUID of the associated powerpack.
        :param pulumi.Input[str] background_color: The background color of the powerpack title.
        :param pulumi.Input[str] banner_img: URL of image to display as a banner for the powerpack.
        :param pulumi.Input[bool] show_title: Whether to show the title of the powerpack.
        :param pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesArgs'] template_variables: The list of template variables for this powerpack.
        :param pulumi.Input[str] title: Title of the powerpack.
        """
        pulumi.set(__self__, "powerpack_id", powerpack_id)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if banner_img is not None:
            pulumi.set(__self__, "banner_img", banner_img)
        if show_title is not None:
            pulumi.set(__self__, "show_title", show_title)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="powerpackId")
    def powerpack_id(self) -> pulumi.Input[str]:
        """
        UUID of the associated powerpack.
        """
        return pulumi.get(self, "powerpack_id")

    @powerpack_id.setter
    def powerpack_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "powerpack_id", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color of the powerpack title.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="bannerImg")
    def banner_img(self) -> Optional[pulumi.Input[str]]:
        """
        URL of image to display as a banner for the powerpack.
        """
        return pulumi.get(self, "banner_img")

    @banner_img.setter
    def banner_img(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "banner_img", value)

    @property
    @pulumi.getter(name="showTitle")
    def show_title(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the title of the powerpack.
        """
        return pulumi.get(self, "show_title")

    @show_title.setter
    def show_title(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_title", value)

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesArgs']]:
        """
        The list of template variables for this powerpack.
        """
        return pulumi.get(self, "template_variables")

    @template_variables.setter
    def template_variables(self, value: Optional[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesArgs']]):
        pulumi.set(self, "template_variables", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the powerpack.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class DashboardWidgetPowerpackDefinitionTemplateVariablesArgs:
    def __init__(__self__, *,
                 controlled_by_powerpacks: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs']]]] = None,
                 controlled_externallies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs']]] controlled_by_powerpacks: Template variables controlled at the powerpack level.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs']]] controlled_externallies: Template variables controlled by the external resource, such as the dashboard this powerpack is on.
        """
        if controlled_by_powerpacks is not None:
            pulumi.set(__self__, "controlled_by_powerpacks", controlled_by_powerpacks)
        if controlled_externallies is not None:
            pulumi.set(__self__, "controlled_externallies", controlled_externallies)

    @property
    @pulumi.getter(name="controlledByPowerpacks")
    def controlled_by_powerpacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs']]]]:
        """
        Template variables controlled at the powerpack level.
        """
        return pulumi.get(self, "controlled_by_powerpacks")

    @controlled_by_powerpacks.setter
    def controlled_by_powerpacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs']]]]):
        pulumi.set(self, "controlled_by_powerpacks", value)

    @property
    @pulumi.getter(name="controlledExternallies")
    def controlled_externallies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs']]]]:
        """
        Template variables controlled by the external resource, such as the dashboard this powerpack is on.
        """
        return pulumi.get(self, "controlled_externallies")

    @controlled_externallies.setter
    def controlled_externallies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs']]]]):
        pulumi.set(self, "controlled_externallies", value)


@pulumi.input_type
class DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        :param pulumi.Input[str] prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        :param pulumi.Input[str] prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionCustomLinkArgs']]]] = None,
                 has_search_bar: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @has_search_bar.setter
    def has_search_bar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "has_search_bar", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 apm_stats_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryArgs']] = None,
                 cell_display_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaArgs']]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input[str] alias: The alias for the column name (defaults to metric name).
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cell_display_modes: A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input[int] limit: The number of lines to show in the table.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] order: The sort order for the rows. Valid values are `asc`, `desc`.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias for the column name (defaults to metric name).
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryArgs']]:
        return pulumi.get(self, "apm_stats_query")

    @apm_stats_query.setter
    def apm_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryArgs']]):
        pulumi.set(self, "apm_stats_query", value)

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @cell_display_modes.setter
    def cell_display_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cell_display_modes", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The sort order for the rows. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 primary_tag: pulumi.Input[str],
                 row_type: pulumi.Input[str],
                 service: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: The environment name.
        :param pulumi.Input[str] name: The operation name associated with the service.
        :param pulumi.Input[str] primary_tag: The organization's host group name and value.
        :param pulumi.Input[str] row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param pulumi.Input[str] service: The service name.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]] columns: Column properties used by the front end for display.
        :param pulumi.Input[str] resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> pulumi.Input[str]:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @primary_tag.setter
    def primary_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_tag", value)

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> pulumi.Input[str]:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @row_type.setter
    def row_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_type", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The column name.
        :param pulumi.Input[str] alias: A user-assigned alias for the column.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionArgs:
    def __init__(__self__, *,
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionCustomLinkArgs']]]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 timeseries_background: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] autoscale: A Boolean indicating whether to automatically scale the tile.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] custom_unit: The unit for the value displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[int] precision: The precision to use when displaying the tile.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs'] timeseries_background: Set a timeseries on the widget background.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if timeseries_background is not None:
            pulumi.set(__self__, "timeseries_background", timeseries_background)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs']]:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @timeseries_background.setter
    def timeseries_background(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs']]):
        pulumi.set(self, "timeseries_background", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 yaxis: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']] = None):
        """
        :param pulumi.Input[str] type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        pulumi.set(__self__, "type", type)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetRunWorkflowDefinitionArgs:
    def __init__(__self__, *,
                 workflow_id: pulumi.Input[str],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs']]]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionInputArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] workflow_id: Workflow ID
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionInputArgs']]] inputs: Array of workflow inputs to map to dashboard template variables.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "workflow_id", workflow_id)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> pulumi.Input[str]:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workflow_id", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionInputArgs']]]]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetRunWorkflowDefinitionInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetRunWorkflowDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetRunWorkflowDefinitionInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the workflow input.
        :param pulumi.Input[str] value: Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the workflow input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionArgs:
    def __init__(__self__, *,
                 color_by_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 xaxis: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] color_by_groups: List of groups used for colors.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs'] xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @color_by_groups.setter
    def color_by_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "color_by_groups", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']]:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def xaxis(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']]:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @xaxis.setter
    def xaxis(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionXaxisArgs']]):
        pulumi.set(self, "xaxis", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestArgs:
    def __init__(__self__, *,
                 scatterplot_tables: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]] = None,
                 xes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]] = None,
                 ys: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs']]] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        if scatterplot_tables is not None:
            pulumi.set(__self__, "scatterplot_tables", scatterplot_tables)
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @scatterplot_tables.setter
    def scatterplot_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]]):
        pulumi.set(self, "scatterplot_tables", value)

    @property
    @pulumi.getter
    def xes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @xes.setter
    def xes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXArgs']]]]):
        pulumi.set(self, "xes", value)

    @property
    @pulumi.getter
    def ys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")

    @ys.setter
    def ys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYArgs']]]]):
        pulumi.set(self, "ys", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]]):
        pulumi.set(self, "queries", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs:
    def __init__(__self__, *,
                 dimension: pulumi.Input[str],
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> pulumi.Input[str]:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionXaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetScatterplotDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetServiceLevelObjectiveDefinitionArgs:
    def __init__(__self__, *,
                 slo_id: pulumi.Input[str],
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 view_mode: pulumi.Input[str],
                 view_type: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 global_time_target: Optional[pulumi.Input[str]] = None,
                 show_error_budget: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] slo_id: The ID of the service level objective used by the widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param pulumi.Input[str] view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param pulumi.Input[str] view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] global_time_target: The global time target of the widget.
        :param pulumi.Input[bool] show_error_budget: Whether to show the error budget or not.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        The ID of the service level objective used by the widget.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> pulumi.Input[str]:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @view_mode.setter
    def view_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_mode", value)

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> pulumi.Input[str]:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @view_type.setter
    def view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_type", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[pulumi.Input[str]]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @global_time_target.setter
    def global_time_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "global_time_target", value)

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @show_error_budget.setter
    def show_error_budget(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_error_budget", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetServicemapDefinitionArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service: pulumi.Input[str],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetServicemapDefinitionCustomLinkArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param pulumi.Input[str] service: The ID of the service to map.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetServicemapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetServicemapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetServicemapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetServicemapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetSloListDefinitionArgs:
    def __init__(__self__, *,
                 request: pulumi.Input['DashboardWidgetSloListDefinitionRequestArgs'],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DashboardWidgetSloListDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> pulumi.Input['DashboardWidgetSloListDefinitionRequestArgs']:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: pulumi.Input['DashboardWidgetSloListDefinitionRequestArgs']):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetSloListDefinitionRequestArgs:
    def __init__(__self__, *,
                 query: pulumi.Input['DashboardWidgetSloListDefinitionRequestQueryArgs'],
                 request_type: pulumi.Input[str]):
        """
        :param pulumi.Input['DashboardWidgetSloListDefinitionRequestQueryArgs'] query: Updated SLO List widget.
        :param pulumi.Input[str] request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input['DashboardWidgetSloListDefinitionRequestQueryArgs']:
        """
        Updated SLO List widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input['DashboardWidgetSloListDefinitionRequestQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> pulumi.Input[str]:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "request_type", value)


@pulumi.input_type
class DashboardWidgetSloListDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 query_string: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetSloListDefinitionRequestQuerySortArgs']] = None):
        """
        :param pulumi.Input[str] query_string: Widget query.
        :param pulumi.Input[int] limit: Maximum number of results to display in the table. Defaults to `100`.
        :param pulumi.Input['DashboardWidgetSloListDefinitionRequestQuerySortArgs'] sort: The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        pulumi.set(__self__, "query_string", query_string)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of results to display in the table. Defaults to `100`.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetSloListDefinitionRequestQuerySortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetSloListDefinitionRequestQuerySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetSloListDefinitionRequestQuerySortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[str],
                 source_widget_definition: pulumi.Input['DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs'],
                 split_config: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigArgs'],
                 has_uniform_y_axes: Optional[pulumi.Input[bool]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] size: Size of the individual graphs in the split.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs'] source_widget_definition: The original widget we are splitting on.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigArgs'] split_config: Encapsulates all user choices about how to split a graph.
        :param pulumi.Input[bool] has_uniform_y_axes: Normalize y axes across graphs.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] title: The title of the widget.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "source_widget_definition", source_widget_definition)
        pulumi.set(__self__, "split_config", split_config)
        if has_uniform_y_axes is not None:
            pulumi.set(__self__, "has_uniform_y_axes", has_uniform_y_axes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        Size of the individual graphs in the split.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sourceWidgetDefinition")
    def source_widget_definition(self) -> pulumi.Input['DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs']:
        """
        The original widget we are splitting on.
        """
        return pulumi.get(self, "source_widget_definition")

    @source_widget_definition.setter
    def source_widget_definition(self, value: pulumi.Input['DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs']):
        pulumi.set(self, "source_widget_definition", value)

    @property
    @pulumi.getter(name="splitConfig")
    def split_config(self) -> pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigArgs']:
        """
        Encapsulates all user choices about how to split a graph.
        """
        return pulumi.get(self, "split_config")

    @split_config.setter
    def split_config(self, value: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigArgs']):
        pulumi.set(self, "split_config", value)

    @property
    @pulumi.getter(name="hasUniformYAxes")
    def has_uniform_y_axes(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize y axes across graphs.
        """
        return pulumi.get(self, "has_uniform_y_axes")

    @has_uniform_y_axes.setter
    def has_uniform_y_axes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_uniform_y_axes", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs:
    def __init__(__self__, *,
                 change_definition: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']] = None,
                 geomap_definition: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']] = None,
                 sunburst_definition: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']] = None,
                 treemap_definition: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetChangeDefinitionArgs'] change_definition: The definition for a Change widget.
        :param pulumi.Input['DashboardWidgetGeomapDefinitionArgs'] geomap_definition: The definition for a Geomap widget.
        :param pulumi.Input['DashboardWidgetQueryTableDefinitionArgs'] query_table_definition: The definition for a Query Table widget.
        :param pulumi.Input['DashboardWidgetQueryValueDefinitionArgs'] query_value_definition: The definition for a Query Value widget.
        :param pulumi.Input['DashboardWidgetScatterplotDefinitionArgs'] scatterplot_definition: The definition for a Scatterplot widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionArgs'] sunburst_definition: The definition for a Sunburst widget.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs'] timeseries_definition: The definition for a Timeseries widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionArgs'] toplist_definition: The definition for a Toplist widget.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionArgs'] treemap_definition: The definition for a Treemap widget.
        """
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['DashboardWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @geomap_definition.setter
    def geomap_definition(self, value: Optional[pulumi.Input['DashboardWidgetGeomapDefinitionArgs']]):
        pulumi.set(self, "geomap_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['DashboardWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['DashboardWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @sunburst_definition.setter
    def sunburst_definition(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionArgs']]):
        pulumi.set(self, "sunburst_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @treemap_definition.setter
    def treemap_definition(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionArgs']]):
        pulumi.set(self, "treemap_definition", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigArgs:
    def __init__(__self__, *,
                 sort: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs'],
                 split_dimensions: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs'],
                 limit: Optional[pulumi.Input[int]] = None,
                 static_splits: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs']]]] = None):
        """
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs'] sort: Controls the order in which graphs appear in the split.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs'] split_dimensions: The property by which the graph splits
        :param pulumi.Input[int] limit: Maximum number of graphs to display in the widget.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs']]] static_splits: The property by which the graph splits
        """
        pulumi.set(__self__, "sort", sort)
        pulumi.set(__self__, "split_dimensions", split_dimensions)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if static_splits is not None:
            pulumi.set(__self__, "static_splits", static_splits)

    @property
    @pulumi.getter
    def sort(self) -> pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs']:
        """
        Controls the order in which graphs appear in the split.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs']):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="splitDimensions")
    def split_dimensions(self) -> pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs']:
        """
        The property by which the graph splits
        """
        return pulumi.get(self, "split_dimensions")

    @split_dimensions.setter
    def split_dimensions(self, value: pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs']):
        pulumi.set(self, "split_dimensions", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of graphs to display in the widget.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="staticSplits")
    def static_splits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs']]]]:
        """
        The property by which the graph splits
        """
        return pulumi.get(self, "static_splits")

    @static_splits.setter
    def static_splits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs']]]]):
        pulumi.set(self, "static_splits", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[str],
                 compute: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs']] = None):
        """
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs'] compute: Defines the metric and aggregation used as the sort value
        """
        pulumi.set(__self__, "order", order)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs']]:
        """
        Defines the metric and aggregation used as the sort value
        """
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs']]):
        pulumi.set(self, "compute", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 aggregation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: The metric to use for sorting graphs.
        :param pulumi.Input[str] aggregation: How to aggregate the sort metric for the purposes of ordering.
        """
        pulumi.set(__self__, "metric", metric)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The metric to use for sorting graphs.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        How to aggregate the sort metric for the purposes of ordering.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs:
    def __init__(__self__, *,
                 one_graph_per: pulumi.Input[str]):
        """
        :param pulumi.Input[str] one_graph_per: The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
        """
        pulumi.set(__self__, "one_graph_per", one_graph_per)

    @property
    @pulumi.getter(name="oneGraphPer")
    def one_graph_per(self) -> pulumi.Input[str]:
        """
        The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
        """
        return pulumi.get(self, "one_graph_per")

    @one_graph_per.setter
    def one_graph_per(self, value: pulumi.Input[str]):
        pulumi.set(self, "one_graph_per", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs:
    def __init__(__self__, *,
                 split_vectors: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs']]] split_vectors: The split graph list contains a graph for each value of the split dimension.
        """
        pulumi.set(__self__, "split_vectors", split_vectors)

    @property
    @pulumi.getter(name="splitVectors")
    def split_vectors(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs']]]:
        """
        The split graph list contains a graph for each value of the split dimension.
        """
        return pulumi.get(self, "split_vectors")

    @split_vectors.setter
    def split_vectors(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs']]]):
        pulumi.set(self, "split_vectors", value)


@pulumi.input_type
class DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[str],
                 tag_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_values", tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "tag_values")

    @tag_values.setter
    def tag_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tag_values", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionCustomLinkArgs']]]] = None,
                 hide_total: Optional[pulumi.Input[bool]] = None,
                 legend_inline: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendInlineArgs']] = None,
                 legend_table: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendTableArgs']] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionCustomLinkArgs']]] custom_links: Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        :param pulumi.Input[bool] hide_total: Whether or not to show the total value in the widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionLegendInlineArgs'] legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionLegendTableArgs'] legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestArgs']]] requests: Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title. Default is 16.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if hide_total is not None:
            pulumi.set(__self__, "hide_total", hide_total)
        if legend_inline is not None:
            pulumi.set(__self__, "legend_inline", legend_inline)
        if legend_table is not None:
            pulumi.set(__self__, "legend_table", legend_table)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionCustomLinkArgs']]]]:
        """
        Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @hide_total.setter
    def hide_total(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_total", value)

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendInlineArgs']]:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @legend_inline.setter
    def legend_inline(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendInlineArgs']]):
        pulumi.set(self, "legend_inline", value)

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendTableArgs']]:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @legend_table.setter
    def legend_table(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionLegendTableArgs']]):
        pulumi.set(self, "legend_table", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestArgs']]]]:
        """
        Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionLegendInlineArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 hide_percent: Optional[pulumi.Input[bool]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        :param pulumi.Input[bool] hide_percent: Whether to hide the percentages of the groups.
        :param pulumi.Input[bool] hide_value: Whether to hide the values of the groups.
        """
        pulumi.set(__self__, "type", type)
        if hide_percent is not None:
            pulumi.set(__self__, "hide_percent", hide_percent)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @hide_percent.setter
    def hide_percent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_percent", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to hide the values of the groups.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionLegendTableArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of legend (table or none). Valid values are `table`, `none`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of legend (table or none). Valid values are `table`, `none`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryArgs']] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 network_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs'] network_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestStyleArgs'] style: Define style for the widget's request.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestStyleArgs']]:
        """
        Define style for the widget's request.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetSunburstDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionCustomLinkArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]] = None,
                 legend_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 legend_layout: Optional[pulumi.Input[str]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 markers: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]] = None,
                 right_yaxis: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRightYaxisArgs']] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param pulumi.Input[str] legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRightYaxisArgs'] right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @legend_columns.setter
    def legend_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "legend_columns", value)

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[pulumi.Input[str]]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @legend_layout.setter
    def legend_layout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_layout", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRightYaxisArgs']]:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @right_yaxis.setter
    def right_yaxis(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRightYaxisArgs']]):
        pulumi.set(self, "right_yaxis", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] q: The event query to use in the widget.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionMarkerArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 display_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        :param pulumi.Input[str] display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param pulumi.Input[str] label: A label for the line or range.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs']] = None,
                 display_type: Optional[pulumi.Input[str]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]] = None,
                 network_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']] = None,
                 on_right_yaxis: Optional[pulumi.Input[bool]] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[str] display_type: How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs'] network_query: The query to use for this widget.
        :param pulumi.Input[bool] on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs'] style: The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @on_right_yaxis.setter
    def on_right_yaxis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_right_yaxis", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestMetadataArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 alias_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: The expression name.
        :param pulumi.Input[str] alias_name: The expression alias.
        """
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[pulumi.Input[str]]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")

    @alias_name.setter
    def alias_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias_name", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 line_type: Optional[pulumi.Input[str]] = None,
                 line_width: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param pulumi.Input[str] line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @line_type.setter
    def line_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_type", value)

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @line_width.setter
    def line_width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_width", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionRightYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetTimeseriesDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['DashboardWidgetRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs'] style: Define request for the widget's style.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['DashboardWidgetApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['DashboardWidgetLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['DashboardWidgetRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['DashboardWidgetSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']]:
        """
        Define request for the widget's style.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetToplistDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class DashboardWidgetTopologyMapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionCustomLinkArgs']]]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetTopologyMapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class DashboardWidgetTopologyMapDefinitionRequestArgs:
    def __init__(__self__, *,
                 queries: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestQueryArgs']]],
                 request_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestQueryArgs']]] queries: The query for a Topology request.
        :param pulumi.Input[str] request_type: The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestQueryArgs']]]:
        """
        The query for a Topology request.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTopologyMapDefinitionRequestQueryArgs']]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> pulumi.Input[str]:
        """
        The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "request_type", value)


@pulumi.input_type
class DashboardWidgetTopologyMapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 filters: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[str] data_source: The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param pulumi.Input[str] service: The ID of the service to map.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class DashboardWidgetTraceServiceDefinitionArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 service: pulumi.Input[str],
                 span_name: pulumi.Input[str],
                 display_format: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 show_breakdown: Optional[pulumi.Input[bool]] = None,
                 show_distribution: Optional[pulumi.Input[bool]] = None,
                 show_errors: Optional[pulumi.Input[bool]] = None,
                 show_hits: Optional[pulumi.Input[bool]] = None,
                 show_latency: Optional[pulumi.Input[bool]] = None,
                 show_resource_list: Optional[pulumi.Input[bool]] = None,
                 size_format: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] span_name: APM span name
        :param pulumi.Input[str] display_format: The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[bool] show_breakdown: Whether to show the latency breakdown or not.
        :param pulumi.Input[bool] show_distribution: Whether to show the latency distribution or not.
        :param pulumi.Input[bool] show_errors: Whether to show the error metrics or not.
        :param pulumi.Input[bool] show_hits: Whether to show the hits metrics or not
        :param pulumi.Input[bool] show_latency: Whether to show the latency metrics or not.
        :param pulumi.Input[bool] show_resource_list: Whether to show the resource list or not.
        :param pulumi.Input[str] size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> pulumi.Input[str]:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @span_name.setter
    def span_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "span_name", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @show_breakdown.setter
    def show_breakdown(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_breakdown", value)

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @show_distribution.setter
    def show_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_distribution", value)

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @show_errors.setter
    def show_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_errors", value)

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @show_hits.setter
    def show_hits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_hits", value)

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @show_latency.setter
    def show_latency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_latency", value)

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @show_resource_list.setter
    def show_resource_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_resource_list", value)

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @size_format.setter
    def size_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_format", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestArgs']]] requests: Nested block describing the request to use when displaying the widget.
        :param pulumi.Input[str] title: The title of the widget.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestArgs']]]]:
        """
        Nested block describing the request to use when displaying the widget.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaArgs']]]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryArgs']]]] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class DashboardWidgetWidgetLayoutArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[int],
                 width: pulumi.Input[int],
                 x: pulumi.Input[int],
                 y: pulumi.Input[int],
                 is_column_break: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] height: The height of the widget.
        :param pulumi.Input[int] width: The width of the widget.
        :param pulumi.Input[int] x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param pulumi.Input[int] y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param pulumi.Input[bool] is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[int]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[int]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[int]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[int]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[int]:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[int]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[int]:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[int]):
        pulumi.set(self, "y", value)

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")

    @is_column_break.setter
    def is_column_break(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_column_break", value)


@pulumi.input_type
class DowntimeRecurrenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 period: Optional[pulumi.Input[int]] = None,
                 rrule: Optional[pulumi.Input[str]] = None,
                 until_date: Optional[pulumi.Input[int]] = None,
                 until_occurrences: Optional[pulumi.Input[int]] = None,
                 week_days: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: One of `days`, `weeks`, `months`, `years`, or `rrule`.
        :param pulumi.Input[int] period: How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        :param pulumi.Input[str] rrule: The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        :param pulumi.Input[int] until_date: The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        :param pulumi.Input[int] until_occurrences: How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] week_days: A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        pulumi.set(__self__, "type", type)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if rrule is not None:
            pulumi.set(__self__, "rrule", rrule)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)
        if until_occurrences is not None:
            pulumi.set(__self__, "until_occurrences", until_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        One of `days`, `weeks`, `months`, `years`, or `rrule`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def rrule(self) -> Optional[pulumi.Input[str]]:
        """
        The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        """
        return pulumi.get(self, "rrule")

    @rrule.setter
    def rrule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rrule", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[int]]:
        """
        The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "until_date", value)

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[pulumi.Input[int]]:
        """
        How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @until_occurrences.setter
    def until_occurrences(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "until_occurrences", value)

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")

    @week_days.setter
    def week_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "week_days", value)


@pulumi.input_type
class DowntimeScheduleMonitorIdentifierArgs:
    def __init__(__self__, *,
                 monitor_id: Optional[pulumi.Input[int]] = None,
                 monitor_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] monitor_id: ID of the monitor to prevent notifications.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] monitor_tags: A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        if monitor_id is not None:
            pulumi.set(__self__, "monitor_id", monitor_id)
        if monitor_tags is not None:
            pulumi.set(__self__, "monitor_tags", monitor_tags)

    @property
    @pulumi.getter(name="monitorId")
    def monitor_id(self) -> Optional[pulumi.Input[int]]:
        """
        ID of the monitor to prevent notifications.
        """
        return pulumi.get(self, "monitor_id")

    @monitor_id.setter
    def monitor_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_id", value)

    @property
    @pulumi.getter(name="monitorTags")
    def monitor_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        return pulumi.get(self, "monitor_tags")

    @monitor_tags.setter
    def monitor_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "monitor_tags", value)


@pulumi.input_type
class DowntimeScheduleOneTimeScheduleArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end: ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        :param pulumi.Input[str] start: ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class DowntimeScheduleRecurringScheduleArgs:
    def __init__(__self__, *,
                 recurrences: Optional[pulumi.Input[Sequence[pulumi.Input['DowntimeScheduleRecurringScheduleRecurrenceArgs']]]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] timezone: The timezone in which to schedule the downtime.
        """
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DowntimeScheduleRecurringScheduleRecurrenceArgs']]]]:
        return pulumi.get(self, "recurrences")

    @recurrences.setter
    def recurrences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DowntimeScheduleRecurringScheduleRecurrenceArgs']]]]):
        pulumi.set(self, "recurrences", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The timezone in which to schedule the downtime.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


@pulumi.input_type
class DowntimeScheduleRecurringScheduleRecurrenceArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 rrule: pulumi.Input[str],
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] duration: The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        :param pulumi.Input[str] rrule: The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        :param pulumi.Input[str] start: ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "rrule", rrule)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def rrule(self) -> pulumi.Input[str]:
        """
        The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        """
        return pulumi.get(self, "rrule")

    @rrule.setter
    def rrule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rrule", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class IpAllowlistEntryArgs:
    def __init__(__self__, *,
                 cidr_block: pulumi.Input[str],
                 note: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr_block: IP address or range of addresses.
        :param pulumi.Input[str] note: Note accompanying IP address.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        if note is not None:
            pulumi.set(__self__, "note", note)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> pulumi.Input[str]:
        """
        IP address or range of addresses.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter
    def note(self) -> Optional[pulumi.Input[str]]:
        """
        Note accompanying IP address.
        """
        return pulumi.get(self, "note")

    @note.setter
    def note(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "note", value)


@pulumi.input_type
class LogsArchiveAzureArchiveArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 container: pulumi.Input[str],
                 storage_account: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Your client id.
        :param pulumi.Input[str] container: The container where the archive is stored.
        :param pulumi.Input[str] storage_account: The associated storage account.
        :param pulumi.Input[str] tenant_id: Your tenant id.
        :param pulumi.Input[str] path: The path where the archive is stored.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        The container where the archive is stored.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> pulumi.Input[str]:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @storage_account.setter
    def storage_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path where the archive is stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LogsArchiveGcsArchiveArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 client_email: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of your GCS bucket.
        :param pulumi.Input[str] client_email: Your client email.
        :param pulumi.Input[str] path: Path where the archive is stored.
        :param pulumi.Input[str] project_id: Your project id.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of your GCS bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> pulumi.Input[str]:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


@pulumi.input_type
class LogsArchiveS3ArchiveArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 bucket: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_id: Your AWS account id.
        :param pulumi.Input[str] bucket: Name of your s3 bucket.
        :param pulumi.Input[str] role_name: Your AWS role name
        :param pulumi.Input[str] path: Path where the archive is stored.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "role_name", role_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of your s3 bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Your AWS role name
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LogsCustomPipelineFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorArgs:
    def __init__(__self__, *,
                 arithmetic_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']] = None,
                 attribute_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']] = None,
                 category_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']] = None,
                 date_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']] = None,
                 geo_ip_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']] = None,
                 grok_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']] = None,
                 lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']] = None,
                 message_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']] = None,
                 pipeline: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']] = None,
                 reference_table_lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs']] = None,
                 service_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']] = None,
                 status_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']] = None,
                 string_builder_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']] = None,
                 trace_id_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']] = None,
                 url_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']] = None,
                 user_agent_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']] = None):
        """
        :param pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs'] arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs'] attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs'] category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs'] date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs'] geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs'] grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs'] lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs'] message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs'] reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs'] service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs'] status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs'] string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs'] trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs'] url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs'] user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if reference_table_lookup_processor is not None:
            pulumi.set(__self__, "reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']]:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @arithmetic_processor.setter
    def arithmetic_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorArithmeticProcessorArgs']]):
        pulumi.set(self, "arithmetic_processor", value)

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']]:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @attribute_remapper.setter
    def attribute_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorAttributeRemapperArgs']]):
        pulumi.set(self, "attribute_remapper", value)

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']]:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @category_processor.setter
    def category_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorArgs']]):
        pulumi.set(self, "category_processor", value)

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']]:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @date_remapper.setter
    def date_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorDateRemapperArgs']]):
        pulumi.set(self, "date_remapper", value)

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']]:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @geo_ip_parser.setter
    def geo_ip_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorGeoIpParserArgs']]):
        pulumi.set(self, "geo_ip_parser", value)

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']]:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @grok_parser.setter
    def grok_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorGrokParserArgs']]):
        pulumi.set(self, "grok_parser", value)

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']]:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @lookup_processor.setter
    def lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorLookupProcessorArgs']]):
        pulumi.set(self, "lookup_processor", value)

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']]:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @message_remapper.setter
    def message_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorMessageRemapperArgs']]):
        pulumi.set(self, "message_remapper", value)

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']]:
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineArgs']]):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs']]:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @reference_table_lookup_processor.setter
    def reference_table_lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs']]):
        pulumi.set(self, "reference_table_lookup_processor", value)

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']]:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @service_remapper.setter
    def service_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorServiceRemapperArgs']]):
        pulumi.set(self, "service_remapper", value)

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']]:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @status_remapper.setter
    def status_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorStatusRemapperArgs']]):
        pulumi.set(self, "status_remapper", value)

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']]:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @string_builder_processor.setter
    def string_builder_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorStringBuilderProcessorArgs']]):
        pulumi.set(self, "string_builder_processor", value)

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']]:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @trace_id_remapper.setter
    def trace_id_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorTraceIdRemapperArgs']]):
        pulumi.set(self, "trace_id_remapper", value)

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']]:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @url_parser.setter
    def url_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorUrlParserArgs']]):
        pulumi.set(self, "url_parser", value)

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']]:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")

    @user_agent_parser.setter
    def user_agent_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorUserAgentParserArgs']]):
        pulumi.set(self, "user_agent_parser", value)


@pulumi.input_type
class LogsCustomPipelineProcessorArithmeticProcessorArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Arithmetic operation between one or more log attributes.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the arithmetic operation.
        :param pulumi.Input[bool] is_enabled: Boolean value to enable your pipeline.
        :param pulumi.Input[bool] is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param pulumi.Input[str] name: Your pipeline name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorAttributeRemapperArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 target_type: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_on_conflict: Optional[pulumi.Input[bool]] = None,
                 preserve_source: Optional[pulumi.Input[bool]] = None,
                 target_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes or tags.
        :param pulumi.Input[str] target: Final attribute or tag name to remap the sources.
        :param pulumi.Input[str] target_type: Defines if the target is a log `attribute` or `tag`.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] override_on_conflict: Override the target element if already set.
        :param pulumi.Input[bool] preserve_source: Remove or preserve the remapped source element.
        :param pulumi.Input[str] target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Final attribute or tag name to remap the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @override_on_conflict.setter
    def override_on_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_on_conflict", value)

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @preserve_source.setter
    def preserve_source(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_source", value)

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[pulumi.Input[str]]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")

    @target_format.setter
    def target_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_format", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param pulumi.Input[str] target: Name of the target attribute whose value is defined by the matching category.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the category
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]]:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs']]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the target attribute whose value is defined by the matching category.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the category
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs'],
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs']):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorDateRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGeoIpParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGrokParserArgs:
    def __init__(__self__, *,
                 grok: pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs'],
                 source: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 samples: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source: Name of the log attribute to parse.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[Sequence[pulumi.Input[str]]] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs']:
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: pulumi.Input['LogsCustomPipelineProcessorGrokParserGrokArgs']):
        pulumi.set(self, "grok", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def samples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    @samples.setter
    def samples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "samples", value)


@pulumi.input_type
class LogsCustomPipelineProcessorGrokParserGrokArgs:
    def __init__(__self__, *,
                 match_rules: pulumi.Input[str],
                 support_rules: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_rules: Match rules for your grok parser.
        :param pulumi.Input[str] support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> pulumi.Input[str]:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @match_rules.setter
    def match_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_rules", value)

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> pulumi.Input[str]:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    @support_rules.setter
    def support_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "support_rules", value)


@pulumi.input_type
class LogsCustomPipelineProcessorLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_tables: pulumi.Input[Sequence[pulumi.Input[str]]],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 default_lookup: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the lookup.
        :param pulumi.Input[str] default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @lookup_tables.setter
    def lookup_tables(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "lookup_tables", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[pulumi.Input[str]]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @default_lookup.setter
    def default_lookup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_lookup", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorMessageRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]],
                 name: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 processors: Optional[pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]]:
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArgs']]]]):
        pulumi.set(self, "processors", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorArgs:
    def __init__(__self__, *,
                 arithmetic_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']] = None,
                 attribute_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']] = None,
                 category_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']] = None,
                 date_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']] = None,
                 geo_ip_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']] = None,
                 grok_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']] = None,
                 lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']] = None,
                 message_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']] = None,
                 reference_table_lookup_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs']] = None,
                 service_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']] = None,
                 status_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']] = None,
                 string_builder_processor: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']] = None,
                 trace_id_remapper: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']] = None,
                 url_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']] = None,
                 user_agent_parser: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']] = None):
        """
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs'] arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs'] attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs'] category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs'] date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs'] geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs'] grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs'] lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs'] message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs'] reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs'] service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs'] status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs'] string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs'] trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs'] url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs'] user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if reference_table_lookup_processor is not None:
            pulumi.set(__self__, "reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']]:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @arithmetic_processor.setter
    def arithmetic_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs']]):
        pulumi.set(self, "arithmetic_processor", value)

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']]:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @attribute_remapper.setter
    def attribute_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs']]):
        pulumi.set(self, "attribute_remapper", value)

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']]:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @category_processor.setter
    def category_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs']]):
        pulumi.set(self, "category_processor", value)

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']]:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @date_remapper.setter
    def date_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs']]):
        pulumi.set(self, "date_remapper", value)

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']]:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @geo_ip_parser.setter
    def geo_ip_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs']]):
        pulumi.set(self, "geo_ip_parser", value)

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']]:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @grok_parser.setter
    def grok_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs']]):
        pulumi.set(self, "grok_parser", value)

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']]:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @lookup_processor.setter
    def lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs']]):
        pulumi.set(self, "lookup_processor", value)

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']]:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @message_remapper.setter
    def message_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs']]):
        pulumi.set(self, "message_remapper", value)

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs']]:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @reference_table_lookup_processor.setter
    def reference_table_lookup_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs']]):
        pulumi.set(self, "reference_table_lookup_processor", value)

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']]:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @service_remapper.setter
    def service_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs']]):
        pulumi.set(self, "service_remapper", value)

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']]:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @status_remapper.setter
    def status_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs']]):
        pulumi.set(self, "status_remapper", value)

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']]:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @string_builder_processor.setter
    def string_builder_processor(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs']]):
        pulumi.set(self, "string_builder_processor", value)

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']]:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @trace_id_remapper.setter
    def trace_id_remapper(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs']]):
        pulumi.set(self, "trace_id_remapper", value)

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']]:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @url_parser.setter
    def url_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs']]):
        pulumi.set(self, "url_parser", value)

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']]:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")

    @user_agent_parser.setter
    def user_agent_parser(self, value: Optional[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs']]):
        pulumi.set(self, "user_agent_parser", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Arithmetic operation between one or more log attributes.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the arithmetic operation.
        :param pulumi.Input[bool] is_enabled: Boolean value to enable your pipeline.
        :param pulumi.Input[bool] is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param pulumi.Input[str] name: Your pipeline name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 target_type: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_on_conflict: Optional[pulumi.Input[bool]] = None,
                 preserve_source: Optional[pulumi.Input[bool]] = None,
                 target_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes or tags.
        :param pulumi.Input[str] target: Final attribute or tag name to remap the sources.
        :param pulumi.Input[str] target_type: Defines if the target is a log `attribute` or `tag`.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] override_on_conflict: Override the target element if already set.
        :param pulumi.Input[bool] preserve_source: Remove or preserve the remapped source element.
        :param pulumi.Input[str] target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Final attribute or tag name to remap the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[pulumi.Input[bool]]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @override_on_conflict.setter
    def override_on_conflict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_on_conflict", value)

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[pulumi.Input[bool]]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @preserve_source.setter
    def preserve_source(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_source", value)

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[pulumi.Input[str]]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")

    @target_format.setter
    def target_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_format", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param pulumi.Input[str] target: Name of the target attribute whose value is defined by the matching category.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the category
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]]:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[Sequence[pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs']]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the target attribute whose value is defined by the matching category.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the category
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs'],
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs']):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs:
    def __init__(__self__, *,
                 grok: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs'],
                 source: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 samples: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source: Name of the log attribute to parse.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[Sequence[pulumi.Input[str]]] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs']:
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: pulumi.Input['LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs']):
        pulumi.set(self, "grok", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def samples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")

    @samples.setter
    def samples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "samples", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrokArgs:
    def __init__(__self__, *,
                 match_rules: pulumi.Input[str],
                 support_rules: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_rules: Match rules for your grok parser.
        :param pulumi.Input[str] support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> pulumi.Input[str]:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @match_rules.setter
    def match_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_rules", value)

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> pulumi.Input[str]:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")

    @support_rules.setter
    def support_rules(self, value: pulumi.Input[str]):
        pulumi.set(self, "support_rules", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_tables: pulumi.Input[Sequence[pulumi.Input[str]]],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 default_lookup: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the lookup.
        :param pulumi.Input[str] default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @lookup_tables.setter
    def lookup_tables(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "lookup_tables", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[pulumi.Input[str]]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @default_lookup.setter
    def default_lookup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_lookup", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_enrichment_table: pulumi.Input[str],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the lookup.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_enrichment_table", lookup_enrichment_table)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> pulumi.Input[str]:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @lookup_enrichment_table.setter
    def lookup_enrichment_table(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookup_enrichment_table", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 template: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The name of the attribute that contains the result of the template.
        :param pulumi.Input[str] template: The formula with one or more attributes and raw text.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of template by an empty string.
        :param pulumi.Input[str] name: The name of the processor.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The name of the attribute that contains the result of the template.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[str]:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of template by an empty string.
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 normalize_ending_slashes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    @normalize_ending_slashes.setter
    def normalize_ending_slashes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "normalize_ending_slashes", value)


@pulumi.input_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_encoded: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_encoded: If the source attribute is URL encoded or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @is_encoded.setter
    def is_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_encoded", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs:
    def __init__(__self__, *,
                 lookup_enrichment_table: pulumi.Input[str],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param pulumi.Input[str] source: Name of the source attribute used to do the lookup.
        :param pulumi.Input[str] target: Name of the attribute that contains the result of the lookup.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "lookup_enrichment_table", lookup_enrichment_table)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> pulumi.Input[str]:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @lookup_enrichment_table.setter
    def lookup_enrichment_table(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookup_enrichment_table", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorServiceRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorStatusRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorStringBuilderProcessorArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 template: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_replace_missing: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The name of the attribute that contains the result of the template.
        :param pulumi.Input[str] template: The formula with one or more attributes and raw text.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_replace_missing: If it replaces all missing attributes of template by an empty string.
        :param pulumi.Input[str] name: The name of the processor.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The name of the attribute that contains the result of the template.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[str]:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[str]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[pulumi.Input[bool]]:
        """
        If it replaces all missing attributes of template by an empty string.
        """
        return pulumi.get(self, "is_replace_missing")

    @is_replace_missing.setter
    def is_replace_missing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_replace_missing", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorTraceIdRemapperArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsCustomPipelineProcessorUrlParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 normalize_ending_slashes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[str] name: Name of the processor
        :param pulumi.Input[bool] normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[pulumi.Input[bool]]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")

    @normalize_ending_slashes.setter
    def normalize_ending_slashes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "normalize_ending_slashes", value)


@pulumi.input_type
class LogsCustomPipelineProcessorUserAgentParserArgs:
    def __init__(__self__, *,
                 sources: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target: pulumi.Input[str],
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_encoded: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sources: List of source attributes.
        :param pulumi.Input[str] target: Name of the parent attribute that contains all the extracted details from the sources.
        :param pulumi.Input[bool] is_enabled: If the processor is enabled or not.
        :param pulumi.Input[bool] is_encoded: If the source attribute is URL encoded or not.
        :param pulumi.Input[str] name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[pulumi.Input[bool]]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @is_encoded.setter
    def is_encoded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_encoded", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsIndexDailyLimitResetArgs:
    def __init__(__self__, *,
                 reset_time: pulumi.Input[str],
                 reset_utc_offset: pulumi.Input[str]):
        """
        :param pulumi.Input[str] reset_time: String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
        :param pulumi.Input[str] reset_utc_offset: String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
        """
        pulumi.set(__self__, "reset_time", reset_time)
        pulumi.set(__self__, "reset_utc_offset", reset_utc_offset)

    @property
    @pulumi.getter(name="resetTime")
    def reset_time(self) -> pulumi.Input[str]:
        """
        String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
        """
        return pulumi.get(self, "reset_time")

    @reset_time.setter
    def reset_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "reset_time", value)

    @property
    @pulumi.getter(name="resetUtcOffset")
    def reset_utc_offset(self) -> pulumi.Input[str]:
        """
        String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
        """
        return pulumi.get(self, "reset_utc_offset")

    @reset_utc_offset.setter
    def reset_utc_offset(self, value: pulumi.Input[str]):
        pulumi.set(self, "reset_utc_offset", value)


@pulumi.input_type
class LogsIndexExclusionFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: A boolean stating if the exclusion is active or not.
        :param pulumi.Input[str] name: The name of the exclusion filter.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogsIndexExclusionFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LogsIndexExclusionFilterFilterArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None,
                 sample_rate: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        :param pulumi.Input[float] sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")

    @sample_rate.setter
    def sample_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sample_rate", value)


@pulumi.input_type
class LogsIndexFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsMetricComputeArgs:
    def __init__(__self__, *,
                 aggregation_type: pulumi.Input[str],
                 include_percentiles: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation_type: The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        :param pulumi.Input[bool] include_percentiles: Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        :param pulumi.Input[str] path: The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if include_percentiles is not None:
            pulumi.set(__self__, "include_percentiles", include_percentiles)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[str]:
        """
        The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        """
        return pulumi.get(self, "include_percentiles")

    @include_percentiles.setter
    def include_percentiles(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_percentiles", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LogsMetricFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The search query - following the log search syntax.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The search query - following the log search syntax.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LogsMetricGroupByArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 tag_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: The path to the value the log-based metric will be aggregated over.
        :param pulumi.Input[str] tag_name: Name of the tag that gets created.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the value the log-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> pulumi.Input[str]:
        """
        Name of the tag that gets created.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_name", value)


@pulumi.input_type
class MetricTagConfigurationAggregationArgs:
    def __init__(__self__, *,
                 space: pulumi.Input[str],
                 time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] space: A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        :param pulumi.Input[str] time: A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        pulumi.set(__self__, "space", space)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def space(self) -> pulumi.Input[str]:
        """
        A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "space")

    @space.setter
    def space(self, value: pulumi.Input[str]):
        pulumi.set(self, "space", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class MonitorConfigPolicyTagPolicyArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[str],
                 tag_key_required: pulumi.Input[bool],
                 valid_tag_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] tag_key: The key of the tag
        :param pulumi.Input[bool] tag_key_required: If a tag key is required for monitor creation
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_tag_values: Valid values for the tag
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_key_required", tag_key_required)
        pulumi.set(__self__, "valid_tag_values", valid_tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[str]:
        """
        The key of the tag
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagKeyRequired")
    def tag_key_required(self) -> pulumi.Input[bool]:
        """
        If a tag key is required for monitor creation
        """
        return pulumi.get(self, "tag_key_required")

    @tag_key_required.setter
    def tag_key_required(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tag_key_required", value)

    @property
    @pulumi.getter(name="validTagValues")
    def valid_tag_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Valid values for the tag
        """
        return pulumi.get(self, "valid_tag_values")

    @valid_tag_values.setter
    def valid_tag_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "valid_tag_values", value)


@pulumi.input_type
class MonitorMonitorThresholdWindowsArgs:
    def __init__(__self__, *,
                 recovery_window: Optional[pulumi.Input[str]] = None,
                 trigger_window: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] recovery_window: Describes how long an anomalous metric must be normal before the alert recovers.
        :param pulumi.Input[str] trigger_window: Describes how long a metric must be anomalous before an alert triggers.
        """
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @recovery_window.setter
    def recovery_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_window", value)

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[pulumi.Input[str]]:
        """
        Describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")

    @trigger_window.setter
    def trigger_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_window", value)


@pulumi.input_type
class MonitorMonitorThresholdsArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input[str]] = None,
                 critical_recovery: Optional[pulumi.Input[str]] = None,
                 ok: Optional[pulumi.Input[str]] = None,
                 unknown: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input[str]] = None,
                 warning_recovery: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] critical: The monitor `CRITICAL` threshold. Must be a number.
        :param pulumi.Input[str] critical_recovery: The monitor `CRITICAL` recovery threshold. Must be a number.
        :param pulumi.Input[str] ok: The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        :param pulumi.Input[str] unknown: The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        :param pulumi.Input[str] warning: The monitor `WARNING` threshold. Must be a number.
        :param pulumi.Input[str] warning_recovery: The monitor `WARNING` recovery threshold. Must be a number.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `CRITICAL` threshold. Must be a number.
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `CRITICAL` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "critical_recovery")

    @critical_recovery.setter
    def critical_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "critical_recovery", value)

    @property
    @pulumi.getter
    def ok(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "ok")

    @ok.setter
    def ok(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ok", value)

    @property
    @pulumi.getter
    def unknown(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "unknown")

    @unknown.setter
    def unknown(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unknown", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `WARNING` threshold. Must be a number.
        """
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warning", value)

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor `WARNING` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "warning_recovery")

    @warning_recovery.setter
    def warning_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warning_recovery", value)


@pulumi.input_type
class MonitorSchedulingOptionArgs:
    def __init__(__self__, *,
                 custom_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionCustomScheduleArgs']]]] = None,
                 evaluation_windows: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionEvaluationWindowArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionCustomScheduleArgs']]] custom_schedules: Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        :param pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionEvaluationWindowArgs']]] evaluation_windows: Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        if custom_schedules is not None:
            pulumi.set(__self__, "custom_schedules", custom_schedules)
        if evaluation_windows is not None:
            pulumi.set(__self__, "evaluation_windows", evaluation_windows)

    @property
    @pulumi.getter(name="customSchedules")
    def custom_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionCustomScheduleArgs']]]]:
        """
        Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        """
        return pulumi.get(self, "custom_schedules")

    @custom_schedules.setter
    def custom_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionCustomScheduleArgs']]]]):
        pulumi.set(self, "custom_schedules", value)

    @property
    @pulumi.getter(name="evaluationWindows")
    def evaluation_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionEvaluationWindowArgs']]]]:
        """
        Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        return pulumi.get(self, "evaluation_windows")

    @evaluation_windows.setter
    def evaluation_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorSchedulingOptionEvaluationWindowArgs']]]]):
        pulumi.set(self, "evaluation_windows", value)


@pulumi.input_type
class MonitorSchedulingOptionCustomScheduleArgs:
    def __init__(__self__, *,
                 recurrence: pulumi.Input['MonitorSchedulingOptionCustomScheduleRecurrenceArgs']):
        """
        :param pulumi.Input['MonitorSchedulingOptionCustomScheduleRecurrenceArgs'] recurrence: A list of recurrence definitions. Length must be 1.
        """
        pulumi.set(__self__, "recurrence", recurrence)

    @property
    @pulumi.getter
    def recurrence(self) -> pulumi.Input['MonitorSchedulingOptionCustomScheduleRecurrenceArgs']:
        """
        A list of recurrence definitions. Length must be 1.
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: pulumi.Input['MonitorSchedulingOptionCustomScheduleRecurrenceArgs']):
        pulumi.set(self, "recurrence", value)


@pulumi.input_type
class MonitorSchedulingOptionCustomScheduleRecurrenceArgs:
    def __init__(__self__, *,
                 rrule: pulumi.Input[str],
                 timezone: pulumi.Input[str],
                 start: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rrule: Must be a valid `rrule`. See API docs for supported fields
        :param pulumi.Input[str] timezone: 'tz database' format. Example: `America/New_York` or `UTC`
        :param pulumi.Input[str] start: Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        """
        pulumi.set(__self__, "rrule", rrule)
        pulumi.set(__self__, "timezone", timezone)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def rrule(self) -> pulumi.Input[str]:
        """
        Must be a valid `rrule`. See API docs for supported fields
        """
        return pulumi.get(self, "rrule")

    @rrule.setter
    def rrule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rrule", value)

    @property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[str]:
        """
        'tz database' format. Example: `America/New_York` or `UTC`
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        """
        Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class MonitorSchedulingOptionEvaluationWindowArgs:
    def __init__(__self__, *,
                 day_starts: Optional[pulumi.Input[str]] = None,
                 hour_starts: Optional[pulumi.Input[int]] = None,
                 month_starts: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] day_starts: The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        :param pulumi.Input[int] hour_starts: The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        :param pulumi.Input[int] month_starts: The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        if day_starts is not None:
            pulumi.set(__self__, "day_starts", day_starts)
        if hour_starts is not None:
            pulumi.set(__self__, "hour_starts", hour_starts)
        if month_starts is not None:
            pulumi.set(__self__, "month_starts", month_starts)

    @property
    @pulumi.getter(name="dayStarts")
    def day_starts(self) -> Optional[pulumi.Input[str]]:
        """
        The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        """
        return pulumi.get(self, "day_starts")

    @day_starts.setter
    def day_starts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_starts", value)

    @property
    @pulumi.getter(name="hourStarts")
    def hour_starts(self) -> Optional[pulumi.Input[int]]:
        """
        The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        """
        return pulumi.get(self, "hour_starts")

    @hour_starts.setter
    def hour_starts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour_starts", value)

    @property
    @pulumi.getter(name="monthStarts")
    def month_starts(self) -> Optional[pulumi.Input[int]]:
        """
        The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        return pulumi.get(self, "month_starts")

    @month_starts.setter
    def month_starts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month_starts", value)


@pulumi.input_type
class MonitorVariablesArgs:
    def __init__(__self__, *,
                 event_queries: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryArgs']]] event_queries: A timeseries formula and functions events query.
        """
        if event_queries is not None:
            pulumi.set(__self__, "event_queries", event_queries)

    @property
    @pulumi.getter(name="eventQueries")
    def event_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryArgs']]]]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_queries")

    @event_queries.setter
    def event_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryArgs']]]]):
        pulumi.set(self, "event_queries", value)


@pulumi.input_type
class MonitorVariablesEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 search: pulumi.Input['MonitorVariablesEventQuerySearchArgs'],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`, `database_queries`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input['MonitorVariablesEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "search", search)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`, `database_queries`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def search(self) -> pulumi.Input['MonitorVariablesEventQuerySearchArgs']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: pulumi.Input['MonitorVariablesEventQuerySearchArgs']):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorVariablesEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)


@pulumi.input_type
class MonitorVariablesEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class MonitorVariablesEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['MonitorVariablesEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['MonitorVariablesEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['MonitorVariablesEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['MonitorVariablesEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class MonitorVariablesEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class MonitorVariablesEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class OrganizationSettingsSettingsArgs:
    def __init__(__self__, *,
                 saml: pulumi.Input['OrganizationSettingsSettingsSamlArgs'],
                 saml_autocreate_users_domains: pulumi.Input['OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs'],
                 saml_idp_initiated_login: pulumi.Input['OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs'],
                 saml_strict_mode: pulumi.Input['OrganizationSettingsSettingsSamlStrictModeArgs'],
                 private_widget_share: Optional[pulumi.Input[bool]] = None,
                 saml_autocreate_access_role: Optional[pulumi.Input[str]] = None,
                 saml_can_be_enabled: Optional[pulumi.Input[bool]] = None,
                 saml_idp_endpoint: Optional[pulumi.Input[str]] = None,
                 saml_idp_metadata_uploaded: Optional[pulumi.Input[bool]] = None,
                 saml_login_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['OrganizationSettingsSettingsSamlArgs'] saml: SAML properties
        :param pulumi.Input['OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs'] saml_autocreate_users_domains: List of domains where the SAML automated user creation is enabled.
        :param pulumi.Input['OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs'] saml_idp_initiated_login: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param pulumi.Input['OrganizationSettingsSettingsSamlStrictModeArgs'] saml_strict_mode: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        :param pulumi.Input[bool] private_widget_share: Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
        :param pulumi.Input[str] saml_autocreate_access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
        :param pulumi.Input[bool] saml_can_be_enabled: Whether or not SAML can be enabled for this organization.
        :param pulumi.Input[str] saml_idp_endpoint: Identity provider endpoint for SAML authentication.
        :param pulumi.Input[bool] saml_idp_metadata_uploaded: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param pulumi.Input[str] saml_login_url: URL for SAML logging.
        """
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "saml_autocreate_users_domains", saml_autocreate_users_domains)
        pulumi.set(__self__, "saml_idp_initiated_login", saml_idp_initiated_login)
        pulumi.set(__self__, "saml_strict_mode", saml_strict_mode)
        if private_widget_share is not None:
            pulumi.set(__self__, "private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            pulumi.set(__self__, "saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_can_be_enabled is not None:
            pulumi.set(__self__, "saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            pulumi.set(__self__, "saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_metadata_uploaded is not None:
            pulumi.set(__self__, "saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            pulumi.set(__self__, "saml_login_url", saml_login_url)

    @property
    @pulumi.getter
    def saml(self) -> pulumi.Input['OrganizationSettingsSettingsSamlArgs']:
        """
        SAML properties
        """
        return pulumi.get(self, "saml")

    @saml.setter
    def saml(self, value: pulumi.Input['OrganizationSettingsSettingsSamlArgs']):
        pulumi.set(self, "saml", value)

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> pulumi.Input['OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs']:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "saml_autocreate_users_domains")

    @saml_autocreate_users_domains.setter
    def saml_autocreate_users_domains(self, value: pulumi.Input['OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs']):
        pulumi.set(self, "saml_autocreate_users_domains", value)

    @property
    @pulumi.getter(name="samlIdpInitiatedLogin")
    def saml_idp_initiated_login(self) -> pulumi.Input['OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs']:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_initiated_login")

    @saml_idp_initiated_login.setter
    def saml_idp_initiated_login(self, value: pulumi.Input['OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs']):
        pulumi.set(self, "saml_idp_initiated_login", value)

    @property
    @pulumi.getter(name="samlStrictMode")
    def saml_strict_mode(self) -> pulumi.Input['OrganizationSettingsSettingsSamlStrictModeArgs']:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "saml_strict_mode")

    @saml_strict_mode.setter
    def saml_strict_mode(self, value: pulumi.Input['OrganizationSettingsSettingsSamlStrictModeArgs']):
        pulumi.set(self, "saml_strict_mode", value)

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
        """
        return pulumi.get(self, "private_widget_share")

    @private_widget_share.setter
    def private_widget_share(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_widget_share", value)

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[pulumi.Input[str]]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
        """
        return pulumi.get(self, "saml_autocreate_access_role")

    @saml_autocreate_access_role.setter
    def saml_autocreate_access_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_autocreate_access_role", value)

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML can be enabled for this organization.
        """
        return pulumi.get(self, "saml_can_be_enabled")

    @saml_can_be_enabled.setter
    def saml_can_be_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "saml_can_be_enabled", value)

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Identity provider endpoint for SAML authentication.
        """
        return pulumi.get(self, "saml_idp_endpoint")

    @saml_idp_endpoint.setter
    def saml_idp_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_idp_endpoint", value)

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @saml_idp_metadata_uploaded.setter
    def saml_idp_metadata_uploaded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "saml_idp_metadata_uploaded", value)

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL for SAML logging.
        """
        return pulumi.get(self, "saml_login_url")

    @saml_login_url.setter
    def saml_login_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saml_login_url", value)


@pulumi.input_type
class OrganizationSettingsSettingsSamlArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not SAML is enabled for this organization. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not SAML is enabled for this organization. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: List of domains where the SAML automated user creation is enabled.
        :param pulumi.Input[bool] enabled: Whether or not the automated user creation based on SAML domain is enabled. Defaults to `false`.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the automated user creation based on SAML domain is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not a SAML identity provider metadata file was provided to the Datadog organization. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class OrganizationSettingsSettingsSamlStrictModeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PowerpackLayoutArgs:
    def __init__(__self__, *,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None,
                 x: Optional[pulumi.Input[int]] = None,
                 y: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] height: The height of the widget.
        :param pulumi.Input[int] width: The width of the widget.
        :param pulumi.Input[int] x: The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
        :param pulumi.Input[int] y: The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[int]]:
        """
        The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class PowerpackTemplateVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 defaults: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the powerpack template variable.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] defaults: One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
        """
        pulumi.set(__self__, "name", name)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the powerpack template variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def defaults(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
        """
        return pulumi.get(self, "defaults")

    @defaults.setter
    def defaults(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "defaults", value)


@pulumi.input_type
class PowerpackWidgetArgs:
    def __init__(__self__, *,
                 alert_graph_definition: Optional[pulumi.Input['PowerpackWidgetAlertGraphDefinitionArgs']] = None,
                 alert_value_definition: Optional[pulumi.Input['PowerpackWidgetAlertValueDefinitionArgs']] = None,
                 change_definition: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionArgs']] = None,
                 check_status_definition: Optional[pulumi.Input['PowerpackWidgetCheckStatusDefinitionArgs']] = None,
                 distribution_definition: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionArgs']] = None,
                 event_stream_definition: Optional[pulumi.Input['PowerpackWidgetEventStreamDefinitionArgs']] = None,
                 event_timeline_definition: Optional[pulumi.Input['PowerpackWidgetEventTimelineDefinitionArgs']] = None,
                 free_text_definition: Optional[pulumi.Input['PowerpackWidgetFreeTextDefinitionArgs']] = None,
                 geomap_definition: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionArgs']] = None,
                 heatmap_definition: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionArgs']] = None,
                 hostmap_definition: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionArgs']] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 iframe_definition: Optional[pulumi.Input['PowerpackWidgetIframeDefinitionArgs']] = None,
                 image_definition: Optional[pulumi.Input['PowerpackWidgetImageDefinitionArgs']] = None,
                 list_stream_definition: Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionArgs']] = None,
                 log_stream_definition: Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionArgs']] = None,
                 manage_status_definition: Optional[pulumi.Input['PowerpackWidgetManageStatusDefinitionArgs']] = None,
                 note_definition: Optional[pulumi.Input['PowerpackWidgetNoteDefinitionArgs']] = None,
                 query_table_definition: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionArgs']] = None,
                 query_value_definition: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionArgs']] = None,
                 run_workflow_definition: Optional[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionArgs']] = None,
                 scatterplot_definition: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionArgs']] = None,
                 service_level_objective_definition: Optional[pulumi.Input['PowerpackWidgetServiceLevelObjectiveDefinitionArgs']] = None,
                 servicemap_definition: Optional[pulumi.Input['PowerpackWidgetServicemapDefinitionArgs']] = None,
                 slo_list_definition: Optional[pulumi.Input['PowerpackWidgetSloListDefinitionArgs']] = None,
                 sunburst_definition: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionArgs']] = None,
                 timeseries_definition: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionArgs']] = None,
                 toplist_definition: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionArgs']] = None,
                 topology_map_definition: Optional[pulumi.Input['PowerpackWidgetTopologyMapDefinitionArgs']] = None,
                 trace_service_definition: Optional[pulumi.Input['PowerpackWidgetTraceServiceDefinitionArgs']] = None,
                 treemap_definition: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionArgs']] = None,
                 widget_layout: Optional[pulumi.Input['PowerpackWidgetWidgetLayoutArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetAlertGraphDefinitionArgs'] alert_graph_definition: The definition for a Alert Graph widget.
        :param pulumi.Input['PowerpackWidgetAlertValueDefinitionArgs'] alert_value_definition: The definition for a Alert Value widget.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionArgs'] change_definition: The definition for a Change widget.
        :param pulumi.Input['PowerpackWidgetCheckStatusDefinitionArgs'] check_status_definition: The definition for a Check Status widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionArgs'] distribution_definition: The definition for a Distribution widget.
        :param pulumi.Input['PowerpackWidgetEventStreamDefinitionArgs'] event_stream_definition: The definition for a Event Stream widget.
        :param pulumi.Input['PowerpackWidgetEventTimelineDefinitionArgs'] event_timeline_definition: The definition for a Event Timeline widget.
        :param pulumi.Input['PowerpackWidgetFreeTextDefinitionArgs'] free_text_definition: The definition for a Free Text widget.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionArgs'] geomap_definition: The definition for a Geomap widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionArgs'] heatmap_definition: The definition for a Heatmap widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionArgs'] hostmap_definition: The definition for a Hostmap widget.
        :param pulumi.Input[int] id: The ID of the widget.
        :param pulumi.Input['PowerpackWidgetIframeDefinitionArgs'] iframe_definition: The definition for an Iframe widget.
        :param pulumi.Input['PowerpackWidgetImageDefinitionArgs'] image_definition: The definition for an Image widget
        :param pulumi.Input['PowerpackWidgetListStreamDefinitionArgs'] list_stream_definition: The definition for a List Stream widget.
        :param pulumi.Input['PowerpackWidgetLogStreamDefinitionArgs'] log_stream_definition: The definition for an Log Stream widget.
        :param pulumi.Input['PowerpackWidgetManageStatusDefinitionArgs'] manage_status_definition: The definition for an Manage Status widget.
        :param pulumi.Input['PowerpackWidgetNoteDefinitionArgs'] note_definition: The definition for a Note widget.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionArgs'] query_table_definition: The definition for a Query Table widget.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionArgs'] query_value_definition: The definition for a Query Value widget.
        :param pulumi.Input['PowerpackWidgetRunWorkflowDefinitionArgs'] run_workflow_definition: The definition for a Run Workflow widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionArgs'] scatterplot_definition: The definition for a Scatterplot widget.
        :param pulumi.Input['PowerpackWidgetServiceLevelObjectiveDefinitionArgs'] service_level_objective_definition: The definition for a Service Level Objective widget.
        :param pulumi.Input['PowerpackWidgetServicemapDefinitionArgs'] servicemap_definition: The definition for a Service Map widget.
        :param pulumi.Input['PowerpackWidgetSloListDefinitionArgs'] slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionArgs'] sunburst_definition: The definition for a Sunburst widget.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionArgs'] timeseries_definition: The definition for a Timeseries widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionArgs'] toplist_definition: The definition for a Toplist widget.
        :param pulumi.Input['PowerpackWidgetTopologyMapDefinitionArgs'] topology_map_definition: The definition for a Topology Map widget.
        :param pulumi.Input['PowerpackWidgetTraceServiceDefinitionArgs'] trace_service_definition: The definition for a Trace Service widget.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionArgs'] treemap_definition: The definition for a Treemap widget.
        :param pulumi.Input['PowerpackWidgetWidgetLayoutArgs'] widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional[pulumi.Input['PowerpackWidgetAlertGraphDefinitionArgs']]:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @alert_graph_definition.setter
    def alert_graph_definition(self, value: Optional[pulumi.Input['PowerpackWidgetAlertGraphDefinitionArgs']]):
        pulumi.set(self, "alert_graph_definition", value)

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional[pulumi.Input['PowerpackWidgetAlertValueDefinitionArgs']]:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @alert_value_definition.setter
    def alert_value_definition(self, value: Optional[pulumi.Input['PowerpackWidgetAlertValueDefinitionArgs']]):
        pulumi.set(self, "alert_value_definition", value)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionArgs']]:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @change_definition.setter
    def change_definition(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionArgs']]):
        pulumi.set(self, "change_definition", value)

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional[pulumi.Input['PowerpackWidgetCheckStatusDefinitionArgs']]:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @check_status_definition.setter
    def check_status_definition(self, value: Optional[pulumi.Input['PowerpackWidgetCheckStatusDefinitionArgs']]):
        pulumi.set(self, "check_status_definition", value)

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionArgs']]:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @distribution_definition.setter
    def distribution_definition(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionArgs']]):
        pulumi.set(self, "distribution_definition", value)

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional[pulumi.Input['PowerpackWidgetEventStreamDefinitionArgs']]:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @event_stream_definition.setter
    def event_stream_definition(self, value: Optional[pulumi.Input['PowerpackWidgetEventStreamDefinitionArgs']]):
        pulumi.set(self, "event_stream_definition", value)

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional[pulumi.Input['PowerpackWidgetEventTimelineDefinitionArgs']]:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @event_timeline_definition.setter
    def event_timeline_definition(self, value: Optional[pulumi.Input['PowerpackWidgetEventTimelineDefinitionArgs']]):
        pulumi.set(self, "event_timeline_definition", value)

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional[pulumi.Input['PowerpackWidgetFreeTextDefinitionArgs']]:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @free_text_definition.setter
    def free_text_definition(self, value: Optional[pulumi.Input['PowerpackWidgetFreeTextDefinitionArgs']]):
        pulumi.set(self, "free_text_definition", value)

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionArgs']]:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @geomap_definition.setter
    def geomap_definition(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionArgs']]):
        pulumi.set(self, "geomap_definition", value)

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionArgs']]:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @heatmap_definition.setter
    def heatmap_definition(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionArgs']]):
        pulumi.set(self, "heatmap_definition", value)

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionArgs']]:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @hostmap_definition.setter
    def hostmap_definition(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionArgs']]):
        pulumi.set(self, "hostmap_definition", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional[pulumi.Input['PowerpackWidgetIframeDefinitionArgs']]:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @iframe_definition.setter
    def iframe_definition(self, value: Optional[pulumi.Input['PowerpackWidgetIframeDefinitionArgs']]):
        pulumi.set(self, "iframe_definition", value)

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional[pulumi.Input['PowerpackWidgetImageDefinitionArgs']]:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @image_definition.setter
    def image_definition(self, value: Optional[pulumi.Input['PowerpackWidgetImageDefinitionArgs']]):
        pulumi.set(self, "image_definition", value)

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionArgs']]:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @list_stream_definition.setter
    def list_stream_definition(self, value: Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionArgs']]):
        pulumi.set(self, "list_stream_definition", value)

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionArgs']]:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @log_stream_definition.setter
    def log_stream_definition(self, value: Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionArgs']]):
        pulumi.set(self, "log_stream_definition", value)

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional[pulumi.Input['PowerpackWidgetManageStatusDefinitionArgs']]:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @manage_status_definition.setter
    def manage_status_definition(self, value: Optional[pulumi.Input['PowerpackWidgetManageStatusDefinitionArgs']]):
        pulumi.set(self, "manage_status_definition", value)

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional[pulumi.Input['PowerpackWidgetNoteDefinitionArgs']]:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @note_definition.setter
    def note_definition(self, value: Optional[pulumi.Input['PowerpackWidgetNoteDefinitionArgs']]):
        pulumi.set(self, "note_definition", value)

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionArgs']]:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @query_table_definition.setter
    def query_table_definition(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionArgs']]):
        pulumi.set(self, "query_table_definition", value)

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionArgs']]:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @query_value_definition.setter
    def query_value_definition(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionArgs']]):
        pulumi.set(self, "query_value_definition", value)

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionArgs']]:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @run_workflow_definition.setter
    def run_workflow_definition(self, value: Optional[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionArgs']]):
        pulumi.set(self, "run_workflow_definition", value)

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionArgs']]:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @scatterplot_definition.setter
    def scatterplot_definition(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionArgs']]):
        pulumi.set(self, "scatterplot_definition", value)

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional[pulumi.Input['PowerpackWidgetServiceLevelObjectiveDefinitionArgs']]:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @service_level_objective_definition.setter
    def service_level_objective_definition(self, value: Optional[pulumi.Input['PowerpackWidgetServiceLevelObjectiveDefinitionArgs']]):
        pulumi.set(self, "service_level_objective_definition", value)

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional[pulumi.Input['PowerpackWidgetServicemapDefinitionArgs']]:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @servicemap_definition.setter
    def servicemap_definition(self, value: Optional[pulumi.Input['PowerpackWidgetServicemapDefinitionArgs']]):
        pulumi.set(self, "servicemap_definition", value)

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional[pulumi.Input['PowerpackWidgetSloListDefinitionArgs']]:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @slo_list_definition.setter
    def slo_list_definition(self, value: Optional[pulumi.Input['PowerpackWidgetSloListDefinitionArgs']]):
        pulumi.set(self, "slo_list_definition", value)

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionArgs']]:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @sunburst_definition.setter
    def sunburst_definition(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionArgs']]):
        pulumi.set(self, "sunburst_definition", value)

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionArgs']]:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @timeseries_definition.setter
    def timeseries_definition(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionArgs']]):
        pulumi.set(self, "timeseries_definition", value)

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionArgs']]:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @toplist_definition.setter
    def toplist_definition(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionArgs']]):
        pulumi.set(self, "toplist_definition", value)

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional[pulumi.Input['PowerpackWidgetTopologyMapDefinitionArgs']]:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @topology_map_definition.setter
    def topology_map_definition(self, value: Optional[pulumi.Input['PowerpackWidgetTopologyMapDefinitionArgs']]):
        pulumi.set(self, "topology_map_definition", value)

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional[pulumi.Input['PowerpackWidgetTraceServiceDefinitionArgs']]:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @trace_service_definition.setter
    def trace_service_definition(self, value: Optional[pulumi.Input['PowerpackWidgetTraceServiceDefinitionArgs']]):
        pulumi.set(self, "trace_service_definition", value)

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionArgs']]:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @treemap_definition.setter
    def treemap_definition(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionArgs']]):
        pulumi.set(self, "treemap_definition", value)

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional[pulumi.Input['PowerpackWidgetWidgetLayoutArgs']]:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")

    @widget_layout.setter
    def widget_layout(self, value: Optional[pulumi.Input['PowerpackWidgetWidgetLayoutArgs']]):
        pulumi.set(self, "widget_layout", value)


@pulumi.input_type
class PowerpackWidgetAlertGraphDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 viz_type: pulumi.Input[str],
                 live_span: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alert_id: The ID of the monitor used by the widget.
        :param pulumi.Input[str] viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> pulumi.Input[str]:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @viz_type.setter
    def viz_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "viz_type", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetAlertValueDefinitionArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 precision: Optional[pulumi.Input[int]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alert_id: The ID of the monitor used by the widget.
        :param pulumi.Input[int] precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input[str] unit: The unit for the value displayed in the widget.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryArgs']] = None,
                 change_type: Optional[pulumi.Input[str]] = None,
                 compare_to: Optional[pulumi.Input[str]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaArgs']]]] = None,
                 increase_good: Optional[pulumi.Input[bool]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryArgs']] = None,
                 order_by: Optional[pulumi.Input[str]] = None,
                 order_dir: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs']] = None,
                 show_present: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input[str] change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param pulumi.Input[str] compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param pulumi.Input[bool] increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param pulumi.Input[str] order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input[bool] show_present: If set to `true`, displays the current value.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[pulumi.Input[str]]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @compare_to.setter
    def compare_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compare_to", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @increase_good.setter
    def increase_good(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "increase_good", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @order_dir.setter
    def order_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_dir", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")

    @show_present.setter
    def show_present(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_present", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetCheckStatusDefinitionArgs:
    def __init__(__self__, *,
                 check: pulumi.Input[str],
                 grouping: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] check: The check to use in the widget.
        :param pulumi.Input[str] grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param pulumi.Input[str] group: The check group to use in the widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags to use in the widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> pulumi.Input[str]:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: pulumi.Input[str]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter
    def grouping(self) -> pulumi.Input[str]:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @grouping.setter
    def grouping(self, value: pulumi.Input[str]):
        pulumi.set(self, "grouping", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionArgs:
    def __init__(__self__, *,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryArgs']] = None,
                 apm_stats_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryArgs']]:
        return pulumi.get(self, "apm_stats_query")

    @apm_stats_query.setter
    def apm_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryArgs']]):
        pulumi.set(self, "apm_stats_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmStatsQueryArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 primary_tag: pulumi.Input[str],
                 row_type: pulumi.Input[str],
                 service: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: The environment name.
        :param pulumi.Input[str] name: The operation name associated with the service.
        :param pulumi.Input[str] primary_tag: The organization's host group name and value.
        :param pulumi.Input[str] row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param pulumi.Input[str] service: The service name.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]] columns: Column properties used by the front end for display.
        :param pulumi.Input[str] resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> pulumi.Input[str]:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @primary_tag.setter
    def primary_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_tag", value)

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> pulumi.Input[str]:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @row_type.setter
    def row_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_type", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The column name.
        :param pulumi.Input[str] alias: A user-assigned alias for the column.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetDistributionDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class PowerpackWidgetEventStreamDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetEventTimelineDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 live_span: Optional[pulumi.Input[str]] = None,
                 tags_execution: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetFreeTextDefinitionArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 text_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: The text to display in the widget.
        :param pulumi.Input[str] color: The color of the text in the widget.
        :param pulumi.Input[str] font_size: The size of the text in the widget.
        :param pulumi.Input[str] text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionArgs:
    def __init__(__self__, *,
                 view: pulumi.Input['PowerpackWidgetGeomapDefinitionViewArgs'],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestArgs']]]] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionViewArgs'] view: The view of the world that the map should render.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> pulumi.Input['PowerpackWidgetGeomapDefinitionViewArgs']:
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: pulumi.Input['PowerpackWidgetGeomapDefinitionViewArgs']):
        pulumi.set(self, "view", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        """
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionStyleArgs:
    def __init__(__self__, *,
                 palette: pulumi.Input[str],
                 palette_flip: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] palette: The color palette to apply to the widget.
        :param pulumi.Input[bool] palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply to the widget.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> pulumi.Input[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: pulumi.Input[bool]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class PowerpackWidgetGeomapDefinitionViewArgs:
    def __init__(__self__, *,
                 focus: pulumi.Input[str]):
        """
        :param pulumi.Input[str] focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> pulumi.Input[str]:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")

    @focus.setter
    def focus(self, value: pulumi.Input[str]):
        pulumi.set(self, "focus", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionCustomLinkArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionEventArgs']]]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestArgs']]]] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionEventArgs']]] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionEventArgs']]]]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] q: The event query to use in the widget.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs']] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class PowerpackWidgetHeatmapDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionCustomLinkArgs']]]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 no_group_hosts: Optional[pulumi.Input[bool]] = None,
                 no_metric_hosts: Optional[pulumi.Input[bool]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionStyleArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The list of tags to group nodes by.
        :param pulumi.Input[bool] no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param pulumi.Input[bool] no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param pulumi.Input[str] node_type: The type of node used. Valid values are `host`, `container`.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: The list of tags to filter nodes by.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionStyleArgs'] style: The style of the widget graph. One nested block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @no_group_hosts.setter
    def no_group_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_group_hosts", value)

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @no_metric_hosts.setter
    def no_metric_hosts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_metric_hosts", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestArgs']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionStyleArgs']]:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionStyleArgs']]):
        pulumi.set(self, "style", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestArgs:
    def __init__(__self__, *,
                 fills: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillArgs']]]] = None,
                 sizes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillArgs']]] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeArgs']]] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillArgs']]]]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @fills.setter
    def fills(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillArgs']]]]):
        pulumi.set(self, "fills", value)

    @property
    @pulumi.getter
    def sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeArgs']]]]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")

    @sizes.setter
    def sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeArgs']]]]):
        pulumi.set(self, "sizes", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetHostmapDefinitionStyleArgs:
    def __init__(__self__, *,
                 fill_max: Optional[pulumi.Input[str]] = None,
                 fill_min: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_flip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] fill_max: The max value to use to color the map.
        :param pulumi.Input[str] fill_min: The min value to use to color the map.
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        :param pulumi.Input[bool] palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[pulumi.Input[str]]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @fill_max.setter
    def fill_max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_max", value)

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[pulumi.Input[str]]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @fill_min.setter
    def fill_min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fill_min", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")

    @palette_flip.setter
    def palette_flip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "palette_flip", value)


@pulumi.input_type
class PowerpackWidgetIframeDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The URL to use as a data source for the widget.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class PowerpackWidgetImageDefinitionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 has_background: Optional[pulumi.Input[bool]] = None,
                 has_border: Optional[pulumi.Input[bool]] = None,
                 horizontal_align: Optional[pulumi.Input[str]] = None,
                 margin: Optional[pulumi.Input[str]] = None,
                 sizing: Optional[pulumi.Input[str]] = None,
                 url_dark_theme: Optional[pulumi.Input[str]] = None,
                 vertical_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL to use as a data source for the widget.
        :param pulumi.Input[bool] has_background: Whether to display a background or not. Defaults to `true`.
        :param pulumi.Input[bool] has_border: Whether to display a border or not. Defaults to `true`.
        :param pulumi.Input[str] horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param pulumi.Input[str] sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param pulumi.Input[str] url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param pulumi.Input[str] vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "url", url)
        if has_background is not None:
            pulumi.set(__self__, "has_background", has_background)
        if has_border is not None:
            pulumi.set(__self__, "has_border", has_border)
        if horizontal_align is not None:
            pulumi.set(__self__, "horizontal_align", horizontal_align)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if url_dark_theme is not None:
            pulumi.set(__self__, "url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to display a background or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_background")

    @has_background.setter
    def has_background(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_background", value)

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to display a border or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_border")

    @has_border.setter
    def has_border(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_border", value)

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[pulumi.Input[str]]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @horizontal_align.setter
    def horizontal_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "horizontal_align", value)

    @property
    @pulumi.getter
    def margin(self) -> Optional[pulumi.Input[str]]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @margin.setter
    def margin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "margin", value)

    @property
    @pulumi.getter
    def sizing(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @sizing.setter
    def sizing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing", value)

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[pulumi.Input[str]]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @url_dark_theme.setter
    def url_dark_theme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_dark_theme", value)

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")

    @vertical_align.setter
    def vertical_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_align", value)


@pulumi.input_type
class PowerpackWidgetListStreamDefinitionArgs:
    def __init__(__self__, *,
                 requests: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestArgs']]],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestArgs']]] requests: Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title. Default is 16.
        """
        pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestArgs']]]:
        """
        Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestArgs']]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetListStreamDefinitionRequestArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestColumnArgs']]],
                 query: pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQueryArgs'],
                 response_format: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestColumnArgs']]] columns: Widget columns.
        :param pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQueryArgs'] query: Updated list stream widget.
        :param pulumi.Input[str] response_format: Widget response format. Valid values are `event_list`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestColumnArgs']]]:
        """
        Widget columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestColumnArgs']]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQueryArgs']:
        """
        Updated list stream widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> pulumi.Input[str]:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")

    @response_format.setter
    def response_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "response_format", value)


@pulumi.input_type
class PowerpackWidgetListStreamDefinitionRequestColumnArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 width: pulumi.Input[str]):
        """
        :param pulumi.Input[str] field: Widget column field.
        :param pulumi.Input[str] width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[str]:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[str]):
        pulumi.set(self, "width", value)


@pulumi.input_type
class PowerpackWidgetListStreamDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 event_size: Optional[pulumi.Input[str]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQuerySortArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`.
        :param pulumi.Input[str] event_size: Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: List of indexes.
        :param pulumi.Input[str] query_string: Widget query.
        :param pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQuerySortArgs'] sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "data_source", data_source)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[pulumi.Input[str]]:
        """
        Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @event_size.setter
    def event_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_size", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of indexes.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQuerySortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetListStreamDefinitionRequestQuerySortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetListStreamDefinitionRequestQuerySortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetLogStreamDefinitionArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 message_display: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 show_date_column: Optional[pulumi.Input[bool]] = None,
                 show_message_column: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionSortArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[bool] show_date_column: If the date column should be displayed.
        :param pulumi.Input[bool] show_message_column: If the message column should be displayed.
        :param pulumi.Input['PowerpackWidgetLogStreamDefinitionSortArgs'] sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[pulumi.Input[str]]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @message_display.setter
    def message_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_display", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @show_date_column.setter
    def show_date_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_date_column", value)

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[pulumi.Input[bool]]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @show_message_column.setter
    def show_message_column(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_message_column", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionSortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetLogStreamDefinitionSortArgs']]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetLogStreamDefinitionSortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetManageStatusDefinitionArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 color_preference: Optional[pulumi.Input[str]] = None,
                 display_format: Optional[pulumi.Input[str]] = None,
                 hide_zero_counts: Optional[pulumi.Input[bool]] = None,
                 show_last_triggered: Optional[pulumi.Input[bool]] = None,
                 show_priority: Optional[pulumi.Input[bool]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 summary_type: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query to use in the widget.
        :param pulumi.Input[str] color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param pulumi.Input[str] display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param pulumi.Input[bool] hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param pulumi.Input[bool] show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param pulumi.Input[bool] show_priority: Whether to show the priorities column.
        :param pulumi.Input[str] sort: The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        :param pulumi.Input[str] summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if show_priority is not None:
            pulumi.set(__self__, "show_priority", show_priority)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @color_preference.setter
    def color_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color_preference", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @hide_zero_counts.setter
    def hide_zero_counts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_zero_counts", value)

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @show_last_triggered.setter
    def show_last_triggered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_last_triggered", value)

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @show_priority.setter
    def show_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_priority", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[pulumi.Input[str]]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @summary_type.setter
    def summary_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary_type", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetNoteDefinitionArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 background_color: Optional[pulumi.Input[str]] = None,
                 font_size: Optional[pulumi.Input[str]] = None,
                 has_padding: Optional[pulumi.Input[bool]] = None,
                 show_tick: Optional[pulumi.Input[bool]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 tick_edge: Optional[pulumi.Input[str]] = None,
                 tick_pos: Optional[pulumi.Input[str]] = None,
                 vertical_align: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: The content of the note.
        :param pulumi.Input[str] background_color: The background color of the note.
        :param pulumi.Input[str] font_size: The size of the text.
        :param pulumi.Input[bool] has_padding: Whether to add padding or not. Defaults to `true`.
        :param pulumi.Input[bool] show_tick: Whether to show a tick or not.
        :param pulumi.Input[str] text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param pulumi.Input[str] tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param pulumi.Input[str] vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if has_padding is not None:
            pulumi.set(__self__, "has_padding", has_padding)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[pulumi.Input[str]]:
        """
        The background color of the note.
        """
        return pulumi.get(self, "background_color")

    @background_color.setter
    def background_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "background_color", value)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the text.
        """
        return pulumi.get(self, "font_size")

    @font_size.setter
    def font_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "font_size", value)

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to add padding or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_padding")

    @has_padding.setter
    def has_padding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_padding", value)

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @show_tick.setter
    def show_tick(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_tick", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[pulumi.Input[str]]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @tick_edge.setter
    def tick_edge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_edge", value)

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[pulumi.Input[str]]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @tick_pos.setter
    def tick_pos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tick_pos", value)

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[pulumi.Input[str]]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")

    @vertical_align.setter
    def vertical_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vertical_align", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionCustomLinkArgs']]]] = None,
                 has_search_bar: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[pulumi.Input[str]]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @has_search_bar.setter
    def has_search_bar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "has_search_bar", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs']] = None,
                 apm_stats_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryArgs']] = None,
                 cell_display_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaArgs']]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs']] = None,
                 order: Optional[pulumi.Input[str]] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input[str] alias: The alias for the column name (defaults to metric name).
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cell_display_modes: A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input[int] limit: The number of lines to show in the table.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[str] order: The sort order for the rows. Valid values are `asc`, `desc`.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        The alias for the column name (defaults to metric name).
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryArgs']]:
        return pulumi.get(self, "apm_stats_query")

    @apm_stats_query.setter
    def apm_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryArgs']]):
        pulumi.set(self, "apm_stats_query", value)

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @cell_display_modes.setter
    def cell_display_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cell_display_modes", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The sort order for the rows. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 primary_tag: pulumi.Input[str],
                 row_type: pulumi.Input[str],
                 service: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]] = None,
                 resource: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: The environment name.
        :param pulumi.Input[str] name: The operation name associated with the service.
        :param pulumi.Input[str] primary_tag: The organization's host group name and value.
        :param pulumi.Input[str] row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param pulumi.Input[str] service: The service name.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]] columns: Column properties used by the front end for display.
        :param pulumi.Input[str] resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> pulumi.Input[str]:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @primary_tag.setter
    def primary_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_tag", value)

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> pulumi.Input[str]:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @row_type.setter
    def row_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_type", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The column name.
        :param pulumi.Input[str] alias: A user-assigned alias for the column.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionArgs:
    def __init__(__self__, *,
                 autoscale: Optional[pulumi.Input[bool]] = None,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionCustomLinkArgs']]]] = None,
                 custom_unit: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestArgs']]]] = None,
                 text_align: Optional[pulumi.Input[str]] = None,
                 timeseries_background: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] autoscale: A Boolean indicating whether to automatically scale the tile.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] custom_unit: The unit for the value displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[int] precision: The precision to use when displaying the tile.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs'] timeseries_background: Set a timeseries on the widget background.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if timeseries_background is not None:
            pulumi.set(__self__, "timeseries_background", timeseries_background)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @custom_unit.setter
    def custom_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_unit", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @text_align.setter
    def text_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_align", value)

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs']]:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @timeseries_background.setter
    def timeseries_background(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs']]):
        pulumi.set(self, "timeseries_background", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 yaxis: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']] = None):
        """
        :param pulumi.Input[str] type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        pulumi.set(__self__, "type", type)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetRunWorkflowDefinitionArgs:
    def __init__(__self__, *,
                 workflow_id: pulumi.Input[str],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs']]]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionInputArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] workflow_id: Workflow ID
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionInputArgs']]] inputs: Array of workflow inputs to map to dashboard template variables.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "workflow_id", workflow_id)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> pulumi.Input[str]:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @workflow_id.setter
    def workflow_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workflow_id", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionInputArgs']]]]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetRunWorkflowDefinitionInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetRunWorkflowDefinitionInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the workflow input.
        :param pulumi.Input[str] value: Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the workflow input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionArgs:
    def __init__(__self__, *,
                 color_by_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 xaxis: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionXaxisArgs']] = None,
                 yaxis: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] color_by_groups: List of groups used for colors.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionXaxisArgs'] xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @color_by_groups.setter
    def color_by_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "color_by_groups", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestArgs']]:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def xaxis(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionXaxisArgs']]:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @xaxis.setter
    def xaxis(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionXaxisArgs']]):
        pulumi.set(self, "xaxis", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestArgs:
    def __init__(__self__, *,
                 scatterplot_tables: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]] = None,
                 xes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXArgs']]]] = None,
                 ys: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs']]] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXArgs']]] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYArgs']]] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        if scatterplot_tables is not None:
            pulumi.set(__self__, "scatterplot_tables", scatterplot_tables)
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @scatterplot_tables.setter
    def scatterplot_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs']]]]):
        pulumi.set(self, "scatterplot_tables", value)

    @property
    @pulumi.getter
    def xes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXArgs']]]]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @xes.setter
    def xes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXArgs']]]]):
        pulumi.set(self, "xes", value)

    @property
    @pulumi.getter
    def ys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYArgs']]]]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")

    @ys.setter
    def ys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYArgs']]]]):
        pulumi.set(self, "ys", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs']]]]):
        pulumi.set(self, "queries", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormulaArgs:
    def __init__(__self__, *,
                 dimension: pulumi.Input[str],
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> pulumi.Input[str]:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYArgs:
    def __init__(__self__, *,
                 aggregator: Optional[pulumi.Input[str]] = None,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs']] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs']] = None):
        """
        :param pulumi.Input[str] aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs'] security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionXaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetScatterplotDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetServiceLevelObjectiveDefinitionArgs:
    def __init__(__self__, *,
                 slo_id: pulumi.Input[str],
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 view_mode: pulumi.Input[str],
                 view_type: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 global_time_target: Optional[pulumi.Input[str]] = None,
                 show_error_budget: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] slo_id: The ID of the service level objective used by the widget.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param pulumi.Input[str] view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param pulumi.Input[str] view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] global_time_target: The global time target of the widget.
        :param pulumi.Input[bool] show_error_budget: Whether to show the error budget or not.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        The ID of the service level objective used by the widget.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> pulumi.Input[str]:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @view_mode.setter
    def view_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_mode", value)

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> pulumi.Input[str]:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @view_type.setter
    def view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_type", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[pulumi.Input[str]]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @global_time_target.setter
    def global_time_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "global_time_target", value)

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @show_error_budget.setter
    def show_error_budget(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_error_budget", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetServicemapDefinitionArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service: pulumi.Input[str],
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetServicemapDefinitionCustomLinkArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param pulumi.Input[str] service: The ID of the service to map.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetServicemapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetServicemapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetServicemapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetServicemapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetSloListDefinitionArgs:
    def __init__(__self__, *,
                 request: pulumi.Input['PowerpackWidgetSloListDefinitionRequestArgs'],
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PowerpackWidgetSloListDefinitionRequestArgs'] request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> pulumi.Input['PowerpackWidgetSloListDefinitionRequestArgs']:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: pulumi.Input['PowerpackWidgetSloListDefinitionRequestArgs']):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetSloListDefinitionRequestArgs:
    def __init__(__self__, *,
                 query: pulumi.Input['PowerpackWidgetSloListDefinitionRequestQueryArgs'],
                 request_type: pulumi.Input[str]):
        """
        :param pulumi.Input['PowerpackWidgetSloListDefinitionRequestQueryArgs'] query: Updated SLO List widget.
        :param pulumi.Input[str] request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input['PowerpackWidgetSloListDefinitionRequestQueryArgs']:
        """
        Updated SLO List widget.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input['PowerpackWidgetSloListDefinitionRequestQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> pulumi.Input[str]:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "request_type", value)


@pulumi.input_type
class PowerpackWidgetSloListDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 query_string: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetSloListDefinitionRequestQuerySortArgs']] = None):
        """
        :param pulumi.Input[str] query_string: Widget query.
        :param pulumi.Input[int] limit: Maximum number of results to display in the table. Defaults to `100`.
        :param pulumi.Input['PowerpackWidgetSloListDefinitionRequestQuerySortArgs'] sort: The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        pulumi.set(__self__, "query_string", query_string)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of results to display in the table. Defaults to `100`.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetSloListDefinitionRequestQuerySortArgs']]:
        """
        The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetSloListDefinitionRequestQuerySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetSloListDefinitionRequestQuerySortArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 order: pulumi.Input[str]):
        """
        :param pulumi.Input[str] column: The facet path for the column.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionCustomLinkArgs']]]] = None,
                 hide_total: Optional[pulumi.Input[bool]] = None,
                 legend_inline: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendInlineArgs']] = None,
                 legend_table: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendTableArgs']] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionCustomLinkArgs']]] custom_links: Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        :param pulumi.Input[bool] hide_total: Whether or not to show the total value in the widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionLegendInlineArgs'] legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionLegendTableArgs'] legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestArgs']]] requests: Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title. Default is 16.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if hide_total is not None:
            pulumi.set(__self__, "hide_total", hide_total)
        if legend_inline is not None:
            pulumi.set(__self__, "legend_inline", legend_inline)
        if legend_table is not None:
            pulumi.set(__self__, "legend_table", legend_table)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionCustomLinkArgs']]]]:
        """
        Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @hide_total.setter
    def hide_total(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_total", value)

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendInlineArgs']]:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @legend_inline.setter
    def legend_inline(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendInlineArgs']]):
        pulumi.set(self, "legend_inline", value)

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendTableArgs']]:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @legend_table.setter
    def legend_table(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionLegendTableArgs']]):
        pulumi.set(self, "legend_table", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestArgs']]]]:
        """
        Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionLegendInlineArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 hide_percent: Optional[pulumi.Input[bool]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        :param pulumi.Input[bool] hide_percent: Whether to hide the percentages of the groups.
        :param pulumi.Input[bool] hide_value: Whether to hide the values of the groups.
        """
        pulumi.set(__self__, "type", type)
        if hide_percent is not None:
            pulumi.set(__self__, "hide_percent", hide_percent)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @hide_percent.setter
    def hide_percent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_percent", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to hide the values of the groups.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionLegendTableArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: The type of legend (table or none). Valid values are `table`, `none`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of legend (table or none). Valid values are `table`, `none`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs']] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryArgs']] = None,
                 network_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs'] network_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestStyleArgs'] style: Define style for the widget's request.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestStyleArgs']]:
        """
        Define style for the widget's request.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetSunburstDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionCustomLinkArgs']]]] = None,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionEventArgs']]]] = None,
                 legend_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 legend_layout: Optional[pulumi.Input[str]] = None,
                 legend_size: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 markers: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionMarkerArgs']]]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestArgs']]]] = None,
                 right_yaxis: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRightYaxisArgs']] = None,
                 show_legend: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None,
                 yaxis: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionYaxisArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionEventArgs']]] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param pulumi.Input[str] legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param pulumi.Input[str] legend_size: The size of the legend displayed in the widget.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionMarkerArgs']]] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRightYaxisArgs'] right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param pulumi.Input[bool] show_legend: Whether or not to show the legend on this widget.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionYaxisArgs'] yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionEventArgs']]]]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionEventArgs']]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @legend_columns.setter
    def legend_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "legend_columns", value)

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[pulumi.Input[str]]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @legend_layout.setter
    def legend_layout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_layout", value)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @legend_size.setter
    def legend_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend_size", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def markers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionMarkerArgs']]]]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @markers.setter
    def markers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionMarkerArgs']]]]):
        pulumi.set(self, "markers", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRightYaxisArgs']]:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @right_yaxis.setter
    def right_yaxis(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRightYaxisArgs']]):
        pulumi.set(self, "right_yaxis", value)

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @show_legend.setter
    def show_legend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_legend", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionYaxisArgs']]:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")

    @yaxis.setter
    def yaxis(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionYaxisArgs']]):
        pulumi.set(self, "yaxis", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionEventArgs:
    def __init__(__self__, *,
                 q: pulumi.Input[str],
                 tags_execution: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] q: The event query to use in the widget.
        :param pulumi.Input[str] tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> pulumi.Input[str]:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: pulumi.Input[str]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[pulumi.Input[str]]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")

    @tags_execution.setter
    def tags_execution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_execution", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionMarkerArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 display_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        :param pulumi.Input[str] display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param pulumi.Input[str] label: A label for the line or range.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs']] = None,
                 display_type: Optional[pulumi.Input[str]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs']] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs']]]] = None,
                 network_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs']] = None,
                 on_right_yaxis: Optional[pulumi.Input[bool]] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[str] display_type: How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs']]] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs'] network_query: The query to use for this widget.
        :param pulumi.Input[bool] on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestStyleArgs'] style: The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        """
        return pulumi.get(self, "display_type")

    @display_type.setter
    def display_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_type", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs']]]]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @network_query.setter
    def network_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs']]):
        pulumi.set(self, "network_query", value)

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @on_right_yaxis.setter
    def on_right_yaxis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_right_yaxis", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestStyleArgs']]:
        """
        The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 alias_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: The expression name.
        :param pulumi.Input[str] alias_name: The expression alias.
        """
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[pulumi.Input[str]]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")

    @alias_name.setter
    def alias_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias_name", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 line_type: Optional[pulumi.Input[str]] = None,
                 line_width: Optional[pulumi.Input[str]] = None,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param pulumi.Input[str] line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @line_type.setter
    def line_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_type", value)

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[pulumi.Input[str]]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @line_width.setter
    def line_width(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_width", value)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionRightYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetTimeseriesDefinitionYaxisArgs:
    def __init__(__self__, *,
                 include_zero: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 max: Optional[pulumi.Input[str]] = None,
                 min: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] include_zero: Always include zero or fit the axis to the data range.
        :param pulumi.Input[str] label: The label of the axis to display on the graph.
        :param pulumi.Input[str] max: Specify the maximum value to show on the Y-axis.
        :param pulumi.Input[str] min: Specify the minimum value to show on the Y-axis.
        :param pulumi.Input[str] scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[pulumi.Input[bool]]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @include_zero.setter
    def include_zero(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_zero", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionCustomLinkArgs']]]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestArgs:
    def __init__(__self__, *,
                 apm_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryArgs']] = None,
                 audit_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryArgs']] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs']]]] = None,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaArgs']]]] = None,
                 log_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestProcessQueryArgs']] = None,
                 q: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryArgs']]]] = None,
                 rum_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryArgs']] = None,
                 security_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestStyleArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryArgs'] apm_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryArgs'] audit_query: The query to use for this widget.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryArgs'] log_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestProcessQueryArgs'] process_query: The process query to use in the widget. The structure of this block is described below.
        :param pulumi.Input[str] q: The metric query to use for this widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryArgs'] rum_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs'] security_query: The query to use for this widget.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestStyleArgs'] style: Define request for the widget's style.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @apm_query.setter
    def apm_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryArgs']]):
        pulumi.set(self, "apm_query", value)

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @audit_query.setter
    def audit_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryArgs']]):
        pulumi.set(self, "audit_query", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @log_query.setter
    def log_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryArgs']]):
        pulumi.set(self, "log_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestProcessQueryArgs']]:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter
    def q(self) -> Optional[pulumi.Input[str]]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @q.setter
    def q(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "q", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @rum_query.setter
    def rum_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryArgs']]):
        pulumi.set(self, "rum_query", value)

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs']]:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @security_query.setter
    def security_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs']]):
        pulumi.set(self, "security_query", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestStyleArgs']]:
        """
        Define request for the widget's style.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestApmQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestLogQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestProcessQueryArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 filter_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 search_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric: Your chosen metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filter_bies: A list of processes.
        :param pulumi.Input[int] limit: The max number of items in the filter list.
        :param pulumi.Input[str] search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @filter_bies.setter
    def filter_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_bies", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[pulumi.Input[str]]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")

    @search_by.setter
    def search_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_by", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestRumQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 compute_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs']]]] = None,
                 multi_computes: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs']]]] = None,
                 search_query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] index: The name of the index to query.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs'] compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs']]] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs']]] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param pulumi.Input[str] search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs']]:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @compute_query.setter
    def compute_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs']]):
        pulumi.set(self, "compute_query", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs']]]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs']]]]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @multi_computes.setter
    def multi_computes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs']]]]):
        pulumi.set(self, "multi_computes", value)

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")

    @search_query.setter
    def search_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort_query: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs']] = None):
        """
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] limit: The maximum number of items in the group.
        :param pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs'] sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs']]:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")

    @sort_query.setter
    def sort_query(self, value: Optional[pulumi.Input['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs']]):
        pulumi.set(self, "sort_query", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 order: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param pulumi.Input[str] facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 facet: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation method.
        :param pulumi.Input[str] facet: The facet name.
        :param pulumi.Input[int] interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class PowerpackWidgetToplistDefinitionRequestStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)


@pulumi.input_type
class PowerpackWidgetTopologyMapDefinitionArgs:
    def __init__(__self__, *,
                 custom_links: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionCustomLinkArgs']]]] = None,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionCustomLinkArgs']]] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestArgs']]] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionCustomLinkArgs']]]]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @custom_links.setter
    def custom_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionCustomLinkArgs']]]]):
        pulumi.set(self, "custom_links", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestArgs']]]]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetTopologyMapDefinitionCustomLinkArgs:
    def __init__(__self__, *,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 override_label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_hidden: The flag for toggling context menu link visibility.
        :param pulumi.Input[str] label: The label for the custom link URL.
        :param pulumi.Input[str] link: The URL of the custom link.
        :param pulumi.Input[str] override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[pulumi.Input[str]]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")

    @override_label.setter
    def override_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_label", value)


@pulumi.input_type
class PowerpackWidgetTopologyMapDefinitionRequestArgs:
    def __init__(__self__, *,
                 queries: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestQueryArgs']]],
                 request_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestQueryArgs']]] queries: The query for a Topology request.
        :param pulumi.Input[str] request_type: The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestQueryArgs']]]:
        """
        The query for a Topology request.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTopologyMapDefinitionRequestQueryArgs']]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> pulumi.Input[str]:
        """
        The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        return pulumi.get(self, "request_type")

    @request_type.setter
    def request_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "request_type", value)


@pulumi.input_type
class PowerpackWidgetTopologyMapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 filters: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[str] data_source: The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param pulumi.Input[str] service: The ID of the service to map.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class PowerpackWidgetTraceServiceDefinitionArgs:
    def __init__(__self__, *,
                 env: pulumi.Input[str],
                 service: pulumi.Input[str],
                 span_name: pulumi.Input[str],
                 display_format: Optional[pulumi.Input[str]] = None,
                 live_span: Optional[pulumi.Input[str]] = None,
                 show_breakdown: Optional[pulumi.Input[bool]] = None,
                 show_distribution: Optional[pulumi.Input[bool]] = None,
                 show_errors: Optional[pulumi.Input[bool]] = None,
                 show_hits: Optional[pulumi.Input[bool]] = None,
                 show_latency: Optional[pulumi.Input[bool]] = None,
                 show_resource_list: Optional[pulumi.Input[bool]] = None,
                 size_format: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 title_align: Optional[pulumi.Input[str]] = None,
                 title_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] span_name: APM span name
        :param pulumi.Input[str] display_format: The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        :param pulumi.Input[str] live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param pulumi.Input[bool] show_breakdown: Whether to show the latency breakdown or not.
        :param pulumi.Input[bool] show_distribution: Whether to show the latency distribution or not.
        :param pulumi.Input[bool] show_errors: Whether to show the error metrics or not.
        :param pulumi.Input[bool] show_hits: Whether to show the hits metrics or not
        :param pulumi.Input[bool] show_latency: Whether to show the latency metrics or not.
        :param pulumi.Input[bool] show_resource_list: Whether to show the resource list or not.
        :param pulumi.Input[str] size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param pulumi.Input[str] title: The title of the widget.
        :param pulumi.Input[str] title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param pulumi.Input[str] title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> pulumi.Input[str]:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @span_name.setter
    def span_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "span_name", value)

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[pulumi.Input[str]]:
        """
        The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        """
        return pulumi.get(self, "display_format")

    @display_format.setter
    def display_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_format", value)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[pulumi.Input[str]]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @live_span.setter
    def live_span(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "live_span", value)

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @show_breakdown.setter
    def show_breakdown(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_breakdown", value)

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @show_distribution.setter
    def show_distribution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_distribution", value)

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @show_errors.setter
    def show_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_errors", value)

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @show_hits.setter
    def show_hits(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_hits", value)

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @show_latency.setter
    def show_latency(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_latency", value)

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @show_resource_list.setter
    def show_resource_list(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_resource_list", value)

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @size_format.setter
    def size_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_format", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[pulumi.Input[str]]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @title_align.setter
    def title_align(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_align", value)

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @title_size.setter
    def title_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_size", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionArgs:
    def __init__(__self__, *,
                 requests: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestArgs']]] requests: Nested block describing the request to use when displaying the widget.
        :param pulumi.Input[str] title: The title of the widget.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestArgs']]]]:
        """
        Nested block describing the request to use when displaying the widget.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestArgs']]]]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestArgs:
    def __init__(__self__, *,
                 formulas: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaArgs']]]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryArgs']]]] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaArgs']]]]:
        return pulumi.get(self, "formulas")

    @formulas.setter
    def formulas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaArgs']]]]):
        pulumi.set(self, "formulas", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryArgs']]]]):
        pulumi.set(self, "queries", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 cell_display_mode: Optional[pulumi.Input[str]] = None,
                 conditional_formats: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]] = None,
                 limit: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs']] = None,
                 style: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs']] = None):
        """
        :param pulumi.Input[str] formula_expression: A string expression built from queries, formulas, and functions.
        :param pulumi.Input[str] alias: An expression alias.
        :param pulumi.Input[str] cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs'] limit: The options for limiting results returned.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs'] style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[pulumi.Input[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @cell_display_mode.setter
    def cell_display_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cell_display_mode", value)

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @conditional_formats.setter
    def conditional_formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs']]]]):
        pulumi.set(self, "conditional_formats", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs']]:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs']]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def style(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs']]:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @style.setter
    def style(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs']]):
        pulumi.set(self, "style", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 palette: pulumi.Input[str],
                 value: pulumi.Input[float],
                 custom_bg_color: Optional[pulumi.Input[str]] = None,
                 custom_fg_color: Optional[pulumi.Input[str]] = None,
                 hide_value: Optional[pulumi.Input[bool]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 timeframe: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param pulumi.Input[str] palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param pulumi.Input[float] value: A value for the comparator.
        :param pulumi.Input[str] custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param pulumi.Input[str] custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param pulumi.Input[bool] hide_value: Setting this to True hides values.
        :param pulumi.Input[str] image_url: Displays an image as the background.
        :param pulumi.Input[str] metric: The metric from the request to correlate with this conditional format.
        :param pulumi.Input[str] timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def palette(self) -> pulumi.Input[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: pulumi.Input[str]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @custom_bg_color.setter
    def custom_bg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_bg_color", value)

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @custom_fg_color.setter
    def custom_fg_color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fg_color", value)

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @hide_value.setter
    def hide_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_value", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeframe", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The number of results to return.
        :param pulumi.Input[str] order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input[str]] = None,
                 palette_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param pulumi.Input[int] palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input[str]]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palette", value)

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[pulumi.Input[int]]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")

    @palette_index.setter
    def palette_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "palette_index", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryArgs:
    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']] = None,
                 apm_resource_stats_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']] = None,
                 cloud_cost_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']] = None,
                 event_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs']] = None,
                 metric_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs']] = None,
                 process_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs']] = None,
                 slo_query: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs']] = None):
        """
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs'] apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs'] apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs'] cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs'] event_query: A timeseries formula and functions events query.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs'] process_query: The process query using formulas and functions.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs'] slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']]:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @apm_dependency_stats_query.setter
    def apm_dependency_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs']]):
        pulumi.set(self, "apm_dependency_stats_query", value)

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']]:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @apm_resource_stats_query.setter
    def apm_resource_stats_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs']]):
        pulumi.set(self, "apm_resource_stats_query", value)

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']]:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @cloud_cost_query.setter
    def cloud_cost_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs']]):
        pulumi.set(self, "cloud_cost_query", value)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @event_query.setter
    def event_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs']]):
        pulumi.set(self, "event_query", value)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs']]:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @process_query.setter
    def process_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs']]):
        pulumi.set(self, "process_query", value)

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs']]:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")

    @slo_query.setter
    def slo_query(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs']]):
        pulumi.set(self, "slo_query", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 operation_name: pulumi.Input[str],
                 resource_name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 is_upstream: Optional[pulumi.Input[bool]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] resource_name: APM resource.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param pulumi.Input[bool] is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> pulumi.Input[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Input[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @is_upstream.setter
    def is_upstream(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_upstream", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 env: pulumi.Input[str],
                 name: pulumi.Input[str],
                 service: pulumi.Input[str],
                 stat: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 operation_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_name: Optional[pulumi.Input[str]] = None,
                 primary_tag_value: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param pulumi.Input[str] env: APM environment.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] service: APM service.
        :param pulumi.Input[str] stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Array of fields to group results by.
        :param pulumi.Input[str] operation_name: Name of operation on service.
        :param pulumi.Input[str] primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param pulumi.Input[str] primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param pulumi.Input[str] resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def env(self) -> pulumi.Input[str]:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: pulumi.Input[str]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def stat(self) -> pulumi.Input[str]:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @stat.setter
    def stat(self, value: pulumi.Input[str]):
        pulumi.set(self, "stat", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @primary_tag_name.setter
    def primary_tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_name", value)

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @primary_tag_value.setter
    def primary_tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_tag_value", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The cloud cost query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs:
    def __init__(__self__, *,
                 computes: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]],
                 data_source: pulumi.Input[str],
                 name: pulumi.Input[str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']] = None,
                 storage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]] computes: The compute options.
        :param pulumi.Input[str] data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]] group_bies: Group by options.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] indexes: An array of index names to query in the stream.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs'] search: The search options.
        :param pulumi.Input[str] storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]]:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs']]]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs']]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']]:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs']]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 interval: Optional[pulumi.Input[int]] = None,
                 metric: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[int] interval: A time interval in milliseconds.
        :param pulumi.Input[str] metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs:
    def __init__(__self__, *,
                 facet: pulumi.Input[str],
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']] = None):
        """
        :param pulumi.Input[str] facet: The event facet.
        :param pulumi.Input[int] limit: The number of groups to return.
        :param pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs'] sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> pulumi.Input[str]:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: pulumi.Input[str]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs']]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs:
    def __init__(__self__, *,
                 aggregation: pulumi.Input[str],
                 metric: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param pulumi.Input[str] metric: The metric used for sorting group by results.
        :param pulumi.Input[str] order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> pulumi.Input[str]:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The events search string.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 metric: pulumi.Input[str],
                 name: pulumi.Input[str],
                 aggregator: Optional[pulumi.Input[str]] = None,
                 is_normalized_cpu: Optional[pulumi.Input[bool]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_filter: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for process queries. Valid values are `process`, `container`.
        :param pulumi.Input[str] metric: The process metric name.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param pulumi.Input[bool] is_normalized_cpu: Whether to normalize the CPU percentages.
        :param pulumi.Input[int] limit: The number of hits to return.
        :param pulumi.Input[str] sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: An array of tags to filter by.
        :param pulumi.Input[str] text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @aggregator.setter
    def aggregator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregator", value)

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @is_normalized_cpu.setter
    def is_normalized_cpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_normalized_cpu", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")

    @text_filter.setter
    def text_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_filter", value)


@pulumi.input_type
class PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input[str],
                 measure: pulumi.Input[str],
                 slo_id: pulumi.Input[str],
                 additional_query_filters: Optional[pulumi.Input[str]] = None,
                 group_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 slo_query_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_source: The data source for SLO queries. Valid values are `slo`.
        :param pulumi.Input[str] measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param pulumi.Input[str] slo_id: ID of an SLO to query.
        :param pulumi.Input[str] additional_query_filters: Additional filters applied to the SLO query.
        :param pulumi.Input[str] group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param pulumi.Input[str] name: The name of query for use in formulas.
        :param pulumi.Input[str] slo_query_type: type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input[str]:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter
    def measure(self) -> pulumi.Input[str]:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @measure.setter
    def measure(self, value: pulumi.Input[str]):
        pulumi.set(self, "measure", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> pulumi.Input[str]:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @additional_query_filters.setter
    def additional_query_filters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_query_filters", value)

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @group_mode.setter
    def group_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")

    @slo_query_type.setter
    def slo_query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slo_query_type", value)


@pulumi.input_type
class PowerpackWidgetWidgetLayoutArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[int],
                 width: pulumi.Input[int],
                 x: pulumi.Input[int],
                 y: pulumi.Input[int],
                 is_column_break: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] height: The height of the widget.
        :param pulumi.Input[int] width: The width of the widget.
        :param pulumi.Input[int] x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param pulumi.Input[int] y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param pulumi.Input[bool] is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> pulumi.Input[int]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[int]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> pulumi.Input[int]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[int]):
        pulumi.set(self, "width", value)

    @property
    @pulumi.getter
    def x(self) -> pulumi.Input[int]:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: pulumi.Input[int]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> pulumi.Input[int]:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: pulumi.Input[int]):
        pulumi.set(self, "y", value)

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")

    @is_column_break.setter
    def is_column_break(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_column_break", value)


@pulumi.input_type
class RestrictionPolicyBindingArgs:
    def __init__(__self__, *,
                 principals: pulumi.Input[Sequence[pulumi.Input[str]]],
                 relation: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] principals: An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
        :param pulumi.Input[str] relation: The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        pulumi.set(__self__, "principals", principals)
        pulumi.set(__self__, "relation", relation)

    @property
    @pulumi.getter
    def principals(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "principals", value)

    @property
    @pulumi.getter
    def relation(self) -> pulumi.Input[str]:
        """
        The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        return pulumi.get(self, "relation")

    @relation.setter
    def relation(self, value: pulumi.Input[str]):
        pulumi.set(self, "relation", value)


@pulumi.input_type
class RolePermissionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the permission to assign.
        :param pulumi.Input[str] name: Name of the permission.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the permission to assign.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SecurityMonitoringDefaultRuleCaseArgs:
    def __init__(__self__, *,
                 notifications: pulumi.Input[Sequence[pulumi.Input[str]]],
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Notification targets for each rule case.
        :param pulumi.Input[str] status: Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        pulumi.set(__self__, "notifications", notifications)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def notifications(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class SecurityMonitoringDefaultRuleFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        :param pulumi.Input[str] query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SecurityMonitoringDefaultRuleOptionsArgs:
    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        if decrease_criticality_based_on_env is not None:
            pulumi.set(__self__, "decrease_criticality_based_on_env", decrease_criticality_based_on_env)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @decrease_criticality_based_on_env.setter
    def decrease_criticality_based_on_env(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decrease_criticality_based_on_env", value)


@pulumi.input_type
class SecurityMonitoringFilterExclusionFilterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Exclusion filter name.
        :param pulumi.Input[str] query: Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Exclusion filter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SecurityMonitoringRuleCaseArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] status: Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[str] condition: A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        :param pulumi.Input[str] name: Name of the case.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Notification targets for each rule case.
        """
        pulumi.set(__self__, "status", status)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)


@pulumi.input_type
class SecurityMonitoringRuleFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The type of filtering action. Valid values are `require`, `suppress`.
        :param pulumi.Input[str] query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SecurityMonitoringRuleOptionsArgs:
    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[pulumi.Input[bool]] = None,
                 detection_method: Optional[pulumi.Input[str]] = None,
                 evaluation_window: Optional[pulumi.Input[int]] = None,
                 impossible_travel_options: Optional[pulumi.Input['SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs']] = None,
                 keep_alive: Optional[pulumi.Input[int]] = None,
                 max_signal_duration: Optional[pulumi.Input[int]] = None,
                 new_value_options: Optional[pulumi.Input['SecurityMonitoringRuleOptionsNewValueOptionsArgs']] = None,
                 third_party_rule_options: Optional[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs']] = None):
        """
        :param pulumi.Input[bool] decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        :param pulumi.Input[str] detection_method: The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`. Defaults to `"threshold"`.
        :param pulumi.Input[int] evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        :param pulumi.Input['SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs'] impossible_travel_options: Options for rules using the impossible travel detection method.
        :param pulumi.Input[int] keep_alive: Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        :param pulumi.Input[int] max_signal_duration: A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        :param pulumi.Input['SecurityMonitoringRuleOptionsNewValueOptionsArgs'] new_value_options: New value rules specific options.
        :param pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs'] third_party_rule_options: Options for rules using the third-party detection method.
        """
        if decrease_criticality_based_on_env is not None:
            pulumi.set(__self__, "decrease_criticality_based_on_env", decrease_criticality_based_on_env)
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if evaluation_window is not None:
            pulumi.set(__self__, "evaluation_window", evaluation_window)
        if impossible_travel_options is not None:
            pulumi.set(__self__, "impossible_travel_options", impossible_travel_options)
        if keep_alive is not None:
            pulumi.set(__self__, "keep_alive", keep_alive)
        if max_signal_duration is not None:
            pulumi.set(__self__, "max_signal_duration", max_signal_duration)
        if new_value_options is not None:
            pulumi.set(__self__, "new_value_options", new_value_options)
        if third_party_rule_options is not None:
            pulumi.set(__self__, "third_party_rule_options", third_party_rule_options)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @decrease_criticality_based_on_env.setter
    def decrease_criticality_based_on_env(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decrease_criticality_based_on_env", value)

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[pulumi.Input[str]]:
        """
        The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`. Defaults to `"threshold"`.
        """
        return pulumi.get(self, "detection_method")

    @detection_method.setter
    def detection_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detection_method", value)

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> Optional[pulumi.Input[int]]:
        """
        A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        """
        return pulumi.get(self, "evaluation_window")

    @evaluation_window.setter
    def evaluation_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_window", value)

    @property
    @pulumi.getter(name="impossibleTravelOptions")
    def impossible_travel_options(self) -> Optional[pulumi.Input['SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs']]:
        """
        Options for rules using the impossible travel detection method.
        """
        return pulumi.get(self, "impossible_travel_options")

    @impossible_travel_options.setter
    def impossible_travel_options(self, value: Optional[pulumi.Input['SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs']]):
        pulumi.set(self, "impossible_travel_options", value)

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> Optional[pulumi.Input[int]]:
        """
        Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        """
        return pulumi.get(self, "keep_alive")

    @keep_alive.setter
    def keep_alive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_alive", value)

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> Optional[pulumi.Input[int]]:
        """
        A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        """
        return pulumi.get(self, "max_signal_duration")

    @max_signal_duration.setter
    def max_signal_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_signal_duration", value)

    @property
    @pulumi.getter(name="newValueOptions")
    def new_value_options(self) -> Optional[pulumi.Input['SecurityMonitoringRuleOptionsNewValueOptionsArgs']]:
        """
        New value rules specific options.
        """
        return pulumi.get(self, "new_value_options")

    @new_value_options.setter
    def new_value_options(self, value: Optional[pulumi.Input['SecurityMonitoringRuleOptionsNewValueOptionsArgs']]):
        pulumi.set(self, "new_value_options", value)

    @property
    @pulumi.getter(name="thirdPartyRuleOptions")
    def third_party_rule_options(self) -> Optional[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs']]:
        """
        Options for rules using the third-party detection method.
        """
        return pulumi.get(self, "third_party_rule_options")

    @third_party_rule_options.setter
    def third_party_rule_options(self, value: Optional[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs']]):
        pulumi.set(self, "third_party_rule_options", value)


@pulumi.input_type
class SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs:
    def __init__(__self__, *,
                 baseline_user_locations: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] baseline_user_locations: If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
        """
        if baseline_user_locations is not None:
            pulumi.set(__self__, "baseline_user_locations", baseline_user_locations)

    @property
    @pulumi.getter(name="baselineUserLocations")
    def baseline_user_locations(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
        """
        return pulumi.get(self, "baseline_user_locations")

    @baseline_user_locations.setter
    def baseline_user_locations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "baseline_user_locations", value)


@pulumi.input_type
class SecurityMonitoringRuleOptionsNewValueOptionsArgs:
    def __init__(__self__, *,
                 forget_after: pulumi.Input[int],
                 learning_duration: Optional[pulumi.Input[int]] = None,
                 learning_method: Optional[pulumi.Input[str]] = None,
                 learning_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] forget_after: The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        :param pulumi.Input[int] learning_duration: The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
        :param pulumi.Input[str] learning_method: The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
        :param pulumi.Input[int] learning_threshold: A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
        """
        pulumi.set(__self__, "forget_after", forget_after)
        if learning_duration is not None:
            pulumi.set(__self__, "learning_duration", learning_duration)
        if learning_method is not None:
            pulumi.set(__self__, "learning_method", learning_method)
        if learning_threshold is not None:
            pulumi.set(__self__, "learning_threshold", learning_threshold)

    @property
    @pulumi.getter(name="forgetAfter")
    def forget_after(self) -> pulumi.Input[int]:
        """
        The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        """
        return pulumi.get(self, "forget_after")

    @forget_after.setter
    def forget_after(self, value: pulumi.Input[int]):
        pulumi.set(self, "forget_after", value)

    @property
    @pulumi.getter(name="learningDuration")
    def learning_duration(self) -> Optional[pulumi.Input[int]]:
        """
        The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
        """
        return pulumi.get(self, "learning_duration")

    @learning_duration.setter
    def learning_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "learning_duration", value)

    @property
    @pulumi.getter(name="learningMethod")
    def learning_method(self) -> Optional[pulumi.Input[str]]:
        """
        The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
        """
        return pulumi.get(self, "learning_method")

    @learning_method.setter
    def learning_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "learning_method", value)

    @property
    @pulumi.getter(name="learningThreshold")
    def learning_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
        """
        return pulumi.get(self, "learning_threshold")

    @learning_threshold.setter
    def learning_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "learning_threshold", value)


@pulumi.input_type
class SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs:
    def __init__(__self__, *,
                 default_status: pulumi.Input[str],
                 root_queries: pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs']]],
                 default_notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 signal_title_template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_status: Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs']]] root_queries: Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_notifications: Notification targets for the default rule case, when none of the third-party cases match.
        :param pulumi.Input[str] signal_title_template: A template for the signal title; if omitted, the title is generated based on the case name.
        """
        pulumi.set(__self__, "default_status", default_status)
        pulumi.set(__self__, "root_queries", root_queries)
        if default_notifications is not None:
            pulumi.set(__self__, "default_notifications", default_notifications)
        if signal_title_template is not None:
            pulumi.set(__self__, "signal_title_template", signal_title_template)

    @property
    @pulumi.getter(name="defaultStatus")
    def default_status(self) -> pulumi.Input[str]:
        """
        Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "default_status")

    @default_status.setter
    def default_status(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_status", value)

    @property
    @pulumi.getter(name="rootQueries")
    def root_queries(self) -> pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs']]]:
        """
        Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        """
        return pulumi.get(self, "root_queries")

    @root_queries.setter
    def root_queries(self, value: pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs']]]):
        pulumi.set(self, "root_queries", value)

    @property
    @pulumi.getter(name="defaultNotifications")
    def default_notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Notification targets for the default rule case, when none of the third-party cases match.
        """
        return pulumi.get(self, "default_notifications")

    @default_notifications.setter
    def default_notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_notifications", value)

    @property
    @pulumi.getter(name="signalTitleTemplate")
    def signal_title_template(self) -> Optional[pulumi.Input[str]]:
        """
        A template for the signal title; if omitted, the title is generated based on the case name.
        """
        return pulumi.get(self, "signal_title_template")

    @signal_title_template.setter
    def signal_title_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signal_title_template", value)


@pulumi.input_type
class SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] query: Query to filter logs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: Fields to group by. If empty, each log triggers a signal.
        """
        pulumi.set(__self__, "query", query)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query to filter logs.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fields to group by. If empty, each log triggers a signal.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)


@pulumi.input_type
class SecurityMonitoringRuleQueryArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 agent_rules: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleQueryAgentRuleArgs']]]] = None,
                 aggregation: Optional[pulumi.Input[str]] = None,
                 distinct_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: Query to run on logs.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleQueryAgentRuleArgs']]] agent_rules: **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        :param pulumi.Input[str] aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"count"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] distinct_fields: Field for which the cardinality is measured. Sent as an array.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_fields: Fields to group by.
        :param pulumi.Input[str] metric: The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metrics: Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        :param pulumi.Input[str] name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "query", query)
        if agent_rules is not None:
            warnings.warn("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""", DeprecationWarning)
            pulumi.log.warn("""agent_rules is deprecated: `agent_rule` has been deprecated in favor of new Agent Rule resource.""")
        if agent_rules is not None:
            pulumi.set(__self__, "agent_rules", agent_rules)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if distinct_fields is not None:
            pulumi.set(__self__, "distinct_fields", distinct_fields)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if metric is not None:
            warnings.warn("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""metric is deprecated: Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query to run on logs.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="agentRules")
    @_utilities.deprecated("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""")
    def agent_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleQueryAgentRuleArgs']]]]:
        """
        **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        """
        return pulumi.get(self, "agent_rules")

    @agent_rules.setter
    def agent_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityMonitoringRuleQueryAgentRuleArgs']]]]):
        pulumi.set(self, "agent_rules", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"count"`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Field for which the cardinality is measured. Sent as an array.
        """
        return pulumi.get(self, "distinct_fields")

    @distinct_fields.setter
    def distinct_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "distinct_fields", value)

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fields to group by.
        """
        return pulumi.get(self, "group_by_fields")

    @group_by_fields.setter
    def group_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_fields", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SecurityMonitoringRuleQueryAgentRuleArgs:
    def __init__(__self__, *,
                 agent_rule_id: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] agent_rule_id: **Deprecated**. It won't be applied anymore.
        :param pulumi.Input[str] expression: **Deprecated**. It won't be applied anymore.
        """
        pulumi.set(__self__, "agent_rule_id", agent_rule_id)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="agentRuleId")
    def agent_rule_id(self) -> pulumi.Input[str]:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "agent_rule_id")

    @agent_rule_id.setter
    def agent_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent_rule_id", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class SecurityMonitoringRuleSignalQueryArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[str],
                 aggregation: Optional[pulumi.Input[str]] = None,
                 correlated_by_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 correlated_query_index: Optional[pulumi.Input[str]] = None,
                 default_rule_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rule_id: Rule ID of the signal to correlate.
        :param pulumi.Input[str] aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"event_count"`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] correlated_by_fields: Fields to correlate by.
        :param pulumi.Input[str] correlated_query_index: Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
        :param pulumi.Input[str] default_rule_id: Default Rule ID of the signal to correlate. This value is READ-ONLY.
        :param pulumi.Input[str] name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if correlated_by_fields is not None:
            pulumi.set(__self__, "correlated_by_fields", correlated_by_fields)
        if correlated_query_index is not None:
            pulumi.set(__self__, "correlated_query_index", correlated_query_index)
        if default_rule_id is not None:
            pulumi.set(__self__, "default_rule_id", default_rule_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Rule ID of the signal to correlate.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"event_count"`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation", value)

    @property
    @pulumi.getter(name="correlatedByFields")
    def correlated_by_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fields to correlate by.
        """
        return pulumi.get(self, "correlated_by_fields")

    @correlated_by_fields.setter
    def correlated_by_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "correlated_by_fields", value)

    @property
    @pulumi.getter(name="correlatedQueryIndex")
    def correlated_query_index(self) -> Optional[pulumi.Input[str]]:
        """
        Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
        """
        return pulumi.get(self, "correlated_query_index")

    @correlated_query_index.setter
    def correlated_query_index(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "correlated_query_index", value)

    @property
    @pulumi.getter(name="defaultRuleId")
    def default_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        Default Rule ID of the signal to correlate. This value is READ-ONLY.
        """
        return pulumi.get(self, "default_rule_id")

    @default_rule_id.setter
    def default_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_rule_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SecurityMonitoringRuleThirdPartyCaseArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param pulumi.Input[str] name: Name of the case.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Notification targets for each rule case.
        :param pulumi.Input[str] query: A query to associate a third-party event to this case.
        """
        pulumi.set(__self__, "status", status)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @notifications.setter
    def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notifications", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        A query to associate a third-party event to this case.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SensitiveDataScannerGroupFilterArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: Query to filter the events.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query to filter the events.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SensitiveDataScannerRuleIncludedKeywordConfigurationArgs:
    def __init__(__self__, *,
                 character_count: pulumi.Input[int],
                 keywords: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[int] character_count: Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keywords: Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
        """
        pulumi.set(__self__, "character_count", character_count)
        pulumi.set(__self__, "keywords", keywords)

    @property
    @pulumi.getter(name="characterCount")
    def character_count(self) -> pulumi.Input[int]:
        """
        Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
        """
        return pulumi.get(self, "character_count")

    @character_count.setter
    def character_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "character_count", value)

    @property
    @pulumi.getter
    def keywords(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
        """
        return pulumi.get(self, "keywords")

    @keywords.setter
    def keywords(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "keywords", value)


@pulumi.input_type
class SensitiveDataScannerRuleTextReplacementArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 number_of_chars: Optional[pulumi.Input[int]] = None,
                 replacement_string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        :param pulumi.Input[int] number_of_chars: Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        :param pulumi.Input[str] replacement_string: Required if type == 'replacement_string'.
        """
        pulumi.set(__self__, "type", type)
        if number_of_chars is not None:
            pulumi.set(__self__, "number_of_chars", number_of_chars)
        if replacement_string is not None:
            pulumi.set(__self__, "replacement_string", replacement_string)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="numberOfChars")
    def number_of_chars(self) -> Optional[pulumi.Input[int]]:
        """
        Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        """
        return pulumi.get(self, "number_of_chars")

    @number_of_chars.setter
    def number_of_chars(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_chars", value)

    @property
    @pulumi.getter(name="replacementString")
    def replacement_string(self) -> Optional[pulumi.Input[str]]:
        """
        Required if type == 'replacement_string'.
        """
        return pulumi.get(self, "replacement_string")

    @replacement_string.setter
    def replacement_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replacement_string", value)


@pulumi.input_type
class ServiceLevelObjectiveQueryArgs:
    def __init__(__self__, *,
                 denominator: pulumi.Input[str],
                 numerator: pulumi.Input[str]):
        """
        :param pulumi.Input[str] denominator: The sum of the `total` events.
        :param pulumi.Input[str] numerator: The sum of all the `good` events.
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> pulumi.Input[str]:
        """
        The sum of the `total` events.
        """
        return pulumi.get(self, "denominator")

    @denominator.setter
    def denominator(self, value: pulumi.Input[str]):
        pulumi.set(self, "denominator", value)

    @property
    @pulumi.getter
    def numerator(self) -> pulumi.Input[str]:
        """
        The sum of all the `good` events.
        """
        return pulumi.get(self, "numerator")

    @numerator.setter
    def numerator(self, value: pulumi.Input[str]):
        pulumi.set(self, "numerator", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationArgs:
    def __init__(__self__, *,
                 time_slice: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceArgs']):
        """
        :param pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceArgs'] time_slice: The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold. Optionally, a fourth part, the query interval, can be provided.
        """
        pulumi.set(__self__, "time_slice", time_slice)

    @property
    @pulumi.getter(name="timeSlice")
    def time_slice(self) -> pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceArgs']:
        """
        The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold. Optionally, a fourth part, the query interval, can be provided.
        """
        return pulumi.get(self, "time_slice")

    @time_slice.setter
    def time_slice(self, value: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceArgs']):
        pulumi.set(self, "time_slice", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationTimeSliceArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input[str],
                 query: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs'],
                 threshold: pulumi.Input[float],
                 query_interval_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] comparator: The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
        :param pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs'] query: A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
        :param pulumi.Input[float] threshold: The threshold value to which each SLI value will be compared.
        :param pulumi.Input[int] query_interval_seconds: The interval used when querying data, which defines the size of a time slice. Valid values are `60`, `300`. Defaults to `300`.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "threshold", threshold)
        if query_interval_seconds is not None:
            pulumi.set(__self__, "query_interval_seconds", query_interval_seconds)

    @property
    @pulumi.getter
    def comparator(self) -> pulumi.Input[str]:
        """
        The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input[str]):
        pulumi.set(self, "comparator", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs']:
        """
        A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold value to which each SLI value will be compared.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="queryIntervalSeconds")
    def query_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The interval used when querying data, which defines the size of a time slice. Valid values are `60`, `300`. Defaults to `300`.
        """
        return pulumi.get(self, "query_interval_seconds")

    @query_interval_seconds.setter
    def query_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_interval_seconds", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs:
    def __init__(__self__, *,
                 formula: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs'],
                 queries: pulumi.Input[Sequence[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs']]]):
        """
        :param pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs'] formula: A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs']]] queries: A list of data-source-specific queries that are in the formula.
        """
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formula(self) -> pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs']:
        """
        A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs']):
        pulumi.set(self, "formula", value)

    @property
    @pulumi.getter
    def queries(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs']]]:
        """
        A list of data-source-specific queries that are in the formula.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs']]]):
        pulumi.set(self, "queries", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs:
    def __init__(__self__, *,
                 formula_expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] formula_expression: The formula string, which is an expression involving named queries.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> pulumi.Input[str]:
        """
        The formula string, which is an expression involving named queries.
        """
        return pulumi.get(self, "formula_expression")

    @formula_expression.setter
    def formula_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "formula_expression", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs:
    def __init__(__self__, *,
                 metric_query: Optional[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs']] = None):
        """
        :param pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs'] metric_query: A timeseries formula and functions metrics query.
        """
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs']]:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @metric_query.setter
    def metric_query(self, value: Optional[pulumi.Input['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs']]):
        pulumi.set(self, "metric_query", value)


@pulumi.input_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 query: pulumi.Input[str],
                 data_source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the query for use in formulas.
        :param pulumi.Input[str] query: The metrics query definition.
        :param pulumi.Input[str] data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[str]]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_source", value)


@pulumi.input_type
class ServiceLevelObjectiveThresholdArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[float],
                 timeframe: pulumi.Input[str],
                 target_display: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input[float]] = None,
                 warning_display: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] target: The objective's target in `(0,100)`.
        :param pulumi.Input[str] timeframe: The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        :param pulumi.Input[str] target_display: A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        :param pulumi.Input[float] warning: The objective's warning value in `(0,100)`. This must be greater than the target value.
        :param pulumi.Input[str] warning_display: A string representation of the warning target (see the description of the target_display field for details).
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timeframe", timeframe)
        if target_display is not None:
            pulumi.set(__self__, "target_display", target_display)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_display is not None:
            pulumi.set(__self__, "warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        The objective's target in `(0,100)`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def timeframe(self) -> pulumi.Input[str]:
        """
        The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        """
        return pulumi.get(self, "timeframe")

    @timeframe.setter
    def timeframe(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeframe", value)

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[pulumi.Input[str]]:
        """
        A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        """
        return pulumi.get(self, "target_display")

    @target_display.setter
    def target_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_display", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[float]]:
        """
        The objective's warning value in `(0,100)`. This must be greater than the target value.
        """
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "warning", value)

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[pulumi.Input[str]]:
        """
        A string representation of the warning target (see the description of the target_display field for details).
        """
        return pulumi.get(self, "warning_display")

    @warning_display.setter
    def warning_display(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warning_display", value)


@pulumi.input_type
class SpansMetricComputeArgs:
    def __init__(__self__, *,
                 aggregation_type: pulumi.Input[str],
                 include_percentiles: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aggregation_type: The type of aggregation to use. This field can't be updated after creation.
        :param pulumi.Input[bool] include_percentiles: Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        :param pulumi.Input[str] path: The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if include_percentiles is not None:
            pulumi.set(__self__, "include_percentiles", include_percentiles)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> pulumi.Input[str]:
        """
        The type of aggregation to use. This field can't be updated after creation.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        """
        return pulumi.get(self, "include_percentiles")

    @include_percentiles.setter
    def include_percentiles(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_percentiles", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class SpansMetricFilterArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The search query - following the span search syntax. Defaults to `"*"`.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The search query - following the span search syntax. Defaults to `"*"`.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class SpansMetricGroupByArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 tag_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: The path to the value the span-based metric will be aggregated over.
        :param pulumi.Input[str] tag_name: Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        pulumi.set(__self__, "path", path)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the value the span-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        """
        Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)


@pulumi.input_type
class SyntheticsGlobalVariableOptionsArgs:
    def __init__(__self__, *,
                 totp_parameters: Optional[pulumi.Input['SyntheticsGlobalVariableOptionsTotpParametersArgs']] = None):
        """
        :param pulumi.Input['SyntheticsGlobalVariableOptionsTotpParametersArgs'] totp_parameters: Parameters needed for MFA/TOTP.
        """
        if totp_parameters is not None:
            pulumi.set(__self__, "totp_parameters", totp_parameters)

    @property
    @pulumi.getter(name="totpParameters")
    def totp_parameters(self) -> Optional[pulumi.Input['SyntheticsGlobalVariableOptionsTotpParametersArgs']]:
        """
        Parameters needed for MFA/TOTP.
        """
        return pulumi.get(self, "totp_parameters")

    @totp_parameters.setter
    def totp_parameters(self, value: Optional[pulumi.Input['SyntheticsGlobalVariableOptionsTotpParametersArgs']]):
        pulumi.set(self, "totp_parameters", value)


@pulumi.input_type
class SyntheticsGlobalVariableOptionsTotpParametersArgs:
    def __init__(__self__, *,
                 digits: pulumi.Input[int],
                 refresh_interval: pulumi.Input[int]):
        """
        :param pulumi.Input[int] digits: Number of digits for the OTP.
        :param pulumi.Input[int] refresh_interval: Interval for which to refresh the token (in seconds).
        """
        pulumi.set(__self__, "digits", digits)
        pulumi.set(__self__, "refresh_interval", refresh_interval)

    @property
    @pulumi.getter
    def digits(self) -> pulumi.Input[int]:
        """
        Number of digits for the OTP.
        """
        return pulumi.get(self, "digits")

    @digits.setter
    def digits(self, value: pulumi.Input[int]):
        pulumi.set(self, "digits", value)

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> pulumi.Input[int]:
        """
        Interval for which to refresh the token (in seconds).
        """
        return pulumi.get(self, "refresh_interval")

    @refresh_interval.setter
    def refresh_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "refresh_interval", value)


@pulumi.input_type
class SyntheticsGlobalVariableParseTestOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 field: Optional[pulumi.Input[str]] = None,
                 local_variable_name: Optional[pulumi.Input[str]] = None,
                 parser: Optional[pulumi.Input['SyntheticsGlobalVariableParseTestOptionsParserArgs']] = None):
        """
        :param pulumi.Input[str] type: Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `local_variable`.
        :param pulumi.Input[str] field: Required when type = `http_header`. Defines the header to use to extract the value
        :param pulumi.Input[str] local_variable_name: When type is `local_variable`, name of the local variable to use to extract the value.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if local_variable_name is not None:
            pulumi.set(__self__, "local_variable_name", local_variable_name)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `local_variable`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        Required when type = `http_header`. Defines the header to use to extract the value
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter(name="localVariableName")
    def local_variable_name(self) -> Optional[pulumi.Input[str]]:
        """
        When type is `local_variable`, name of the local variable to use to extract the value.
        """
        return pulumi.get(self, "local_variable_name")

    @local_variable_name.setter
    def local_variable_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_variable_name", value)

    @property
    @pulumi.getter
    def parser(self) -> Optional[pulumi.Input['SyntheticsGlobalVariableParseTestOptionsParserArgs']]:
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: Optional[pulumi.Input['SyntheticsGlobalVariableParseTestOptionsParserArgs']]):
        pulumi.set(self, "parser", value)


@pulumi.input_type
class SyntheticsGlobalVariableParseTestOptionsParserArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        :param pulumi.Input[str] value: Value for the parser to use, required for type `json_path` or `regex`.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value for the parser to use, required for type `json_path` or `regex`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticsPrivateLocationMetadataArgs:
    def __init__(__self__, *,
                 restricted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        if restricted_roles is not None:
            pulumi.set(__self__, "restricted_roles", restricted_roles)

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")

    @restricted_roles.setter
    def restricted_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "restricted_roles", value)


@pulumi.input_type
class SyntheticsTestApiStepArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 allow_failure: Optional[pulumi.Input[bool]] = None,
                 assertions: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepAssertionArgs']]]] = None,
                 extracted_values: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepExtractedValueArgs']]]] = None,
                 is_critical: Optional[pulumi.Input[bool]] = None,
                 request_basicauth: Optional[pulumi.Input['SyntheticsTestApiStepRequestBasicauthArgs']] = None,
                 request_client_certificate: Optional[pulumi.Input['SyntheticsTestApiStepRequestClientCertificateArgs']] = None,
                 request_definition: Optional[pulumi.Input['SyntheticsTestApiStepRequestDefinitionArgs']] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 request_proxy: Optional[pulumi.Input['SyntheticsTestApiStepRequestProxyArgs']] = None,
                 request_query: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 retry: Optional[pulumi.Input['SyntheticsTestApiStepRetryArgs']] = None,
                 subtype: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the step.
        :param pulumi.Input[bool] allow_failure: Determines whether or not to continue with test if this step fails.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepAssertionArgs']]] assertions: Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepExtractedValueArgs']]] extracted_values: Values to parse and save as variables from the response.
        :param pulumi.Input[bool] is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param pulumi.Input['SyntheticsTestApiStepRequestBasicauthArgs'] request_basicauth: The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input['SyntheticsTestApiStepRequestClientCertificateArgs'] request_client_certificate: Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input['SyntheticsTestApiStepRequestDefinitionArgs'] request_definition: The request for the api step.
        :param pulumi.Input[Mapping[str, Any]] request_headers: Header name and value map.
        :param pulumi.Input['SyntheticsTestApiStepRequestProxyArgs'] request_proxy: The proxy to perform the test.
        :param pulumi.Input[Mapping[str, Any]] request_query: Query arguments name and value map.
        :param pulumi.Input[str] subtype: The subtype of the Synthetic multistep API test step. Valid values are `http`, `grpc`. Defaults to `"http"`.
        """
        pulumi.set(__self__, "name", name)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if extracted_values is not None:
            pulumi.set(__self__, "extracted_values", extracted_values)
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if request_basicauth is not None:
            pulumi.set(__self__, "request_basicauth", request_basicauth)
        if request_client_certificate is not None:
            pulumi.set(__self__, "request_client_certificate", request_client_certificate)
        if request_definition is not None:
            pulumi.set(__self__, "request_definition", request_definition)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_proxy is not None:
            pulumi.set(__self__, "request_proxy", request_proxy)
        if request_query is not None:
            pulumi.set(__self__, "request_query", request_query)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if subtype is not None:
            pulumi.set(__self__, "subtype", subtype)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not to continue with test if this step fails.
        """
        return pulumi.get(self, "allow_failure")

    @allow_failure.setter
    def allow_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_failure", value)

    @property
    @pulumi.getter
    def assertions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepAssertionArgs']]]]:
        """
        Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "assertions")

    @assertions.setter
    def assertions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepAssertionArgs']]]]):
        pulumi.set(self, "assertions", value)

    @property
    @pulumi.getter(name="extractedValues")
    def extracted_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepExtractedValueArgs']]]]:
        """
        Values to parse and save as variables from the response.
        """
        return pulumi.get(self, "extracted_values")

    @extracted_values.setter
    def extracted_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SyntheticsTestApiStepExtractedValueArgs']]]]):
        pulumi.set(self, "extracted_values", value)

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @is_critical.setter
    def is_critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_critical", value)

    @property
    @pulumi.getter(name="requestBasicauth")
    def request_basicauth(self) -> Optional[pulumi.Input['SyntheticsTestApiStepRequestBasicauthArgs']]:
        """
        The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_basicauth")

    @request_basicauth.setter
    def request_basicauth(self, value: Optional[pulumi.Input['SyntheticsTestApiStepRequestBasicauthArgs']]):
        pulumi.set(self, "request_basicauth", value)

    @property
    @pulumi.getter(name="requestClientCertificate")
    def request_client_certificate(self) -> Optional[pulumi.Input['SyntheticsTestApiStepRequestClientCertificateArgs']]:
        """
        Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_client_certificate")

    @request_client_certificate.setter
    def request_client_certificate(self, value: Optional[pulumi.Input['SyntheticsTestApiStepRequestClientCertificateArgs']]):
        pulumi.set(self, "request_client_certificate", value)

    @property
    @pulumi.getter(name="requestDefinition")
    def request_definition(self) -> Optional[pulumi.Input['SyntheticsTestApiStepRequestDefinitionArgs']]:
        """
        The request for the api step.
        """
        return pulumi.get(self, "request_definition")

    @request_definition.setter
    def request_definition(self, value: Optional[pulumi.Input['SyntheticsTestApiStepRequestDefinitionArgs']]):
        pulumi.set(self, "request_definition", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="requestProxy")
    def request_proxy(self) -> Optional[pulumi.Input['SyntheticsTestApiStepRequestProxyArgs']]:
        """
        The proxy to perform the test.
        """
        return pulumi.get(self, "request_proxy")

    @request_proxy.setter
    def request_proxy(self, value: Optional[pulumi.Input['SyntheticsTestApiStepRequestProxyArgs']]):
        pulumi.set(self, "request_proxy", value)

    @property
    @pulumi.getter(name="requestQuery")
    def request_query(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Query arguments name and value map.
        """
        return pulumi.get(self, "request_query")

    @request_query.setter
    def request_query(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "request_query", value)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input['SyntheticsTestApiStepRetryArgs']]:
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input['SyntheticsTestApiStepRetryArgs']]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter
    def subtype(self) -> Optional[pulumi.Input[str]]:
        """
        The subtype of the Synthetic multistep API test step. Valid values are `http`, `grpc`. Defaults to `"http"`.
        """
        return pulumi.get(self, "subtype")

    @subtype.setter
    def subtype(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subtype", value)


@pulumi.input_type
class SyntheticsTestApiStepAssertionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 type: pulumi.Input[str],
                 property: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 targetjsonpath: Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetjsonpathArgs']] = None,
                 targetxpath: Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetxpathArgs']] = None,
                 timings_scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param pulumi.Input[str] type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param pulumi.Input[str] property: If assertion type is `header`, this is the header name.
        :param pulumi.Input[str] target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param pulumi.Input['SyntheticsTestApiStepAssertionTargetjsonpathArgs'] targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input['SyntheticsTestApiStepAssertionTargetxpathArgs'] targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input[str] timings_scope: Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if targetjsonpath is not None:
            pulumi.set(__self__, "targetjsonpath", targetjsonpath)
        if targetxpath is not None:
            pulumi.set(__self__, "targetxpath", targetxpath)
        if timings_scope is not None:
            pulumi.set(__self__, "timings_scope", timings_scope)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetjsonpathArgs']]:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @targetjsonpath.setter
    def targetjsonpath(self, value: Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetjsonpathArgs']]):
        pulumi.set(self, "targetjsonpath", value)

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetxpathArgs']]:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @targetxpath.setter
    def targetxpath(self, value: Optional[pulumi.Input['SyntheticsTestApiStepAssertionTargetxpathArgs']]):
        pulumi.set(self, "targetxpath", value)

    @property
    @pulumi.getter(name="timingsScope")
    def timings_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        return pulumi.get(self, "timings_scope")

    @timings_scope.setter
    def timings_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timings_scope", value)

    @property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[str]]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class SyntheticsTestApiStepAssertionTargetjsonpathArgs:
    def __init__(__self__, *,
                 jsonpath: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 targetvalue: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] jsonpath: The JSON path to assert.
        :param pulumi.Input[str] operator: The specific operator to use on the path.
        :param pulumi.Input[str] targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "jsonpath", jsonpath)
        pulumi.set(__self__, "operator", operator)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> pulumi.Input[str]:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @jsonpath.setter
    def jsonpath(self, value: pulumi.Input[str]):
        pulumi.set(self, "jsonpath", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[pulumi.Input[str]]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")

    @targetvalue.setter
    def targetvalue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "targetvalue", value)


@pulumi.input_type
class SyntheticsTestApiStepAssertionTargetxpathArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 xpath: pulumi.Input[str],
                 targetvalue: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: The specific operator to use on the path.
        :param pulumi.Input[str] xpath: The xpath to assert.
        :param pulumi.Input[str] targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "xpath", xpath)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def xpath(self) -> pulumi.Input[str]:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @xpath.setter
    def xpath(self, value: pulumi.Input[str]):
        pulumi.set(self, "xpath", value)

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[pulumi.Input[str]]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")

    @targetvalue.setter
    def targetvalue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "targetvalue", value)


@pulumi.input_type
class SyntheticsTestApiStepExtractedValueArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parser: pulumi.Input['SyntheticsTestApiStepExtractedValueParserArgs'],
                 type: pulumi.Input[str],
                 field: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Property of the Synthetics Test Response to use for the variable. Valid values are `http_body`, `http_header`, `local_variable`.
        :param pulumi.Input[str] field: When type is `http_header`, name of the header to use to extract the value.
        :param pulumi.Input[bool] secure: Determines whether or not the extracted value will be obfuscated.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parser", parser)
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parser(self) -> pulumi.Input['SyntheticsTestApiStepExtractedValueParserArgs']:
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: pulumi.Input['SyntheticsTestApiStepExtractedValueParserArgs']):
        pulumi.set(self, "parser", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Property of the Synthetics Test Response to use for the variable. Valid values are `http_body`, `http_header`, `local_variable`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        When type is `http_header`, name of the header to use to extract the value.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the extracted value will be obfuscated.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)


@pulumi.input_type
class SyntheticsTestApiStepExtractedValueParserArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of parser for a Synthetics global variable from a synthetics test. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        :param pulumi.Input[str] value: Regex or JSON path used for the parser. Not used with type `raw`.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of parser for a Synthetics global variable from a synthetics test. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestBasicauthArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 access_token_url: Optional[pulumi.Input[str]] = None,
                 audience: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 token_api_authentication: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 workstation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: Access key for `SIGV4` authentication.
        :param pulumi.Input[str] access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] audience: Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] domain: Domain for `ntlm` authentication.
        :param pulumi.Input[str] password: Password for authentication.
        :param pulumi.Input[str] region: Region for `SIGV4` authentication.
        :param pulumi.Input[str] resource: Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] scope: Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] secret_key: Secret key for `SIGV4` authentication.
        :param pulumi.Input[str] service_name: Service name for `SIGV4` authentication.
        :param pulumi.Input[str] session_token: Session token for `SIGV4` authentication.
        :param pulumi.Input[str] token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param pulumi.Input[str] type: Type of basic authentication to use when performing the test. Defaults to `"web"`.
        :param pulumi.Input[str] username: Username for authentication.
        :param pulumi.Input[str] workstation: Workstation for `ntlm` authentication.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_token_url is not None:
            pulumi.set(__self__, "access_token_url", access_token_url)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if token_api_authentication is not None:
            pulumi.set(__self__, "token_api_authentication", token_api_authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if workstation is not None:
            pulumi.set(__self__, "workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[pulumi.Input[str]]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @access_token_url.setter
    def access_token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_url", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[pulumi.Input[str]]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @token_api_authentication.setter
    def token_api_authentication(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_api_authentication", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of basic authentication to use when performing the test. Defaults to `"web"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def workstation(self) -> Optional[pulumi.Input[str]]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")

    @workstation.setter
    def workstation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workstation", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestClientCertificateArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input['SyntheticsTestApiStepRequestClientCertificateCertArgs'],
                 key: pulumi.Input['SyntheticsTestApiStepRequestClientCertificateKeyArgs']):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> pulumi.Input['SyntheticsTestApiStepRequestClientCertificateCertArgs']:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input['SyntheticsTestApiStepRequestClientCertificateCertArgs']):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input['SyntheticsTestApiStepRequestClientCertificateKeyArgs']:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['SyntheticsTestApiStepRequestClientCertificateKeyArgs']):
        pulumi.set(self, "key", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestClientCertificateCertArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 filename: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the certificate.
        :param pulumi.Input[str] filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestClientCertificateKeyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 filename: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the certificate.
        :param pulumi.Input[str] filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestDefinitionArgs:
    def __init__(__self__, *,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 body_type: Optional[pulumi.Input[str]] = None,
                 call_type: Optional[pulumi.Input[str]] = None,
                 certificate_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_server: Optional[pulumi.Input[str]] = None,
                 dns_server_port: Optional[pulumi.Input[int]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 http_version: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 no_saving_response_body: Optional[pulumi.Input[bool]] = None,
                 number_of_packets: Optional[pulumi.Input[int]] = None,
                 persist_cookies: Optional[pulumi.Input[bool]] = None,
                 plain_proto_file: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 proto_json_descriptor: Optional[pulumi.Input[str]] = None,
                 servername: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 should_track_hops: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_insecure: Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        :param pulumi.Input[str] body: The request body.
        :param pulumi.Input[str] body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        :param pulumi.Input[str] call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param pulumi.Input[str] dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param pulumi.Input[int] dns_server_port: DNS server port to use for DNS tests.
        :param pulumi.Input[bool] follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param pulumi.Input[str] host: Host name to perform the test with.
        :param pulumi.Input[str] http_version: HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        :param pulumi.Input[str] message: For UDP and websocket tests, message to send with the request.
        :param pulumi.Input[str] method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param pulumi.Input[bool] no_saving_response_body: Determines whether or not to save the response body.
        :param pulumi.Input[int] number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param pulumi.Input[bool] persist_cookies: Persist cookies across redirects.
        :param pulumi.Input[str] plain_proto_file: The content of a proto file as a string.
        :param pulumi.Input[int] port: Port to use when performing the test.
        :param pulumi.Input[str] proto_json_descriptor: A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        :param pulumi.Input[str] servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param pulumi.Input[str] service: The gRPC service on which you want to perform the gRPC call.
        :param pulumi.Input[bool] should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param pulumi.Input[int] timeout: Timeout in seconds for the test. Defaults to `60`.
        :param pulumi.Input[str] url: The URL to send the request to.
        """
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if call_type is not None:
            pulumi.set(__self__, "call_type", call_type)
        if certificate_domains is not None:
            pulumi.set(__self__, "certificate_domains", certificate_domains)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_server_port is not None:
            pulumi.set(__self__, "dns_server_port", dns_server_port)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            pulumi.set(__self__, "number_of_packets", number_of_packets)
        if persist_cookies is not None:
            pulumi.set(__self__, "persist_cookies", persist_cookies)
        if plain_proto_file is not None:
            pulumi.set(__self__, "plain_proto_file", plain_proto_file)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proto_json_descriptor is not None:
            warnings.warn("""Use `plain_proto_file` instead.""", DeprecationWarning)
            pulumi.log.warn("""proto_json_descriptor is deprecated: Use `plain_proto_file` instead.""")
        if proto_json_descriptor is not None:
            pulumi.set(__self__, "proto_json_descriptor", proto_json_descriptor)
        if servername is not None:
            pulumi.set(__self__, "servername", servername)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if should_track_hops is not None:
            pulumi.set(__self__, "should_track_hops", should_track_hops)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        """
        return pulumi.get(self, "body_type")

    @body_type.setter
    def body_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_type", value)

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @call_type.setter
    def call_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "call_type", value)

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @certificate_domains.setter
    def certificate_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate_domains", value)

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[pulumi.Input[str]]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_server", value)

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[pulumi.Input[int]]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @dns_server_port.setter
    def dns_server_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dns_server_port", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_version", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @no_saving_response_body.setter
    def no_saving_response_body(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_saving_response_body", value)

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @number_of_packets.setter
    def number_of_packets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_packets", value)

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[pulumi.Input[bool]]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @persist_cookies.setter
    def persist_cookies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "persist_cookies", value)

    @property
    @pulumi.getter(name="plainProtoFile")
    def plain_proto_file(self) -> Optional[pulumi.Input[str]]:
        """
        The content of a proto file as a string.
        """
        return pulumi.get(self, "plain_proto_file")

    @plain_proto_file.setter
    def plain_proto_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plain_proto_file", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="protoJsonDescriptor")
    @_utilities.deprecated("""Use `plain_proto_file` instead.""")
    def proto_json_descriptor(self) -> Optional[pulumi.Input[str]]:
        """
        A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        """
        return pulumi.get(self, "proto_json_descriptor")

    @proto_json_descriptor.setter
    def proto_json_descriptor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proto_json_descriptor", value)

    @property
    @pulumi.getter
    def servername(self) -> Optional[pulumi.Input[str]]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @servername.setter
    def servername(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "servername", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[pulumi.Input[bool]]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @should_track_hops.setter
    def should_track_hops(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_track_hops", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout in seconds for the test. Defaults to `60`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SyntheticsTestApiStepRequestProxyArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 headers: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] url: URL of the proxy to perform the test.
        :param pulumi.Input[Mapping[str, Any]] headers: Header name and value map.
        """
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class SyntheticsTestApiStepRetryArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
        :param pulumi.Input[int] interval: Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class SyntheticsTestAssertionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 type: pulumi.Input[str],
                 property: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 targetjsonpath: Optional[pulumi.Input['SyntheticsTestAssertionTargetjsonpathArgs']] = None,
                 targetxpath: Optional[pulumi.Input['SyntheticsTestAssertionTargetxpathArgs']] = None,
                 timings_scope: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param pulumi.Input[str] type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param pulumi.Input[str] property: If assertion type is `header`, this is the header name.
        :param pulumi.Input[str] target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param pulumi.Input['SyntheticsTestAssertionTargetjsonpathArgs'] targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input['SyntheticsTestAssertionTargetxpathArgs'] targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        :param pulumi.Input[str] timings_scope: Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if targetjsonpath is not None:
            pulumi.set(__self__, "targetjsonpath", targetjsonpath)
        if targetxpath is not None:
            pulumi.set(__self__, "targetxpath", targetxpath)
        if timings_scope is not None:
            pulumi.set(__self__, "timings_scope", timings_scope)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional[pulumi.Input['SyntheticsTestAssertionTargetjsonpathArgs']]:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @targetjsonpath.setter
    def targetjsonpath(self, value: Optional[pulumi.Input['SyntheticsTestAssertionTargetjsonpathArgs']]):
        pulumi.set(self, "targetjsonpath", value)

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional[pulumi.Input['SyntheticsTestAssertionTargetxpathArgs']]:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @targetxpath.setter
    def targetxpath(self, value: Optional[pulumi.Input['SyntheticsTestAssertionTargetxpathArgs']]):
        pulumi.set(self, "targetxpath", value)

    @property
    @pulumi.getter(name="timingsScope")
    def timings_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        return pulumi.get(self, "timings_scope")

    @timings_scope.setter
    def timings_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timings_scope", value)

    @property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[str]]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property", value)


@pulumi.input_type
class SyntheticsTestAssertionTargetjsonpathArgs:
    def __init__(__self__, *,
                 jsonpath: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 targetvalue: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] jsonpath: The JSON path to assert.
        :param pulumi.Input[str] operator: The specific operator to use on the path.
        :param pulumi.Input[str] targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "jsonpath", jsonpath)
        pulumi.set(__self__, "operator", operator)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> pulumi.Input[str]:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @jsonpath.setter
    def jsonpath(self, value: pulumi.Input[str]):
        pulumi.set(self, "jsonpath", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[pulumi.Input[str]]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")

    @targetvalue.setter
    def targetvalue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "targetvalue", value)


@pulumi.input_type
class SyntheticsTestAssertionTargetxpathArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 xpath: pulumi.Input[str],
                 targetvalue: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: The specific operator to use on the path.
        :param pulumi.Input[str] xpath: The xpath to assert.
        :param pulumi.Input[str] targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "xpath", xpath)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def xpath(self) -> pulumi.Input[str]:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @xpath.setter
    def xpath(self, value: pulumi.Input[str]):
        pulumi.set(self, "xpath", value)

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[pulumi.Input[str]]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")

    @targetvalue.setter
    def targetvalue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "targetvalue", value)


@pulumi.input_type
class SyntheticsTestBrowserStepArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 params: pulumi.Input['SyntheticsTestBrowserStepParamsArgs'],
                 type: pulumi.Input[str],
                 allow_failure: Optional[pulumi.Input[bool]] = None,
                 force_element_update: Optional[pulumi.Input[bool]] = None,
                 is_critical: Optional[pulumi.Input[bool]] = None,
                 no_screenshot: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Name of the step.
        :param pulumi.Input['SyntheticsTestBrowserStepParamsArgs'] params: Parameters for the step.
        :param pulumi.Input[str] type: Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        :param pulumi.Input[bool] allow_failure: Determines if the step should be allowed to fail.
        :param pulumi.Input[bool] force_element_update: Force update of the "element" parameter for the step
        :param pulumi.Input[bool] is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param pulumi.Input[bool] no_screenshot: Prevents saving screenshots of the step.
        :param pulumi.Input[int] timeout: Used to override the default timeout of a step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if force_element_update is not None:
            pulumi.set(__self__, "force_element_update", force_element_update)
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def params(self) -> pulumi.Input['SyntheticsTestBrowserStepParamsArgs']:
        """
        Parameters for the step.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: pulumi.Input['SyntheticsTestBrowserStepParamsArgs']):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the step should be allowed to fail.
        """
        return pulumi.get(self, "allow_failure")

    @allow_failure.setter
    def allow_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_failure", value)

    @property
    @pulumi.getter(name="forceElementUpdate")
    def force_element_update(self) -> Optional[pulumi.Input[bool]]:
        """
        Force update of the "element" parameter for the step
        """
        return pulumi.get(self, "force_element_update")

    @force_element_update.setter
    def force_element_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_element_update", value)

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @is_critical.setter
    def is_critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_critical", value)

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevents saving screenshots of the step.
        """
        return pulumi.get(self, "no_screenshot")

    @no_screenshot.setter
    def no_screenshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_screenshot", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Used to override the default timeout of a step.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class SyntheticsTestBrowserStepParamsArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[str]] = None,
                 check: Optional[pulumi.Input[str]] = None,
                 click_type: Optional[pulumi.Input[str]] = None,
                 code: Optional[pulumi.Input[str]] = None,
                 delay: Optional[pulumi.Input[int]] = None,
                 element: Optional[pulumi.Input[str]] = None,
                 element_user_locator: Optional[pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorArgs']] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 file: Optional[pulumi.Input[str]] = None,
                 files: Optional[pulumi.Input[str]] = None,
                 modifiers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 playing_tab_id: Optional[pulumi.Input[str]] = None,
                 request: Optional[pulumi.Input[str]] = None,
                 subtest_public_id: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 variable: Optional[pulumi.Input['SyntheticsTestBrowserStepParamsVariableArgs']] = None,
                 with_click: Optional[pulumi.Input[bool]] = None,
                 x: Optional[pulumi.Input[int]] = None,
                 y: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] attribute: Name of the attribute to use for an "assert attribute" step.
        :param pulumi.Input[str] check: Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        :param pulumi.Input[str] click_type: Type of click to use for a "click" step.
        :param pulumi.Input[str] code: Javascript code to use for the step.
        :param pulumi.Input[int] delay: Delay between each key stroke for a "type test" step.
        :param pulumi.Input[str] element: Element to use for the step, json encoded string.
        :param pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorArgs'] element_user_locator: Custom user selector to use for the step.
        :param pulumi.Input[str] email: Details of the email for an "assert email" step.
        :param pulumi.Input[str] file: JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
        :param pulumi.Input[str] files: Details of the files for an "upload files" step, json encoded string.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] modifiers: Modifier to use for a "press key" step.
        :param pulumi.Input[str] playing_tab_id: ID of the tab to play the subtest.
        :param pulumi.Input[str] request: Request for an API step.
        :param pulumi.Input[str] subtest_public_id: ID of the Synthetics test to use as subtest.
        :param pulumi.Input[str] value: Value of the step.
        :param pulumi.Input['SyntheticsTestBrowserStepParamsVariableArgs'] variable: Details of the variable to extract.
        :param pulumi.Input[bool] with_click: For "file upload" steps.
        :param pulumi.Input[int] x: X coordinates for a "scroll step".
        :param pulumi.Input[int] y: Y coordinates for a "scroll step".
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if click_type is not None:
            pulumi.set(__self__, "click_type", click_type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if element is not None:
            pulumi.set(__self__, "element", element)
        if element_user_locator is not None:
            pulumi.set(__self__, "element_user_locator", element_user_locator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if playing_tab_id is not None:
            pulumi.set(__self__, "playing_tab_id", playing_tab_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if subtest_public_id is not None:
            pulumi.set(__self__, "subtest_public_id", subtest_public_id)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)
        if with_click is not None:
            pulumi.set(__self__, "with_click", with_click)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the attribute to use for an "assert attribute" step.
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def check(self) -> Optional[pulumi.Input[str]]:
        """
        Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        """
        return pulumi.get(self, "check")

    @check.setter
    def check(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "check", value)

    @property
    @pulumi.getter(name="clickType")
    def click_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of click to use for a "click" step.
        """
        return pulumi.get(self, "click_type")

    @click_type.setter
    def click_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "click_type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        Javascript code to use for the step.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[int]]:
        """
        Delay between each key stroke for a "type test" step.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay", value)

    @property
    @pulumi.getter
    def element(self) -> Optional[pulumi.Input[str]]:
        """
        Element to use for the step, json encoded string.
        """
        return pulumi.get(self, "element")

    @element.setter
    def element(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "element", value)

    @property
    @pulumi.getter(name="elementUserLocator")
    def element_user_locator(self) -> Optional[pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorArgs']]:
        """
        Custom user selector to use for the step.
        """
        return pulumi.get(self, "element_user_locator")

    @element_user_locator.setter
    def element_user_locator(self, value: Optional[pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorArgs']]):
        pulumi.set(self, "element_user_locator", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Details of the email for an "assert email" step.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input[str]]:
        """
        JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[str]]:
        """
        Details of the files for an "upload files" step, json encoded string.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "files", value)

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Modifier to use for a "press key" step.
        """
        return pulumi.get(self, "modifiers")

    @modifiers.setter
    def modifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "modifiers", value)

    @property
    @pulumi.getter(name="playingTabId")
    def playing_tab_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the tab to play the subtest.
        """
        return pulumi.get(self, "playing_tab_id")

    @playing_tab_id.setter
    def playing_tab_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "playing_tab_id", value)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input[str]]:
        """
        Request for an API step.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter(name="subtestPublicId")
    def subtest_public_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Synthetics test to use as subtest.
        """
        return pulumi.get(self, "subtest_public_id")

    @subtest_public_id.setter
    def subtest_public_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subtest_public_id", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the step.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def variable(self) -> Optional[pulumi.Input['SyntheticsTestBrowserStepParamsVariableArgs']]:
        """
        Details of the variable to extract.
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: Optional[pulumi.Input['SyntheticsTestBrowserStepParamsVariableArgs']]):
        pulumi.set(self, "variable", value)

    @property
    @pulumi.getter(name="withClick")
    def with_click(self) -> Optional[pulumi.Input[bool]]:
        """
        For "file upload" steps.
        """
        return pulumi.get(self, "with_click")

    @with_click.setter
    def with_click(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "with_click", value)

    @property
    @pulumi.getter
    def x(self) -> Optional[pulumi.Input[int]]:
        """
        X coordinates for a "scroll step".
        """
        return pulumi.get(self, "x")

    @x.setter
    def x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x", value)

    @property
    @pulumi.getter
    def y(self) -> Optional[pulumi.Input[int]]:
        """
        Y coordinates for a "scroll step".
        """
        return pulumi.get(self, "y")

    @y.setter
    def y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "y", value)


@pulumi.input_type
class SyntheticsTestBrowserStepParamsElementUserLocatorArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs'],
                 fail_test_on_cannot_locate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] fail_test_on_cannot_locate: Defaults to `false`.
        """
        pulumi.set(__self__, "value", value)
        if fail_test_on_cannot_locate is not None:
            pulumi.set(__self__, "fail_test_on_cannot_locate", fail_test_on_cannot_locate)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="failTestOnCannotLocate")
    def fail_test_on_cannot_locate(self) -> Optional[pulumi.Input[bool]]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "fail_test_on_cannot_locate")

    @fail_test_on_cannot_locate.setter
    def fail_test_on_cannot_locate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_test_on_cannot_locate", value)


@pulumi.input_type
class SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Defaults to `"css"`.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Defaults to `"css"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SyntheticsTestBrowserStepParamsVariableArgs:
    def __init__(__self__, *,
                 example: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] example: Example of the extracted variable. Defaults to `""`.
        :param pulumi.Input[str] name: Name of the extracted variable.
        """
        if example is not None:
            pulumi.set(__self__, "example", example)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[str]]:
        """
        Example of the extracted variable. Defaults to `""`.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the extracted variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SyntheticsTestBrowserVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 example: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Name of the variable.
        :param pulumi.Input[str] type: Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        :param pulumi.Input[str] example: Example for the variable. Defaults to `""`.
        :param pulumi.Input[str] id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        :param pulumi.Input[str] pattern: Pattern of the variable. Defaults to `""`.
        :param pulumi.Input[bool] secure: Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[str]]:
        """
        Example for the variable. Defaults to `""`.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern of the variable. Defaults to `""`.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)


@pulumi.input_type
class SyntheticsTestConfigVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 example: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Name of the variable.
        :param pulumi.Input[str] type: Type of test configuration variable. Valid values are `global`, `text`.
        :param pulumi.Input[str] id: When type = `global`, ID of the global variable to use.
        :param pulumi.Input[bool] secure: Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of test configuration variable. Valid values are `global`, `text`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        When type = `global`, ID of the global variable to use.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)


@pulumi.input_type
class SyntheticsTestOptionsListArgs:
    def __init__(__self__, *,
                 tick_every: pulumi.Input[int],
                 accept_self_signed: Optional[pulumi.Input[bool]] = None,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 check_certificate_revocation: Optional[pulumi.Input[bool]] = None,
                 ci: Optional[pulumi.Input['SyntheticsTestOptionsListCiArgs']] = None,
                 disable_cors: Optional[pulumi.Input[bool]] = None,
                 disable_csp: Optional[pulumi.Input[bool]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 http_version: Optional[pulumi.Input[str]] = None,
                 ignore_server_certificate_error: Optional[pulumi.Input[bool]] = None,
                 initial_navigation_timeout: Optional[pulumi.Input[int]] = None,
                 min_failure_duration: Optional[pulumi.Input[int]] = None,
                 min_location_failed: Optional[pulumi.Input[int]] = None,
                 monitor_name: Optional[pulumi.Input[str]] = None,
                 monitor_options: Optional[pulumi.Input['SyntheticsTestOptionsListMonitorOptionsArgs']] = None,
                 monitor_priority: Optional[pulumi.Input[int]] = None,
                 no_screenshot: Optional[pulumi.Input[bool]] = None,
                 restricted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 retry: Optional[pulumi.Input['SyntheticsTestOptionsListRetryArgs']] = None,
                 rum_settings: Optional[pulumi.Input['SyntheticsTestOptionsListRumSettingsArgs']] = None,
                 scheduling: Optional[pulumi.Input['SyntheticsTestOptionsListSchedulingArgs']] = None):
        """
        :param pulumi.Input[int] tick_every: How often the test should run (in seconds).
        :param pulumi.Input[bool] accept_self_signed: For SSL test, whether or not the test should allow self signed certificates.
        :param pulumi.Input[bool] allow_insecure: Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        :param pulumi.Input[bool] check_certificate_revocation: For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        :param pulumi.Input['SyntheticsTestOptionsListCiArgs'] ci: CI/CD options for a Synthetic test.
        :param pulumi.Input[bool] disable_cors: Disable Cross-Origin Resource Sharing for browser tests.
        :param pulumi.Input[bool] disable_csp: Disable Content Security Policy for browser tests.
        :param pulumi.Input[bool] follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param pulumi.Input[str] http_version: HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        :param pulumi.Input[bool] ignore_server_certificate_error: Ignore server certificate error for browser tests.
        :param pulumi.Input[int] initial_navigation_timeout: Timeout before declaring the initial step as failed (in seconds) for browser tests.
        :param pulumi.Input[int] min_failure_duration: Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        :param pulumi.Input[int] min_location_failed: Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
        :param pulumi.Input[str] monitor_name: The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        :param pulumi.Input[bool] no_screenshot: Prevents saving screenshots of the steps.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        :param pulumi.Input['SyntheticsTestOptionsListRumSettingsArgs'] rum_settings: The RUM data collection settings for the Synthetic browser test.
        :param pulumi.Input['SyntheticsTestOptionsListSchedulingArgs'] scheduling: Object containing timeframes and timezone used for advanced scheduling.
        """
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if check_certificate_revocation is not None:
            pulumi.set(__self__, "check_certificate_revocation", check_certificate_revocation)
        if ci is not None:
            pulumi.set(__self__, "ci", ci)
        if disable_cors is not None:
            pulumi.set(__self__, "disable_cors", disable_cors)
        if disable_csp is not None:
            pulumi.set(__self__, "disable_csp", disable_csp)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if ignore_server_certificate_error is not None:
            pulumi.set(__self__, "ignore_server_certificate_error", ignore_server_certificate_error)
        if initial_navigation_timeout is not None:
            pulumi.set(__self__, "initial_navigation_timeout", initial_navigation_timeout)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)
        if monitor_name is not None:
            pulumi.set(__self__, "monitor_name", monitor_name)
        if monitor_options is not None:
            pulumi.set(__self__, "monitor_options", monitor_options)
        if monitor_priority is not None:
            pulumi.set(__self__, "monitor_priority", monitor_priority)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if restricted_roles is not None:
            pulumi.set(__self__, "restricted_roles", restricted_roles)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if rum_settings is not None:
            pulumi.set(__self__, "rum_settings", rum_settings)
        if scheduling is not None:
            pulumi.set(__self__, "scheduling", scheduling)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> pulumi.Input[int]:
        """
        How often the test should run (in seconds).
        """
        return pulumi.get(self, "tick_every")

    @tick_every.setter
    def tick_every(self, value: pulumi.Input[int]):
        pulumi.set(self, "tick_every", value)

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[pulumi.Input[bool]]:
        """
        For SSL test, whether or not the test should allow self signed certificates.
        """
        return pulumi.get(self, "accept_self_signed")

    @accept_self_signed.setter
    def accept_self_signed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_self_signed", value)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter(name="checkCertificateRevocation")
    def check_certificate_revocation(self) -> Optional[pulumi.Input[bool]]:
        """
        For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        """
        return pulumi.get(self, "check_certificate_revocation")

    @check_certificate_revocation.setter
    def check_certificate_revocation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_certificate_revocation", value)

    @property
    @pulumi.getter
    def ci(self) -> Optional[pulumi.Input['SyntheticsTestOptionsListCiArgs']]:
        """
        CI/CD options for a Synthetic test.
        """
        return pulumi.get(self, "ci")

    @ci.setter
    def ci(self, value: Optional[pulumi.Input['SyntheticsTestOptionsListCiArgs']]):
        pulumi.set(self, "ci", value)

    @property
    @pulumi.getter(name="disableCors")
    def disable_cors(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Cross-Origin Resource Sharing for browser tests.
        """
        return pulumi.get(self, "disable_cors")

    @disable_cors.setter
    def disable_cors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_cors", value)

    @property
    @pulumi.getter(name="disableCsp")
    def disable_csp(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Content Security Policy for browser tests.
        """
        return pulumi.get(self, "disable_csp")

    @disable_csp.setter
    def disable_csp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_csp", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_version", value)

    @property
    @pulumi.getter(name="ignoreServerCertificateError")
    def ignore_server_certificate_error(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore server certificate error for browser tests.
        """
        return pulumi.get(self, "ignore_server_certificate_error")

    @ignore_server_certificate_error.setter
    def ignore_server_certificate_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_server_certificate_error", value)

    @property
    @pulumi.getter(name="initialNavigationTimeout")
    def initial_navigation_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout before declaring the initial step as failed (in seconds) for browser tests.
        """
        return pulumi.get(self, "initial_navigation_timeout")

    @initial_navigation_timeout.setter
    def initial_navigation_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_navigation_timeout", value)

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        """
        return pulumi.get(self, "min_failure_duration")

    @min_failure_duration.setter
    def min_failure_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_failure_duration", value)

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
        """
        return pulumi.get(self, "min_location_failed")

    @min_location_failed.setter
    def min_location_failed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_location_failed", value)

    @property
    @pulumi.getter(name="monitorName")
    def monitor_name(self) -> Optional[pulumi.Input[str]]:
        """
        The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        """
        return pulumi.get(self, "monitor_name")

    @monitor_name.setter
    def monitor_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor_name", value)

    @property
    @pulumi.getter(name="monitorOptions")
    def monitor_options(self) -> Optional[pulumi.Input['SyntheticsTestOptionsListMonitorOptionsArgs']]:
        return pulumi.get(self, "monitor_options")

    @monitor_options.setter
    def monitor_options(self, value: Optional[pulumi.Input['SyntheticsTestOptionsListMonitorOptionsArgs']]):
        pulumi.set(self, "monitor_options", value)

    @property
    @pulumi.getter(name="monitorPriority")
    def monitor_priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monitor_priority")

    @monitor_priority.setter
    def monitor_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_priority", value)

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevents saving screenshots of the steps.
        """
        return pulumi.get(self, "no_screenshot")

    @no_screenshot.setter
    def no_screenshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_screenshot", value)

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")

    @restricted_roles.setter
    def restricted_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "restricted_roles", value)

    @property
    @pulumi.getter
    def retry(self) -> Optional[pulumi.Input['SyntheticsTestOptionsListRetryArgs']]:
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: Optional[pulumi.Input['SyntheticsTestOptionsListRetryArgs']]):
        pulumi.set(self, "retry", value)

    @property
    @pulumi.getter(name="rumSettings")
    def rum_settings(self) -> Optional[pulumi.Input['SyntheticsTestOptionsListRumSettingsArgs']]:
        """
        The RUM data collection settings for the Synthetic browser test.
        """
        return pulumi.get(self, "rum_settings")

    @rum_settings.setter
    def rum_settings(self, value: Optional[pulumi.Input['SyntheticsTestOptionsListRumSettingsArgs']]):
        pulumi.set(self, "rum_settings", value)

    @property
    @pulumi.getter
    def scheduling(self) -> Optional[pulumi.Input['SyntheticsTestOptionsListSchedulingArgs']]:
        """
        Object containing timeframes and timezone used for advanced scheduling.
        """
        return pulumi.get(self, "scheduling")

    @scheduling.setter
    def scheduling(self, value: Optional[pulumi.Input['SyntheticsTestOptionsListSchedulingArgs']]):
        pulumi.set(self, "scheduling", value)


@pulumi.input_type
class SyntheticsTestOptionsListCiArgs:
    def __init__(__self__, *,
                 execution_rule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] execution_rule: Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        if execution_rule is not None:
            pulumi.set(__self__, "execution_rule", execution_rule)

    @property
    @pulumi.getter(name="executionRule")
    def execution_rule(self) -> Optional[pulumi.Input[str]]:
        """
        Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        return pulumi.get(self, "execution_rule")

    @execution_rule.setter
    def execution_rule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_rule", value)


@pulumi.input_type
class SyntheticsTestOptionsListMonitorOptionsArgs:
    def __init__(__self__, *,
                 renotify_interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] renotify_interval: Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        if renotify_interval is not None:
            pulumi.set(__self__, "renotify_interval", renotify_interval)

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        return pulumi.get(self, "renotify_interval")

    @renotify_interval.setter
    def renotify_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "renotify_interval", value)


@pulumi.input_type
class SyntheticsTestOptionsListRetryArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
        :param pulumi.Input[int] interval: Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


@pulumi.input_type
class SyntheticsTestOptionsListRumSettingsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 application_id: Optional[pulumi.Input[str]] = None,
                 client_token_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_enabled: Determines whether RUM data is collected during test runs.
        :param pulumi.Input[str] application_id: RUM application ID used to collect RUM data for the browser test.
        :param pulumi.Input[int] client_token_id: RUM application API key ID used to collect RUM data for the browser test.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if client_token_id is not None:
            pulumi.set(__self__, "client_token_id", client_token_id)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether RUM data is collected during test runs.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[str]]:
        """
        RUM application ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientTokenId")
    def client_token_id(self) -> Optional[pulumi.Input[int]]:
        """
        RUM application API key ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "client_token_id")

    @client_token_id.setter
    def client_token_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_token_id", value)


@pulumi.input_type
class SyntheticsTestOptionsListSchedulingArgs:
    def __init__(__self__, *,
                 timeframes: pulumi.Input[Sequence[pulumi.Input['SyntheticsTestOptionsListSchedulingTimeframeArgs']]],
                 timezone: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SyntheticsTestOptionsListSchedulingTimeframeArgs']]] timeframes: Array containing objects describing the scheduling pattern to apply to each day.
        :param pulumi.Input[str] timezone: Timezone in which the timeframe is based.
        """
        pulumi.set(__self__, "timeframes", timeframes)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def timeframes(self) -> pulumi.Input[Sequence[pulumi.Input['SyntheticsTestOptionsListSchedulingTimeframeArgs']]]:
        """
        Array containing objects describing the scheduling pattern to apply to each day.
        """
        return pulumi.get(self, "timeframes")

    @timeframes.setter
    def timeframes(self, value: pulumi.Input[Sequence[pulumi.Input['SyntheticsTestOptionsListSchedulingTimeframeArgs']]]):
        pulumi.set(self, "timeframes", value)

    @property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[str]:
        """
        Timezone in which the timeframe is based.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone", value)


@pulumi.input_type
class SyntheticsTestOptionsListSchedulingTimeframeArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[int],
                 from_: pulumi.Input[str],
                 to: pulumi.Input[str]):
        """
        :param pulumi.Input[int] day: Number representing the day of the week
        :param pulumi.Input[str] from_: The hour of the day on which scheduling starts.
        :param pulumi.Input[str] to: The hour of the day on which scheduling ends.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[int]:
        """
        Number representing the day of the week
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[int]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The hour of the day on which scheduling starts.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[str]:
        """
        The hour of the day on which scheduling ends.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[str]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class SyntheticsTestRequestBasicauthArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 access_token_url: Optional[pulumi.Input[str]] = None,
                 audience: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 token_api_authentication: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 workstation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: Access key for `SIGV4` authentication.
        :param pulumi.Input[str] access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] audience: Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param pulumi.Input[str] domain: Domain for `ntlm` authentication.
        :param pulumi.Input[str] password: Password for authentication.
        :param pulumi.Input[str] region: Region for `SIGV4` authentication.
        :param pulumi.Input[str] resource: Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] scope: Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param pulumi.Input[str] secret_key: Secret key for `SIGV4` authentication.
        :param pulumi.Input[str] service_name: Service name for `SIGV4` authentication.
        :param pulumi.Input[str] session_token: Session token for `SIGV4` authentication.
        :param pulumi.Input[str] token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param pulumi.Input[str] type: Type of basic authentication to use when performing the test. Defaults to `"web"`.
        :param pulumi.Input[str] username: Username for authentication.
        :param pulumi.Input[str] workstation: Workstation for `ntlm` authentication.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_token_url is not None:
            pulumi.set(__self__, "access_token_url", access_token_url)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if token_api_authentication is not None:
            pulumi.set(__self__, "token_api_authentication", token_api_authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if workstation is not None:
            pulumi.set(__self__, "workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[pulumi.Input[str]]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @access_token_url.setter
    def access_token_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_url", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[str]]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[pulumi.Input[str]]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @token_api_authentication.setter
    def token_api_authentication(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_api_authentication", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of basic authentication to use when performing the test. Defaults to `"web"`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def workstation(self) -> Optional[pulumi.Input[str]]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")

    @workstation.setter
    def workstation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workstation", value)


@pulumi.input_type
class SyntheticsTestRequestClientCertificateArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input['SyntheticsTestRequestClientCertificateCertArgs'],
                 key: pulumi.Input['SyntheticsTestRequestClientCertificateKeyArgs']):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> pulumi.Input['SyntheticsTestRequestClientCertificateCertArgs']:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input['SyntheticsTestRequestClientCertificateCertArgs']):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input['SyntheticsTestRequestClientCertificateKeyArgs']:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['SyntheticsTestRequestClientCertificateKeyArgs']):
        pulumi.set(self, "key", value)


@pulumi.input_type
class SyntheticsTestRequestClientCertificateCertArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 filename: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the certificate.
        :param pulumi.Input[str] filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)


@pulumi.input_type
class SyntheticsTestRequestClientCertificateKeyArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 filename: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Content of the certificate.
        :param pulumi.Input[str] filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[str]]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filename", value)


@pulumi.input_type
class SyntheticsTestRequestDefinitionArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[str]] = None,
                 body_type: Optional[pulumi.Input[str]] = None,
                 call_type: Optional[pulumi.Input[str]] = None,
                 certificate_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_server: Optional[pulumi.Input[str]] = None,
                 dns_server_port: Optional[pulumi.Input[int]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 http_version: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 no_saving_response_body: Optional[pulumi.Input[bool]] = None,
                 number_of_packets: Optional[pulumi.Input[int]] = None,
                 persist_cookies: Optional[pulumi.Input[bool]] = None,
                 plain_proto_file: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 proto_json_descriptor: Optional[pulumi.Input[str]] = None,
                 servername: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 should_track_hops: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body: The request body.
        :param pulumi.Input[str] body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        :param pulumi.Input[str] call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param pulumi.Input[str] dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param pulumi.Input[int] dns_server_port: DNS server port to use for DNS tests.
        :param pulumi.Input[str] host: Host name to perform the test with.
        :param pulumi.Input[str] http_version: HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        :param pulumi.Input[str] message: For UDP and websocket tests, message to send with the request.
        :param pulumi.Input[str] method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param pulumi.Input[bool] no_saving_response_body: Determines whether or not to save the response body.
        :param pulumi.Input[int] number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param pulumi.Input[bool] persist_cookies: Persist cookies across redirects.
        :param pulumi.Input[str] plain_proto_file: The content of a proto file as a string.
        :param pulumi.Input[int] port: Port to use when performing the test.
        :param pulumi.Input[str] proto_json_descriptor: A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        :param pulumi.Input[str] servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param pulumi.Input[str] service: The gRPC service on which you want to perform the gRPC call.
        :param pulumi.Input[bool] should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param pulumi.Input[int] timeout: Timeout in seconds for the test. Defaults to `60`.
        :param pulumi.Input[str] url: The URL to send the request to.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if call_type is not None:
            pulumi.set(__self__, "call_type", call_type)
        if certificate_domains is not None:
            pulumi.set(__self__, "certificate_domains", certificate_domains)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_server_port is not None:
            pulumi.set(__self__, "dns_server_port", dns_server_port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            pulumi.set(__self__, "number_of_packets", number_of_packets)
        if persist_cookies is not None:
            pulumi.set(__self__, "persist_cookies", persist_cookies)
        if plain_proto_file is not None:
            pulumi.set(__self__, "plain_proto_file", plain_proto_file)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proto_json_descriptor is not None:
            warnings.warn("""Use `plain_proto_file` instead.""", DeprecationWarning)
            pulumi.log.warn("""proto_json_descriptor is deprecated: Use `plain_proto_file` instead.""")
        if proto_json_descriptor is not None:
            pulumi.set(__self__, "proto_json_descriptor", proto_json_descriptor)
        if servername is not None:
            pulumi.set(__self__, "servername", servername)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if should_track_hops is not None:
            pulumi.set(__self__, "should_track_hops", should_track_hops)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        """
        return pulumi.get(self, "body_type")

    @body_type.setter
    def body_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_type", value)

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @call_type.setter
    def call_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "call_type", value)

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @certificate_domains.setter
    def certificate_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate_domains", value)

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[pulumi.Input[str]]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_server", value)

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[pulumi.Input[int]]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @dns_server_port.setter
    def dns_server_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dns_server_port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_version", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @no_saving_response_body.setter
    def no_saving_response_body(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_saving_response_body", value)

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @number_of_packets.setter
    def number_of_packets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_packets", value)

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[pulumi.Input[bool]]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @persist_cookies.setter
    def persist_cookies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "persist_cookies", value)

    @property
    @pulumi.getter(name="plainProtoFile")
    def plain_proto_file(self) -> Optional[pulumi.Input[str]]:
        """
        The content of a proto file as a string.
        """
        return pulumi.get(self, "plain_proto_file")

    @plain_proto_file.setter
    def plain_proto_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plain_proto_file", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="protoJsonDescriptor")
    @_utilities.deprecated("""Use `plain_proto_file` instead.""")
    def proto_json_descriptor(self) -> Optional[pulumi.Input[str]]:
        """
        A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        """
        return pulumi.get(self, "proto_json_descriptor")

    @proto_json_descriptor.setter
    def proto_json_descriptor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proto_json_descriptor", value)

    @property
    @pulumi.getter
    def servername(self) -> Optional[pulumi.Input[str]]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @servername.setter
    def servername(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "servername", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[pulumi.Input[bool]]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @should_track_hops.setter
    def should_track_hops(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_track_hops", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout in seconds for the test. Defaults to `60`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SyntheticsTestRequestProxyArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 headers: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] url: URL of the proxy to perform the test.
        :param pulumi.Input[Mapping[str, Any]] headers: Header name and value map.
        """
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "headers", value)



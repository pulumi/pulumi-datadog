// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * Provides a Datadog Security Monitoring Suppression API resource. It can be used to create and manage Datadog security monitoring suppression rules.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as datadog from "@pulumi/datadog";
 *
 * const mySuppression = new datadog.SecurityMonitoringSuppression("my_suppression", {
 *     name: "My suppression",
 *     description: "Suppression for low severity CloudTrail signals from John Doe, excluding test environments from analysis, limited to 2024",
 *     enabled: true,
 *     ruleQuery: "severity:low source:cloudtrail",
 *     suppressionQuery: "@usr.id:john.doe",
 *     dataExclusionQuery: "env:test",
 *     startDate: "2024-12-01T16:00:00Z",
 *     expirationDate: "2024-12-31T12:00:00Z",
 * });
 * ```
 *
 * ## Import
 *
 * The `pulumi import` command can be used, for example:
 *
 * Security monitoring suppressions can be imported using ID, for example:
 *
 * ```sh
 * $ pulumi import datadog:index/securityMonitoringSuppression:SecurityMonitoringSuppression my_suppression m0o-hto-lkb
 * ```
 */
export class SecurityMonitoringSuppression extends pulumi.CustomResource {
    /**
     * Get an existing SecurityMonitoringSuppression resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SecurityMonitoringSuppressionState, opts?: pulumi.CustomResourceOptions): SecurityMonitoringSuppression {
        return new SecurityMonitoringSuppression(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'datadog:index/securityMonitoringSuppression:SecurityMonitoringSuppression';

    /**
     * Returns true if the given object is an instance of SecurityMonitoringSuppression.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SecurityMonitoringSuppression {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SecurityMonitoringSuppression.__pulumiType;
    }

    /**
     * An exclusion query on the input data of the security rules, which could be logs, Agent events, or other types of data based on the security rule. Events matching this query are ignored by any detection rules referenced in the suppression rule.
     */
    declare public readonly dataExclusionQuery: pulumi.Output<string | undefined>;
    /**
     * A description for the suppression rule.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Whether the suppression rule is enabled.
     */
    declare public readonly enabled: pulumi.Output<boolean>;
    /**
     * A RFC3339 timestamp giving an expiration date for the suppression rule. After this date, it won't suppress signals anymore.
     */
    declare public readonly expirationDate: pulumi.Output<string | undefined>;
    /**
     * The name of the suppression rule.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The rule query of the suppression rule, with the same syntax as the search bar for detection rules.
     */
    declare public readonly ruleQuery: pulumi.Output<string>;
    /**
     * A RFC3339 timestamp giving a start date for the suppression rule. Before this date, it doesn't suppress signals.
     */
    declare public readonly startDate: pulumi.Output<string | undefined>;
    /**
     * The suppression query of the suppression rule. If a signal matches this query, it is suppressed and is not triggered. It uses the same syntax as the queries to search signals in the Signals Explorer.
     */
    declare public readonly suppressionQuery: pulumi.Output<string | undefined>;

    /**
     * Create a SecurityMonitoringSuppression resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SecurityMonitoringSuppressionArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SecurityMonitoringSuppressionArgs | SecurityMonitoringSuppressionState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SecurityMonitoringSuppressionState | undefined;
            resourceInputs["dataExclusionQuery"] = state?.dataExclusionQuery;
            resourceInputs["description"] = state?.description;
            resourceInputs["enabled"] = state?.enabled;
            resourceInputs["expirationDate"] = state?.expirationDate;
            resourceInputs["name"] = state?.name;
            resourceInputs["ruleQuery"] = state?.ruleQuery;
            resourceInputs["startDate"] = state?.startDate;
            resourceInputs["suppressionQuery"] = state?.suppressionQuery;
        } else {
            const args = argsOrState as SecurityMonitoringSuppressionArgs | undefined;
            if (args?.enabled === undefined && !opts.urn) {
                throw new Error("Missing required property 'enabled'");
            }
            if (args?.name === undefined && !opts.urn) {
                throw new Error("Missing required property 'name'");
            }
            if (args?.ruleQuery === undefined && !opts.urn) {
                throw new Error("Missing required property 'ruleQuery'");
            }
            resourceInputs["dataExclusionQuery"] = args?.dataExclusionQuery;
            resourceInputs["description"] = args?.description;
            resourceInputs["enabled"] = args?.enabled;
            resourceInputs["expirationDate"] = args?.expirationDate;
            resourceInputs["name"] = args?.name;
            resourceInputs["ruleQuery"] = args?.ruleQuery;
            resourceInputs["startDate"] = args?.startDate;
            resourceInputs["suppressionQuery"] = args?.suppressionQuery;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SecurityMonitoringSuppression.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering SecurityMonitoringSuppression resources.
 */
export interface SecurityMonitoringSuppressionState {
    /**
     * An exclusion query on the input data of the security rules, which could be logs, Agent events, or other types of data based on the security rule. Events matching this query are ignored by any detection rules referenced in the suppression rule.
     */
    dataExclusionQuery?: pulumi.Input<string>;
    /**
     * A description for the suppression rule.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether the suppression rule is enabled.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * A RFC3339 timestamp giving an expiration date for the suppression rule. After this date, it won't suppress signals anymore.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * The name of the suppression rule.
     */
    name?: pulumi.Input<string>;
    /**
     * The rule query of the suppression rule, with the same syntax as the search bar for detection rules.
     */
    ruleQuery?: pulumi.Input<string>;
    /**
     * A RFC3339 timestamp giving a start date for the suppression rule. Before this date, it doesn't suppress signals.
     */
    startDate?: pulumi.Input<string>;
    /**
     * The suppression query of the suppression rule. If a signal matches this query, it is suppressed and is not triggered. It uses the same syntax as the queries to search signals in the Signals Explorer.
     */
    suppressionQuery?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a SecurityMonitoringSuppression resource.
 */
export interface SecurityMonitoringSuppressionArgs {
    /**
     * An exclusion query on the input data of the security rules, which could be logs, Agent events, or other types of data based on the security rule. Events matching this query are ignored by any detection rules referenced in the suppression rule.
     */
    dataExclusionQuery?: pulumi.Input<string>;
    /**
     * A description for the suppression rule.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether the suppression rule is enabled.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * A RFC3339 timestamp giving an expiration date for the suppression rule. After this date, it won't suppress signals anymore.
     */
    expirationDate?: pulumi.Input<string>;
    /**
     * The name of the suppression rule.
     */
    name: pulumi.Input<string>;
    /**
     * The rule query of the suppression rule, with the same syntax as the search bar for detection rules.
     */
    ruleQuery: pulumi.Input<string>;
    /**
     * A RFC3339 timestamp giving a start date for the suppression rule. Before this date, it doesn't suppress signals.
     */
    startDate?: pulumi.Input<string>;
    /**
     * The suppression query of the suppression rule. If a signal matches this query, it is suppressed and is not triggered. It uses the same syntax as the queries to search signals in the Signals Explorer.
     */
    suppressionQuery?: pulumi.Input<string>;
}

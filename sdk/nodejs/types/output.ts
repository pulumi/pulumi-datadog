// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApmRetentionFilterFilter {
    /**
     * The search query - following the span search syntax. Defaults to `"*"`.
     */
    query: string;
}

export interface ChildOrganizationApiKey {
    /**
     * API key.
     */
    key: string;
    /**
     * Name of your API key.
     */
    name: string;
}

export interface ChildOrganizationApplicationKey {
    /**
     * Hash of an application key.
     */
    hash: string;
    /**
     * Name of an application key.
     */
    name: string;
    /**
     * Owner of an application key.
     */
    owner: string;
}

export interface ChildOrganizationSetting {
    /**
     * Whether or not the organization users can share widgets outside of Datadog.
     */
    privateWidgetShare: boolean;
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
     */
    samlAutocreateAccessRole: string;
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    samlAutocreateUsersDomains: outputs.ChildOrganizationSettingSamlAutocreateUsersDomain[];
    /**
     * Whether or not SAML can be enabled for this organization.
     */
    samlCanBeEnabled: boolean;
    /**
     * Identity provider endpoint for SAML authentication.
     */
    samlIdpEndpoint: string;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpInitiatedLogins: outputs.ChildOrganizationSettingSamlIdpInitiatedLogin[];
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpMetadataUploaded: boolean;
    /**
     * URL for SAML logging.
     */
    samlLoginUrl: string;
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    samlStrictModes: outputs.ChildOrganizationSettingSamlStrictMode[];
    /**
     * SAML properties
     */
    samls: outputs.ChildOrganizationSettingSaml[];
}

export interface ChildOrganizationSettingSaml {
    /**
     * Whether or not SAML is enabled for this organization.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlAutocreateUsersDomain {
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    domains: string[];
    /**
     * Whether or not the automated user creation based on SAML domain is enabled.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlIdpInitiatedLogin {
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlStrictMode {
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    enabled: boolean;
}

export interface ChildOrganizationUser {
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
     */
    accessRole: string;
    /**
     * The new email of the user.
     */
    email: string;
    /**
     * The name of the user.
     */
    name: string;
}

export interface CloudConfigurationRuleFilter {
    /**
     * The type of filtering action. Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface DashboardListDashItem {
    /**
     * The ID of the dashboard to add
     */
    dashId: string;
    /**
     * The type of this dashboard. Valid values are `customTimeboard`, `customScreenboard`, `integrationScreenboard`, `integrationTimeboard`, `hostTimeboard`.
     */
    type: string;
}

export interface DashboardTemplateVariable {
    /**
     * The list of values that the template variable drop-down is be limited to
     */
    availableValues?: string[];
    /**
     * The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
     *
     * @deprecated Use `defaults` instead.
     */
    default?: string;
    /**
     * One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
     */
    defaults?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
}

export interface DashboardTemplateVariablePreset {
    /**
     * The name of the preset.
     */
    name?: string;
    /**
     * The template variable names and assumed values under the given preset
     */
    templateVariables?: outputs.DashboardTemplateVariablePresetTemplateVariable[];
}

export interface DashboardTemplateVariablePresetTemplateVariable {
    /**
     * The name of the template variable
     */
    name?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     *
     * @deprecated Use `values` instead.
     */
    value?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values?: string[];
}

export interface DashboardWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.DashboardWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.DashboardWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.DashboardWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.DashboardWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.DashboardWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.DashboardWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.DashboardWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGeomapDefinition;
    /**
     * The definition for a Group widget.
     */
    groupDefinition?: outputs.DashboardWidgetGroupDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.DashboardWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.DashboardWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.DashboardWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.DashboardWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.DashboardWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.DashboardWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.DashboardWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.DashboardWidgetNoteDefinition;
    /**
     * The definition for a Powerpack widget.
     */
    powerpackDefinition?: outputs.DashboardWidgetPowerpackDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.DashboardWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.DashboardWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.DashboardWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.DashboardWidgetSloListDefinition;
    /**
     * The definition for a Split Graph widget.
     */
    splitGraphDefinition?: outputs.DashboardWidgetSplitGraphDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.DashboardWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.DashboardWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.DashboardWidgetWidgetLayout;
}

export interface DashboardWidgetAlertGraphDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
     */
    vizType: string;
}

export interface DashboardWidgetAlertValueDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The unit for the value displayed in the widget.
     */
    unit?: string;
}

export interface DashboardWidgetApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetApmQueryGroupBySortQuery;
}

export interface DashboardWidgetApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.DashboardWidgetChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface DashboardWidgetChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetCheckStatusDefinition {
    /**
     * The check to use in the widget.
     */
    check: string;
    /**
     * The check group to use in the widget.
     */
    group?: string;
    /**
     * When `grouping = "cluster"`, indicates a list of tags to use for grouping.
     */
    groupBies?: string[];
    /**
     * The kind of grouping to use. Valid values are `check`, `cluster`.
     */
    grouping: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A list of tags to use in the widget.
     */
    tags?: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetDistributionDefinition {
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetDistributionDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetDistributionDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.DashboardWidgetDistributionDefinitionRequestStyle;
}

export interface DashboardWidgetDistributionDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn[];
    /**
     * The environment name.
     */
    env: string;
    /**
     * The operation name associated with the service.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * The service name.
     */
    service: string;
}

export interface DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn {
    /**
     * A user-assigned alias for the column.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The column name.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface DashboardWidgetEventStreamDefinition {
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetEventTimelineDefinition {
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetFreeTextDefinition {
    /**
     * The color of the text in the widget.
     */
    color?: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * The text to display in the widget.
     */
    text: string;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
}

export interface DashboardWidgetGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `logQuery` or `rumQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetGeomapDefinitionRequest[];
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.DashboardWidgetGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.DashboardWidgetGeomapDefinitionView;
}

export interface DashboardWidgetGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGeomapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGeomapDefinitionStyle {
    /**
     * The color palette to apply to the widget.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface DashboardWidgetGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface DashboardWidgetGroupDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The image URL to display as a banner for the group.
     */
    bannerImg?: string;
    /**
     * The layout type of the group. Valid values are `ordered`.
     */
    layoutType: string;
    /**
     * Whether to show the title or not. Defaults to `true`.
     */
    showTitle?: boolean;
    /**
     * The title of the group.
     */
    title?: string;
    /**
     * The list of widgets in this group.
     */
    widgets?: outputs.DashboardWidgetGroupDefinitionWidget[];
}

export interface DashboardWidgetGroupDefinitionWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.DashboardWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.DashboardWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.DashboardWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.DashboardWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.DashboardWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.DashboardWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.DashboardWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGeomapDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.DashboardWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.DashboardWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.DashboardWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.DashboardWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.DashboardWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.DashboardWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.DashboardWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.DashboardWidgetNoteDefinition;
    /**
     * The definition for a Powerpack widget.
     */
    powerpackDefinition?: outputs.DashboardWidgetPowerpackDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.DashboardWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.DashboardWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.DashboardWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.DashboardWidgetSloListDefinition;
    /**
     * The definition for a Split Graph widget.
     */
    splitGraphDefinition?: outputs.DashboardWidgetSplitGraphDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.DashboardWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.DashboardWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout;
}

export interface DashboardWidgetGroupDefinitionWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
     */
    y: number;
}

export interface DashboardWidgetHeatmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetHeatmapDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetHeatmapDefinitionEvent[];
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetHeatmapDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetHeatmapDefinitionYaxis;
}

export interface DashboardWidgetHeatmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetHeatmapDefinitionEvent {
    /**
     * The event query to use in the widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    formulas?: outputs.DashboardWidgetHeatmapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetHeatmapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.DashboardWidgetHeatmapDefinitionRequestStyle;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface DashboardWidgetHeatmapDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetHostmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetHostmapDefinitionCustomLink[];
    /**
     * The list of tags to group nodes by.
     */
    groups?: string[];
    /**
     * A Boolean indicating whether to show ungrouped nodes.
     */
    noGroupHosts?: boolean;
    /**
     * A Boolean indicating whether to show nodes with no metrics.
     */
    noMetricHosts?: boolean;
    /**
     * The type of node used. Valid values are `host`, `container`.
     */
    nodeType?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
     */
    request?: outputs.DashboardWidgetHostmapDefinitionRequest;
    /**
     * The list of tags to filter nodes by.
     */
    scopes?: string[];
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.DashboardWidgetHostmapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetHostmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetHostmapDefinitionRequest {
    /**
     * The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    fills?: outputs.DashboardWidgetHostmapDefinitionRequestFill[];
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    sizes?: outputs.DashboardWidgetHostmapDefinitionRequestSize[];
}

export interface DashboardWidgetHostmapDefinitionRequestFill {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSize {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHostmapDefinitionStyle {
    /**
     * The max value to use to color the map.
     */
    fillMax?: string;
    /**
     * The min value to use to color the map.
     */
    fillMin?: string;
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip?: boolean;
}

export interface DashboardWidgetIframeDefinition {
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
}

export interface DashboardWidgetImageDefinition {
    /**
     * Whether to display a background or not. Defaults to `true`.
     */
    hasBackground?: boolean;
    /**
     * Whether to display a border or not. Defaults to `true`.
     */
    hasBorder?: boolean;
    /**
     * The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
     */
    horizontalAlign?: string;
    /**
     * The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
     */
    margin?: string;
    /**
     * The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
     */
    sizing?: string;
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
    /**
     * The URL in dark mode to use as a data source for the widget.
     */
    urlDarkTheme?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetListStreamDefinition {
    /**
     * Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
     */
    requests: outputs.DashboardWidgetListStreamDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title. Default is 16.
     */
    titleSize?: string;
}

export interface DashboardWidgetListStreamDefinitionRequest {
    /**
     * Widget columns.
     */
    columns: outputs.DashboardWidgetListStreamDefinitionRequestColumn[];
    /**
     * Updated list stream widget.
     */
    query: outputs.DashboardWidgetListStreamDefinitionRequestQuery;
    /**
     * Widget response format. Valid values are `eventList`.
     */
    responseFormat: string;
}

export interface DashboardWidgetListStreamDefinitionRequestColumn {
    /**
     * Widget column field.
     */
    field: string;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: string;
}

export interface DashboardWidgetListStreamDefinitionRequestQuery {
    /**
     * Source from which to query items to display in the stream. Valid values are `logsStream`, `auditStream`, `ciPipelineStream`, `ciTestStream`, `rumIssueStream`, `apmIssueStream`, `traceStream`, `logsIssueStream`, `logsPatternStream`, `logsTransactionStream`, `eventStream`.
     */
    dataSource: string;
    /**
     * Size of events displayed in widget. Required if `dataSource` is `eventStream`. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * List of indexes.
     */
    indexes?: string[];
    /**
     * Widget query.
     */
    queryString?: string;
    /**
     * The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
     */
    sort?: outputs.DashboardWidgetListStreamDefinitionRequestQuerySort;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetListStreamDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetLogQueryGroupBySortQuery;
}

export interface DashboardWidgetLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetLogStreamDefinition {
    /**
     * Stringified list of columns to use, for example: `["column1","column2","column3"]`.
     */
    columns?: string[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
     */
    messageDisplay?: string;
    /**
     * The query to use in the widget.
     */
    query?: string;
    /**
     * If the date column should be displayed.
     */
    showDateColumn?: boolean;
    /**
     * If the message column should be displayed.
     */
    showMessageColumn?: boolean;
    /**
     * The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
     */
    sort?: outputs.DashboardWidgetLogStreamDefinitionSort;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetLogStreamDefinitionSort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetManageStatusDefinition {
    /**
     * Whether to colorize text or background. Valid values are `background`, `text`.
     */
    colorPreference?: string;
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * A Boolean indicating whether to hide empty categories.
     */
    hideZeroCounts?: boolean;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * A Boolean indicating whether to show when monitors/groups last triggered.
     */
    showLastTriggered?: boolean;
    /**
     * Whether to show the priorities column.
     */
    showPriority?: boolean;
    /**
     * The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
     */
    sort?: string;
    /**
     * The summary type to use. Valid values are `monitors`, `groups`, `combined`.
     */
    summaryType?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetNoteDefinition {
    /**
     * The background color of the note.
     */
    backgroundColor?: string;
    /**
     * The content of the note.
     */
    content: string;
    /**
     * The size of the text.
     */
    fontSize?: string;
    /**
     * Whether to add padding or not. Defaults to `true`.
     */
    hasPadding?: boolean;
    /**
     * Whether to show a tick or not.
     */
    showTick?: boolean;
    /**
     * The alignment of the widget's text. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
     */
    tickEdge?: string;
    /**
     * When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tickPos = "50%"` is centered alignment.
     */
    tickPos?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetPowerpackDefinition {
    /**
     * The background color of the powerpack title.
     */
    backgroundColor?: string;
    /**
     * URL of image to display as a banner for the powerpack.
     */
    bannerImg?: string;
    /**
     * UUID of the associated powerpack.
     */
    powerpackId: string;
    /**
     * Whether to show the title of the powerpack.
     */
    showTitle?: boolean;
    /**
     * The list of template variables for this powerpack.
     */
    templateVariables?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariables;
    /**
     * Title of the powerpack.
     */
    title?: string;
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariables {
    /**
     * Template variables controlled at the powerpack level.
     */
    controlledByPowerpacks?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack[];
    /**
     * Template variables controlled by the external resource, such as the dashboard this powerpack is on.
     */
    controlledExternallies?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally[];
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
     */
    values: string[];
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
     */
    values: string[];
}

export interface DashboardWidgetQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequest {
    /**
     * The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The alias for the column name (defaults to metric name).
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetQueryTableDefinitionRequestFormula[];
    /**
     * The number of lines to show in the table.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The sort order for the rows. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * The environment name.
     */
    env: string;
    /**
     * The operation name associated with the service.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * The service name.
     */
    service: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * A user-assigned alias for the column.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The column name.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the tile.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetQueryValueDefinitionRequest[];
    /**
     * The alignment of the widget's text. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequest {
    /**
     * The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    yaxis?: outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetRumQueryGroupBySortQuery;
}

export interface DashboardWidgetRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetRunWorkflowDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetRunWorkflowDefinitionCustomLink[];
    /**
     * Array of workflow inputs to map to dashboard template variables.
     */
    inputs?: outputs.DashboardWidgetRunWorkflowDefinitionInput[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Workflow ID
     */
    workflowId: string;
}

export interface DashboardWidgetRunWorkflowDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetRunWorkflowDefinitionInput {
    /**
     * Name of the workflow input.
     */
    name: string;
    /**
     * Dashboard template variable. Can be suffixed with `.value` or `.key`.
     */
    value: string;
}

export interface DashboardWidgetScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
     */
    request?: outputs.DashboardWidgetScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.DashboardWidgetScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    yaxis?: outputs.DashboardWidgetScatterplotDefinitionYaxis;
}

export interface DashboardWidgetScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.DashboardWidgetScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.DashboardWidgetScatterplotDefinitionRequestY[];
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestX {
    /**
     * Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestY {
    /**
     * Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetServiceLevelObjectiveDefinition {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The global time target of the widget.
     */
    globalTimeTarget?: string;
    /**
     * Whether to show the error budget or not.
     */
    showErrorBudget?: boolean;
    /**
     * The ID of the service level objective used by the widget.
     */
    sloId: string;
    /**
     * A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `weekToDate`, `previousWeek`, `monthToDate`, `previousMonth`, `globalTime`.
     */
    timeWindows: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view mode for the widget. Valid values are `overall`, `component`, `both`.
     */
    viewMode: string;
    /**
     * The type of view to use when displaying the widget. Only `detail` is supported.
     */
    viewType: string;
}

export interface DashboardWidgetServicemapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetServicemapDefinitionCustomLink[];
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * The ID of the service to map.
     */
    service: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetServicemapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSloListDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
     */
    request: outputs.DashboardWidgetSloListDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSloListDefinitionRequest {
    /**
     * Updated SLO List widget.
     */
    query: outputs.DashboardWidgetSloListDefinitionRequestQuery;
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface DashboardWidgetSloListDefinitionRequestQuery {
    /**
     * Maximum number of results to display in the table. Defaults to `100`.
     */
    limit?: number;
    /**
     * Widget query.
     */
    queryString: string;
    /**
     * The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
     */
    sort?: outputs.DashboardWidgetSloListDefinitionRequestQuerySort;
}

export interface DashboardWidgetSloListDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinition {
    /**
     * Normalize y axes across graphs.
     */
    hasUniformYAxes?: boolean;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * Size of the individual graphs in the split.
     */
    size: string;
    /**
     * The original widget we are splitting on.
     */
    sourceWidgetDefinition: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition;
    /**
     * Encapsulates all user choices about how to split a graph.
     */
    splitConfig: outputs.DashboardWidgetSplitGraphDefinitionSplitConfig;
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition {
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetChangeDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGeomapDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetQueryValueDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetScatterplotDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetToplistDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetTreemapDefinition;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfig {
    /**
     * Maximum number of graphs to display in the widget.
     */
    limit?: number;
    /**
     * Controls the order in which graphs appear in the split.
     */
    sort: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSort;
    /**
     * The property by which the graph splits
     */
    splitDimensions: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions;
    /**
     * The property by which the graph splits
     */
    staticSplits?: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit[];
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSort {
    /**
     * Defines the metric and aggregation used as the sort value
     */
    compute?: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute {
    /**
     * How to aggregate the sort metric for the purposes of ordering.
     */
    aggregation?: string;
    /**
     * The metric to use for sorting graphs.
     */
    metric: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions {
    /**
     * The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
     */
    oneGraphPer: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit {
    /**
     * The split graph list contains a graph for each value of the split dimension.
     */
    splitVectors: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector[];
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector {
    tagKey: string;
    tagValues: string[];
}

export interface DashboardWidgetSunburstDefinition {
    /**
     * Nested block describing a custom link. Multiple `customLink` blocks are allowed with the structure below.
     */
    customLinks?: outputs.DashboardWidgetSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.DashboardWidgetSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.DashboardWidgetSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `logQuery` or `rumQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title. Default is 16.
     */
    titleSize?: string;
}

export interface DashboardWidgetSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Whether to hide the values of the groups.
     */
    hideValue?: boolean;
    /**
     * The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
     */
    type: string;
}

export interface DashboardWidgetSunburstDefinitionLegendTable {
    /**
     * The type of legend (table or none). Valid values are `table`, `none`.
     */
    type: string;
}

export interface DashboardWidgetSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.DashboardWidgetSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * Define style for the widget's request.
     */
    style?: outputs.DashboardWidgetSunburstDefinitionRequestStyle;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface DashboardWidgetTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.DashboardWidgetTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `networkQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.DashboardWidgetTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetTimeseriesDefinitionYaxis;
}

export interface DashboardWidgetTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetTimeseriesDefinitionEvent {
    /**
     * The event query to use in the widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * A label for the line or range.
     */
    label?: string;
    /**
     * A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
     */
    value: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery;
    /**
     * How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
     */
    displayType?: string;
    formulas?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * The style of the widget graph. Exactly one `style` block is allowed using the structure below.
     */
    style?: outputs.DashboardWidgetTimeseriesDefinitionRequestStyle;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.DashboardWidgetToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSecurityQuery;
    /**
     * Define request for the widget's style.
     */
    style?: outputs.DashboardWidgetToplistDefinitionRequestStyle;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetToplistDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface DashboardWidgetTopologyMapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetTopologyMapDefinitionCustomLink[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `requestType` are required within the request).
     */
    requests?: outputs.DashboardWidgetTopologyMapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetTopologyMapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetTopologyMapDefinitionRequest {
    /**
     * The query for a Topology request.
     */
    queries: outputs.DashboardWidgetTopologyMapDefinitionRequestQuery[];
    /**
     * The request type for the Topology request ('topology'). Valid values are `topology`.
     */
    requestType: string;
}

export interface DashboardWidgetTopologyMapDefinitionRequestQuery {
    /**
     * The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `dataStreams`, `serviceMap`.
     */
    dataSource: string;
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * The ID of the service to map.
     */
    service: string;
}

export interface DashboardWidgetTraceServiceDefinition {
    /**
     * The number of columns to display. Valid values are `oneColumn`, `twoColumn`, `threeColumn`.
     */
    displayFormat?: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * Whether to show the latency breakdown or not.
     */
    showBreakdown?: boolean;
    /**
     * Whether to show the latency distribution or not.
     */
    showDistribution?: boolean;
    /**
     * Whether to show the error metrics or not.
     */
    showErrors?: boolean;
    /**
     * Whether to show the hits metrics or not
     */
    showHits?: boolean;
    /**
     * Whether to show the latency metrics or not.
     */
    showLatency?: boolean;
    /**
     * Whether to show the resource list or not.
     */
    showResourceList?: boolean;
    /**
     * The size of the widget. Valid values are `small`, `medium`, `large`.
     */
    sizeFormat?: string;
    /**
     * APM span name
     */
    spanName: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetTreemapDefinition {
    /**
     * Nested block describing the request to use when displaying the widget.
     */
    requests?: outputs.DashboardWidgetTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetTreemapDefinitionRequest {
    formulas?: outputs.DashboardWidgetTreemapDefinitionRequestFormula[];
    queries?: outputs.DashboardWidgetTreemapDefinitionRequestQuery[];
}

export interface DashboardWidgetTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
     */
    y: number;
}

export interface DowntimeRecurrence {
    /**
     * How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
     */
    period?: number;
    /**
     * The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
     */
    rrule?: string;
    /**
     * One of `days`, `weeks`, `months`, `years`, or `rrule`.
     */
    type: string;
    /**
     * The date at which the recurrence should end as a POSIX timestamp. `untilOccurrences` and `untilDate` are mutually exclusive.
     */
    untilDate?: number;
    /**
     * How many times the downtime will be rescheduled. `untilOccurrences` and `untilDate` are mutually exclusive.
     */
    untilOccurrences?: number;
    /**
     * A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
     */
    weekDays?: string[];
}

export interface DowntimeScheduleMonitorIdentifier {
    /**
     * ID of the monitor to prevent notifications.
     */
    monitorId?: number;
    /**
     * A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitorTags` to `[*]` configures the downtime to mute all monitors for the given scope.
     */
    monitorTags?: string[];
}

export interface DowntimeScheduleOneTimeSchedule {
    /**
     * ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
     */
    end?: string;
    /**
     * ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
     */
    start: string;
}

export interface DowntimeScheduleRecurringSchedule {
    recurrences?: outputs.DowntimeScheduleRecurringScheduleRecurrence[];
    /**
     * The timezone in which to schedule the downtime.
     */
    timezone: string;
}

export interface DowntimeScheduleRecurringScheduleRecurrence {
    /**
     * The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
     */
    duration: string;
    /**
     * The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
     */
    rrule: string;
    /**
     * ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
     */
    start: string;
}

export interface GetCloudWorkloadSecurityAgentRulesAgentRule {
    /**
     * The description of the Agent rule.
     */
    description: string;
    /**
     * Whether the Agent rule is enabled.
     */
    enabled: boolean;
    /**
     * The SECL expression of the Agent rule.
     */
    expression: string;
    /**
     * The id of the Agent rule.
     */
    id: string;
    /**
     * The name of the Agent rule.
     */
    name: string;
}

export interface GetCsmThreatsAgentRulesAgentRule {
    description: string;
    enabled: boolean;
    expression: string;
    id: string;
    name: string;
}

export interface GetHostsHostList {
    aliases: string[];
    apps: string[];
    awsName: string;
    hostName: string;
    id: number;
    isMuted: boolean;
    lastReportedTime: number;
    meta: outputs.GetHostsHostListMeta;
    metrics: outputs.GetHostsHostListMetrics;
    muteTimeout: number;
    name: string;
    sources: string[];
    up: boolean;
}

export interface GetHostsHostListMeta {
    agentVersion: string;
    cpuCores: number;
    gohai: string;
    machine: string;
    platform: string;
    processor: string;
    pythonVersion: string;
    socketFqdn: string;
    socketHostname: string;
}

export interface GetHostsHostListMetrics {
    cpu: number;
    iowait: number;
    load: number;
}

export interface GetLogsIndexesLogsIndex {
    /**
     * The number of log events you can send in this index per day before you are rate-limited.
     */
    dailyLimit: number;
    /**
     * Object containing options to override the default daily limit reset time.
     */
    dailyLimitResets: outputs.GetLogsIndexesLogsIndexDailyLimitReset[];
    /**
     * The percentage threshold of the daily quota at which a Datadog warning event is generated.
     */
    dailyLimitWarningThresholdPercentage: number;
    /**
     * List of exclusion filters.
     */
    exclusionFilters: outputs.GetLogsIndexesLogsIndexExclusionFilter[];
    /**
     * Logs filter
     */
    filters: outputs.GetLogsIndexesLogsIndexFilter[];
    /**
     * The name of the index.
     */
    name: string;
    /**
     * The number of days before logs are deleted from this index.
     */
    retentionDays: number;
}

export interface GetLogsIndexesLogsIndexDailyLimitReset {
    /**
     * String in `HH:00` format representing the time of day the daily limit should be reset. The hours between 00 and 23 (inclusive).
     */
    resetTime: string;
    /**
     * String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours between -12 and +14 (inclusive).
     */
    resetUtcOffset: string;
}

export interface GetLogsIndexesLogsIndexExclusionFilter {
    filters?: outputs.GetLogsIndexesLogsIndexExclusionFilterFilter[];
    /**
     * A boolean stating if the exclusion is active or not.
     */
    isEnabled: boolean;
    /**
     * The name of the exclusion filter.
     */
    name: string;
}

export interface GetLogsIndexesLogsIndexExclusionFilterFilter {
    /**
     * Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
     */
    query: string;
    /**
     * The fraction of logs excluded by the exclusion filter, when active.
     */
    sampleRate: number;
}

export interface GetLogsIndexesLogsIndexFilter {
    /**
     * Logs filter criteria. Only logs matching this filter criteria are considered for this index.
     */
    query: string;
}

export interface GetLogsPipelinesLogsPipeline {
    /**
     * Pipelines filter
     */
    filters: outputs.GetLogsPipelinesLogsPipelineFilter[];
    /**
     * ID of the pipeline
     */
    id: string;
    /**
     * Whether or not the pipeline is enabled.
     */
    isEnabled: boolean;
    /**
     * Whether or not the pipeline can be edited.
     */
    isReadOnly: boolean;
    /**
     * The name of the pipeline.
     */
    name: string;
    /**
     * Whether or not the pipeline can be edited.
     */
    type: string;
}

export interface GetLogsPipelinesLogsPipelineFilter {
    /**
     * Pipeline filter criteria.
     */
    query: string;
}

export interface GetMonitorConfigPoliciesMonitorConfigPolicy {
    /**
     * ID of the monitor config policy
     */
    id: string;
    /**
     * The monitor config policy type
     */
    policyType: string;
    /**
     * Config for a tag policy. Only set if `policyType` is `tag`.
     */
    tagPolicy: outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicy;
}

export interface GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicy {
    /**
     * The key of the tag
     */
    tagKey: string;
    /**
     * If a tag key is required for monitor creation
     */
    tagKeyRequired: boolean;
    /**
     * Valid values for the tag
     */
    validTagValues: string[];
}

export interface GetMonitorMonitorThreshold {
    critical: string;
    criticalRecovery: string;
    ok: string;
    unknown: string;
    warning: string;
    warningRecovery: string;
}

export interface GetMonitorMonitorThresholdWindow {
    recoveryWindow: string;
    triggerWindow: string;
}

export interface GetMonitorSchedulingOption {
    /**
     * Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
     */
    customSchedules: outputs.GetMonitorSchedulingOptionCustomSchedule[];
    /**
     * Configuration options for the evaluation window. If `hourStarts` is set, no other fields may be set. Otherwise, `dayStarts` and `monthStarts` must be set together.
     */
    evaluationWindows: outputs.GetMonitorSchedulingOptionEvaluationWindow[];
}

export interface GetMonitorSchedulingOptionCustomSchedule {
    /**
     * A list of recurrence definitions. Length must be 1.
     */
    recurrences: outputs.GetMonitorSchedulingOptionCustomScheduleRecurrence[];
}

export interface GetMonitorSchedulingOptionCustomScheduleRecurrence {
    /**
     * Must be a valid rrule. See api docs for supported fields
     */
    rrule: string;
    /**
     * Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
     */
    start: string;
    /**
     * 'tz database' format. ex: 'America/New_York' or UTC
     */
    timezone: string;
}

export interface GetMonitorSchedulingOptionEvaluationWindow {
    /**
     * The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
     */
    dayStarts: string;
    /**
     * The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
     */
    hourStarts: number;
    /**
     * The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
     */
    monthStarts: number;
}

export interface GetMonitorsMonitor {
    /**
     * ID of the monitor
     */
    id: number;
    /**
     * Name of the monitor
     */
    name: string;
    /**
     * Type of the monitor.
     */
    type: string;
}

export interface GetRoleUsersRoleUser {
    roleId: string;
    userId: string;
}

export interface GetRolesRole {
    /**
     * ID of the Datadog role
     */
    id: string;
    /**
     * Name of the Datadog role
     */
    name: string;
    /**
     * Number of users that have this role.
     */
    userCount: number;
}

export interface GetSecurityMonitoringFiltersFilter {
    /**
     * Exclusion filters to exclude some logs from the security filter.
     */
    exclusionFilters?: outputs.GetSecurityMonitoringFiltersFilterExclusionFilter[];
    /**
     * The filtered data type.
     */
    filteredDataType?: string;
    /**
     * Whether the security filter is enabled.
     */
    isEnabled: boolean;
    /**
     * The name of the security filter.
     */
    name: string;
    /**
     * The query of the security filter.
     */
    query: string;
    /**
     * The version of the security filter.
     */
    version: number;
}

export interface GetSecurityMonitoringFiltersFilterExclusionFilter {
    /**
     * Exclusion filter name.
     */
    name: string;
    /**
     * Exclusion filter query. Logs that match this query are excluded from the security filter.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRule {
    /**
     * Cases for generating signals.
     */
    cases?: outputs.GetSecurityMonitoringRulesRuleCase[];
    /**
     * Whether the rule is enabled.
     */
    enabled?: boolean;
    /**
     * Additional queries to filter matched events before they are processed. **Note**: This field is deprecated for log detection, signal correlation, and workload security rules.
     */
    filters?: outputs.GetSecurityMonitoringRulesRuleFilter[];
    /**
     * Whether the notifications include the triggering group-by values in their title.
     */
    hasExtendedTitle?: boolean;
    /**
     * Message for generated signals.
     */
    message: string;
    /**
     * The name of the rule.
     */
    name: string;
    /**
     * Options on rules.
     */
    options?: outputs.GetSecurityMonitoringRulesRuleOptions;
    /**
     * Queries for selecting logs which are part of the rule.
     */
    queries?: outputs.GetSecurityMonitoringRulesRuleQuery[];
    /**
     * Queries for selecting logs which are part of the rule.
     */
    signalQueries?: outputs.GetSecurityMonitoringRulesRuleSignalQuery[];
    /**
     * Tags for generated signals.
     */
    tags?: string[];
    /**
     * Cases for generating signals for third-party rules. Only required and accepted for third-party rules
     */
    thirdPartyCases?: outputs.GetSecurityMonitoringRulesRuleThirdPartyCase[];
    /**
     * The rule type.
     */
    type?: string;
}

export interface GetSecurityMonitoringRulesRuleCase {
    /**
     * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
     */
    condition?: string;
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * Severity of the Security Signal.
     */
    status: string;
}

export interface GetSecurityMonitoringRulesRuleFilter {
    /**
     * The type of filtering action.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
    /**
     * The detection method.
     */
    detectionMethod?: string;
    /**
     * A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
     */
    evaluationWindow?: number;
    /**
     * Options for rules using the impossible travel detection method.
     */
    impossibleTravelOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptions;
    /**
     * Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window (in seconds).
     */
    keepAlive?: number;
    /**
     * A signal will “close” regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp.
     */
    maxSignalDuration?: number;
    /**
     * New value rules specific options.
     */
    newValueOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptions;
    /**
     * Options for rules using the third-party detection method.
     */
    thirdPartyRuleOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptions;
}

export interface GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptions {
    /**
     * If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
     */
    baselineUserLocations?: boolean;
}

export interface GetSecurityMonitoringRulesRuleOptionsNewValueOptions {
    /**
     * The duration in days after which a learned value is forgotten.
     */
    forgetAfter: number;
    /**
     * The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
     */
    learningDuration?: number;
    /**
     * The learning method used to determine when signals should be generated for values that weren't learned.
     */
    learningMethod?: string;
    /**
     * A number of occurrences after which signals are generated for values that weren't learned.
     */
    learningThreshold?: number;
}

export interface GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptions {
    /**
     * Notification targets for the default rule case, when none of the third-party cases match.
     */
    defaultNotifications?: string[];
    /**
     * Severity of the default rule case, when none of the third-party cases match.
     */
    defaultStatus: string;
    /**
     * Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
     */
    rootQueries: outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQuery[];
    /**
     * A template for the signal title; if omitted, the title is generated based on the case name.
     */
    signalTitleTemplate?: string;
}

export interface GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQuery {
    /**
     * Fields to group by. If empty, each log triggers a signal.
     */
    groupByFields?: string[];
    /**
     * Query to filter logs.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleQuery {
    /**
     * **Deprecated**. It won't be applied anymore.
     *
     * @deprecated `agentRule` has been deprecated in favor of new Agent Rule resource.
     */
    agentRules?: outputs.GetSecurityMonitoringRulesRuleQueryAgentRule[];
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count.
     */
    aggregation?: string;
    /**
     * Field for which the cardinality is measured. Sent as an array.
     */
    distinctFields?: string[];
    /**
     * Fields to group by.
     */
    groupByFields?: string[];
    /**
     * The target field to aggregate over when using the `sum`, `max`, or `geoData` aggregations.
     *
     * @deprecated Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     */
    metric?: string;
    /**
     * Group of target fields to aggregate over when using the `sum`, `max`, `geoData`, or `newValue` aggregations. The `sum`, `max`, and `geoData` aggregations only accept one value in this list, whereas the `newValue` aggregation accepts up to five values.
     */
    metrics: string[];
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Query to run on logs.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleQueryAgentRule {
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    agentRuleId: string;
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    expression: string;
}

export interface GetSecurityMonitoringRulesRuleSignalQuery {
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count.
     */
    aggregation?: string;
    /**
     * Fields to correlate by.
     */
    correlatedByFields?: string[];
    /**
     * Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
     */
    correlatedQueryIndex?: string;
    /**
     * Default Rule ID of the signal to correlate. This value is READ-ONLY.
     */
    defaultRuleId?: string;
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Rule ID of the signal to correlate.
     */
    ruleId: string;
}

export interface GetSecurityMonitoringRulesRuleThirdPartyCase {
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * A query to associate a third-party event to this case.
     */
    query?: string;
    /**
     * Severity of the Security Signal.
     */
    status: string;
}

export interface GetSecurityMonitoringSuppressionsSuppression {
    dataExclusionQuery: string;
    description: string;
    enabled: boolean;
    expirationDate: string;
    id: string;
    name: string;
    ruleQuery: string;
    suppressionQuery: string;
}

export interface GetServiceLevelObjectiveQuery {
    /**
     * The sum of the `total` events.
     */
    denominator: string;
    /**
     * The sum of all the `good` events.
     */
    numerator: string;
}

export interface GetServiceLevelObjectivesSlo {
    /**
     * ID of the Datadog service level objective
     */
    id: string;
    /**
     * Name of the Datadog service level objective
     */
    name: string;
    /**
     * The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation page](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object). Available options to choose from are: `metric` and `monitor`.
     */
    type: string;
}

export interface GetTeamMembershipsTeamMembership {
    id: string;
    role: string;
    teamId: string;
    userId: string;
}

export interface GetUsersUser {
    email: string;
    id: string;
    name: string;
}

export interface IpAllowlistEntry {
    /**
     * IP address or range of addresses.
     */
    cidrBlock: string;
    /**
     * Note accompanying IP address.
     */
    note?: string;
}

export interface LogsArchiveAzureArchive {
    /**
     * Your client id.
     */
    clientId: string;
    /**
     * The container where the archive is stored.
     */
    container: string;
    /**
     * The path where the archive is stored.
     */
    path?: string;
    /**
     * The associated storage account.
     */
    storageAccount: string;
    /**
     * Your tenant id.
     */
    tenantId: string;
}

export interface LogsArchiveGcsArchive {
    /**
     * Name of your GCS bucket.
     */
    bucket: string;
    /**
     * Your client email.
     */
    clientEmail: string;
    /**
     * Path where the archive is stored.
     */
    path?: string;
    /**
     * Your project id.
     */
    projectId?: string;
}

export interface LogsArchiveS3Archive {
    /**
     * Your AWS account id.
     */
    accountId: string;
    /**
     * Name of your s3 bucket.
     */
    bucket: string;
    /**
     * Path where the archive is stored.
     */
    path?: string;
    /**
     * Your AWS role name
     */
    roleName: string;
}

export interface LogsCustomPipelineFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessor {
    /**
     * Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
     */
    arithmeticProcessor?: outputs.LogsCustomPipelineProcessorArithmeticProcessor;
    /**
     * Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
     */
    attributeRemapper?: outputs.LogsCustomPipelineProcessorAttributeRemapper;
    /**
     * Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
     */
    categoryProcessor?: outputs.LogsCustomPipelineProcessorCategoryProcessor;
    /**
     * Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
     */
    dateRemapper?: outputs.LogsCustomPipelineProcessorDateRemapper;
    /**
     * Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
     */
    geoIpParser?: outputs.LogsCustomPipelineProcessorGeoIpParser;
    /**
     * Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
     */
    grokParser?: outputs.LogsCustomPipelineProcessorGrokParser;
    /**
     * Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    lookupProcessor?: outputs.LogsCustomPipelineProcessorLookupProcessor;
    /**
     * Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
     */
    messageRemapper?: outputs.LogsCustomPipelineProcessorMessageRemapper;
    pipeline?: outputs.LogsCustomPipelineProcessorPipeline;
    /**
     * Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    referenceTableLookupProcessor?: outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor;
    /**
     * Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
     */
    serviceRemapper?: outputs.LogsCustomPipelineProcessorServiceRemapper;
    /**
     * Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
     */
    statusRemapper?: outputs.LogsCustomPipelineProcessorStatusRemapper;
    /**
     * String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
     */
    stringBuilderProcessor?: outputs.LogsCustomPipelineProcessorStringBuilderProcessor;
    /**
     * Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
     */
    traceIdRemapper?: outputs.LogsCustomPipelineProcessorTraceIdRemapper;
    /**
     * URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
     */
    urlParser?: outputs.LogsCustomPipelineProcessorUrlParser;
    /**
     * User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
     */
    userAgentParser?: outputs.LogsCustomPipelineProcessorUserAgentParser;
}

export interface LogsCustomPipelineProcessorArithmeticProcessor {
    /**
     * Arithmetic operation between one or more log attributes.
     */
    expression: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorAttributeRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Override the target element if already set.
     */
    overrideOnConflict?: boolean;
    /**
     * Remove or preserve the remapped source element.
     */
    preserveSource?: boolean;
    /**
     * Defines where the sources are from (log `attribute` or `tag`).
     */
    sourceType: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Final attribute or tag name to remap the sources.
     */
    target: string;
    /**
     * If the `targetType` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `targetType` is `tag`, this parameter may not be specified.
     */
    targetFormat?: string;
    /**
     * Defines if the target is a log `attribute` or `tag`.
     */
    targetType: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessor {
    /**
     * List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
     */
    categories: outputs.LogsCustomPipelineProcessorCategoryProcessorCategory[];
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the category
     */
    name?: string;
    /**
     * Name of the target attribute whose value is defined by the matching category.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessorCategory {
    filter: outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter;
    name: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessorCategoryFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorDateRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorGeoIpParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorGrokParser {
    grok: outputs.LogsCustomPipelineProcessorGrokParserGrok;
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
     */
    samples?: string[];
    /**
     * Name of the log attribute to parse.
     */
    source: string;
}

export interface LogsCustomPipelineProcessorGrokParserGrok {
    /**
     * Match rules for your grok parser.
     */
    matchRules: string;
    /**
     * Support rules for your grok parser.
     */
    supportRules: string;
}

export interface LogsCustomPipelineProcessorLookupProcessor {
    /**
     * Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
     */
    defaultLookup?: string;
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * List of entries of the lookup table using `key,value` format.
     */
    lookupTables: string[];
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Name of the source attribute used to do the lookup.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the lookup.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorMessageRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipeline {
    filters: outputs.LogsCustomPipelineProcessorPipelineFilter[];
    isEnabled?: boolean;
    name: string;
    processors?: outputs.LogsCustomPipelineProcessorPipelineProcessor[];
}

export interface LogsCustomPipelineProcessorPipelineFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessor {
    /**
     * Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
     */
    arithmeticProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor;
    /**
     * Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
     */
    attributeRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper;
    /**
     * Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
     */
    categoryProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor;
    /**
     * Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
     */
    dateRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper;
    /**
     * Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
     */
    geoIpParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser;
    /**
     * Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
     */
    grokParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser;
    /**
     * Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    lookupProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor;
    /**
     * Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
     */
    messageRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper;
    /**
     * Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    referenceTableLookupProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor;
    /**
     * Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
     */
    serviceRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper;
    /**
     * Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
     */
    statusRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper;
    /**
     * String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
     */
    stringBuilderProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor;
    /**
     * Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
     */
    traceIdRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper;
    /**
     * URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
     */
    urlParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser;
    /**
     * User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
     */
    userAgentParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser;
}

export interface LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor {
    /**
     * Arithmetic operation between one or more log attributes.
     */
    expression: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Override the target element if already set.
     */
    overrideOnConflict?: boolean;
    /**
     * Remove or preserve the remapped source element.
     */
    preserveSource?: boolean;
    /**
     * Defines where the sources are from (log `attribute` or `tag`).
     */
    sourceType: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Final attribute or tag name to remap the sources.
     */
    target: string;
    /**
     * If the `targetType` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `targetType` is `tag`, this parameter may not be specified.
     */
    targetFormat?: string;
    /**
     * Defines if the target is a log `attribute` or `tag`.
     */
    targetType: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor {
    /**
     * List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
     */
    categories: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory[];
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the category
     */
    name?: string;
    /**
     * Name of the target attribute whose value is defined by the matching category.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory {
    filter: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter;
    name: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorDateRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorGeoIpParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorGrokParser {
    grok: outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok;
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
     */
    samples?: string[];
    /**
     * Name of the log attribute to parse.
     */
    source: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok {
    /**
     * Match rules for your grok parser.
     */
    matchRules: string;
    /**
     * Support rules for your grok parser.
     */
    supportRules: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorLookupProcessor {
    /**
     * Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
     */
    defaultLookup?: string;
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * List of entries of the lookup table using `key,value` format.
     */
    lookupTables: string[];
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Name of the source attribute used to do the lookup.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the lookup.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorMessageRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the Reference Table for the source attribute and their associated target attribute values.
     */
    lookupEnrichmentTable: string;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Name of the source attribute used to do the lookup.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the lookup.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorServiceRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorStatusRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * If it replaces all missing attributes of template by an empty string.
     */
    isReplaceMissing?: boolean;
    /**
     * The name of the processor.
     */
    name?: string;
    /**
     * The name of the attribute that contains the result of the template.
     */
    target: string;
    /**
     * The formula with one or more attributes and raw text.
     */
    template: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorUrlParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Normalize the ending slashes or not.
     */
    normalizeEndingSlashes?: boolean;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorUserAgentParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * If the source attribute is URL encoded or not.
     */
    isEncoded?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorReferenceTableLookupProcessor {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the Reference Table for the source attribute and their associated target attribute values.
     */
    lookupEnrichmentTable: string;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Name of the source attribute used to do the lookup.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the lookup.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorServiceRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorStatusRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorStringBuilderProcessor {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * If it replaces all missing attributes of template by an empty string.
     */
    isReplaceMissing?: boolean;
    /**
     * The name of the processor.
     */
    name?: string;
    /**
     * The name of the attribute that contains the result of the template.
     */
    target: string;
    /**
     * The formula with one or more attributes and raw text.
     */
    template: string;
}

export interface LogsCustomPipelineProcessorTraceIdRemapper {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor.
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorUrlParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * Normalize the ending slashes or not.
     */
    normalizeEndingSlashes?: boolean;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorUserAgentParser {
    /**
     * If the processor is enabled or not.
     */
    isEnabled?: boolean;
    /**
     * If the source attribute is URL encoded or not.
     */
    isEncoded?: boolean;
    /**
     * Name of the processor
     */
    name?: string;
    /**
     * List of source attributes.
     */
    sources: string[];
    /**
     * Name of the parent attribute that contains all the extracted details from the sources.
     */
    target: string;
}

export interface LogsIndexDailyLimitReset {
    /**
     * String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
     */
    resetTime: string;
    /**
     * String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
     */
    resetUtcOffset: string;
}

export interface LogsIndexExclusionFilter {
    filters?: outputs.LogsIndexExclusionFilterFilter[];
    /**
     * A boolean stating if the exclusion is active or not.
     */
    isEnabled?: boolean;
    /**
     * The name of the exclusion filter.
     */
    name?: string;
}

export interface LogsIndexExclusionFilterFilter {
    /**
     * Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
     */
    query?: string;
    /**
     * The fraction of logs excluded by the exclusion filter, when active.
     */
    sampleRate?: number;
}

export interface LogsIndexFilter {
    /**
     * Logs filter criteria. Only logs matching this filter criteria are considered for this index.
     */
    query: string;
}

export interface LogsMetricCompute {
    /**
     * The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
     */
    aggregationType: string;
    /**
     * Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregationType` of distribution.
     */
    includePercentiles?: boolean;
    /**
     * The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
     */
    path?: string;
}

export interface LogsMetricFilter {
    /**
     * The search query - following the log search syntax.
     */
    query: string;
}

export interface LogsMetricGroupBy {
    /**
     * The path to the value the log-based metric will be aggregated over.
     */
    path: string;
    /**
     * Name of the tag that gets created.
     */
    tagName: string;
}

export interface MetricTagConfigurationAggregation {
    /**
     * A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
     */
    space: string;
    /**
     * A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
     */
    time: string;
}

export interface MonitorConfigPolicyTagPolicy {
    /**
     * The key of the tag
     */
    tagKey: string;
    /**
     * If a tag key is required for monitor creation
     */
    tagKeyRequired: boolean;
    /**
     * Valid values for the tag
     */
    validTagValues: string[];
}

export interface MonitorMonitorThresholdWindows {
    /**
     * Describes how long an anomalous metric must be normal before the alert recovers.
     */
    recoveryWindow?: string;
    /**
     * Describes how long a metric must be anomalous before an alert triggers.
     */
    triggerWindow?: string;
}

export interface MonitorMonitorThresholds {
    /**
     * The monitor `CRITICAL` threshold. Must be a number.
     */
    critical?: string;
    /**
     * The monitor `CRITICAL` recovery threshold. Must be a number.
     */
    criticalRecovery?: string;
    /**
     * The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
     */
    ok?: string;
    /**
     * The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
     */
    unknown?: string;
    /**
     * The monitor `WARNING` threshold. Must be a number.
     */
    warning?: string;
    /**
     * The monitor `WARNING` recovery threshold. Must be a number.
     */
    warningRecovery?: string;
}

export interface MonitorSchedulingOption {
    /**
     * Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
     */
    customSchedules?: outputs.MonitorSchedulingOptionCustomSchedule[];
    /**
     * Configuration options for the evaluation window. If `hourStarts` is set, no other fields may be set. Otherwise, `dayStarts` and `monthStarts` must be set together.
     */
    evaluationWindows?: outputs.MonitorSchedulingOptionEvaluationWindow[];
}

export interface MonitorSchedulingOptionCustomSchedule {
    /**
     * A list of recurrence definitions. Length must be 1.
     */
    recurrence: outputs.MonitorSchedulingOptionCustomScheduleRecurrence;
}

export interface MonitorSchedulingOptionCustomScheduleRecurrence {
    /**
     * Must be a valid `rrule`. See API docs for supported fields
     */
    rrule: string;
    /**
     * Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
     */
    start?: string;
    /**
     * 'tz database' format. Example: `America/New_York` or `UTC`
     */
    timezone: string;
}

export interface MonitorSchedulingOptionEvaluationWindow {
    /**
     * The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
     */
    dayStarts?: string;
    /**
     * The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
     */
    hourStarts?: number;
    /**
     * The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
     */
    monthStarts?: number;
}

export interface MonitorVariables {
    /**
     * A timeseries formula and functions events query.
     */
    eventQueries?: outputs.MonitorVariablesEventQuery[];
}

export interface MonitorVariablesEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.MonitorVariablesEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `rum`, `ciPipelines`, `ciTests`, `audit`, `events`, `logs`, `spans`, `databaseQueries`, `networkPerformanceQueries`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.MonitorVariablesEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search: outputs.MonitorVariablesEventQuerySearch;
}

export interface MonitorVariablesEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface MonitorVariablesEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.MonitorVariablesEventQueryGroupBySort;
}

export interface MonitorVariablesEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface MonitorVariablesEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface OrganizationSettingsSettings {
    /**
     * Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
     */
    privateWidgetShare?: boolean;
    /**
     * SAML properties
     */
    saml: outputs.OrganizationSettingsSettingsSaml;
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
     */
    samlAutocreateAccessRole?: string;
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    samlAutocreateUsersDomains: outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains;
    /**
     * Whether or not SAML can be enabled for this organization.
     */
    samlCanBeEnabled: boolean;
    /**
     * Identity provider endpoint for SAML authentication.
     */
    samlIdpEndpoint: string;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpInitiatedLogin: outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpMetadataUploaded: boolean;
    /**
     * URL for SAML logging.
     */
    samlLoginUrl: string;
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    samlStrictMode: outputs.OrganizationSettingsSettingsSamlStrictMode;
}

export interface OrganizationSettingsSettingsSaml {
    /**
     * Whether or not SAML is enabled for this organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlAutocreateUsersDomains {
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    domains?: string[];
    /**
     * Whether or not the automated user creation based on SAML domain is enabled. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlIdpInitiatedLogin {
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlStrictMode {
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface PowerpackLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
     */
    y: number;
}

export interface PowerpackTemplateVariable {
    /**
     * One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
     */
    defaults?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
}

export interface PowerpackWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.PowerpackWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.PowerpackWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.PowerpackWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.PowerpackWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.PowerpackWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.PowerpackWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.PowerpackWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.PowerpackWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.PowerpackWidgetGeomapDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.PowerpackWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.PowerpackWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.PowerpackWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.PowerpackWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.PowerpackWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.PowerpackWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.PowerpackWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.PowerpackWidgetNoteDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.PowerpackWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.PowerpackWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.PowerpackWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.PowerpackWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.PowerpackWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.PowerpackWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.PowerpackWidgetSloListDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.PowerpackWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.PowerpackWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.PowerpackWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.PowerpackWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.PowerpackWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.PowerpackWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.PowerpackWidgetWidgetLayout;
}

export interface PowerpackWidgetAlertGraphDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
     */
    vizType: string;
}

export interface PowerpackWidgetAlertValueDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The unit for the value displayed in the widget.
     */
    unit?: string;
}

export interface PowerpackWidgetChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.PowerpackWidgetChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetCheckStatusDefinition {
    /**
     * The check to use in the widget.
     */
    check: string;
    /**
     * The check group to use in the widget.
     */
    group?: string;
    /**
     * When `grouping = "cluster"`, indicates a list of tags to use for grouping.
     */
    groupBies?: string[];
    /**
     * The kind of grouping to use. Valid values are `check`, `cluster`.
     */
    grouping: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A list of tags to use in the widget.
     */
    tags?: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetDistributionDefinition {
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetDistributionDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQuery;
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.PowerpackWidgetDistributionDefinitionRequestStyle;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn[];
    /**
     * The environment name.
     */
    env: string;
    /**
     * The operation name associated with the service.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * The service name.
     */
    service: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn {
    /**
     * A user-assigned alias for the column.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The column name.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface PowerpackWidgetEventStreamDefinition {
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetEventTimelineDefinition {
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetFreeTextDefinition {
    /**
     * The color of the text in the widget.
     */
    color?: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * The text to display in the widget.
     */
    text: string;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
}

export interface PowerpackWidgetGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `logQuery` or `rumQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetGeomapDefinitionRequest[];
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.PowerpackWidgetGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.PowerpackWidgetGeomapDefinitionView;
}

export interface PowerpackWidgetGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequest {
    formulas?: outputs.PowerpackWidgetGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionStyle {
    /**
     * The color palette to apply to the widget.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface PowerpackWidgetGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface PowerpackWidgetHeatmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetHeatmapDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.PowerpackWidgetHeatmapDefinitionEvent[];
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetHeatmapDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetHeatmapDefinitionYaxis;
}

export interface PowerpackWidgetHeatmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetHeatmapDefinitionEvent {
    /**
     * The event query to use in the widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters.
     */
    tagsExecution?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQuery;
    formulas?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetHeatmapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQuery;
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.PowerpackWidgetHeatmapDefinitionRequestStyle;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface PowerpackWidgetHeatmapDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetHostmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetHostmapDefinitionCustomLink[];
    /**
     * The list of tags to group nodes by.
     */
    groups?: string[];
    /**
     * A Boolean indicating whether to show ungrouped nodes.
     */
    noGroupHosts?: boolean;
    /**
     * A Boolean indicating whether to show nodes with no metrics.
     */
    noMetricHosts?: boolean;
    /**
     * The type of node used. Valid values are `host`, `container`.
     */
    nodeType?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
     */
    request?: outputs.PowerpackWidgetHostmapDefinitionRequest;
    /**
     * The list of tags to filter nodes by.
     */
    scopes?: string[];
    /**
     * The style of the widget graph. One nested block is allowed using the structure below.
     */
    style?: outputs.PowerpackWidgetHostmapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetHostmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequest {
    /**
     * The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    fills?: outputs.PowerpackWidgetHostmapDefinitionRequestFill[];
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    sizes?: outputs.PowerpackWidgetHostmapDefinitionRequestSize[];
}

export interface PowerpackWidgetHostmapDefinitionRequestFill {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSize {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionStyle {
    /**
     * The max value to use to color the map.
     */
    fillMax?: string;
    /**
     * The min value to use to color the map.
     */
    fillMin?: string;
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip?: boolean;
}

export interface PowerpackWidgetIframeDefinition {
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
}

export interface PowerpackWidgetImageDefinition {
    /**
     * Whether to display a background or not. Defaults to `true`.
     */
    hasBackground?: boolean;
    /**
     * Whether to display a border or not. Defaults to `true`.
     */
    hasBorder?: boolean;
    /**
     * The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
     */
    horizontalAlign?: string;
    /**
     * The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
     */
    margin?: string;
    /**
     * The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
     */
    sizing?: string;
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
    /**
     * The URL in dark mode to use as a data source for the widget.
     */
    urlDarkTheme?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface PowerpackWidgetListStreamDefinition {
    /**
     * Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
     */
    requests: outputs.PowerpackWidgetListStreamDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title. Default is 16.
     */
    titleSize?: string;
}

export interface PowerpackWidgetListStreamDefinitionRequest {
    /**
     * Widget columns.
     */
    columns: outputs.PowerpackWidgetListStreamDefinitionRequestColumn[];
    /**
     * Updated list stream widget.
     */
    query: outputs.PowerpackWidgetListStreamDefinitionRequestQuery;
    /**
     * Widget response format. Valid values are `eventList`.
     */
    responseFormat: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestColumn {
    /**
     * Widget column field.
     */
    field: string;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestQuery {
    /**
     * Source from which to query items to display in the stream. Valid values are `logsStream`, `auditStream`, `ciPipelineStream`, `ciTestStream`, `rumIssueStream`, `apmIssueStream`, `traceStream`, `logsIssueStream`, `logsPatternStream`, `logsTransactionStream`, `eventStream`.
     */
    dataSource: string;
    /**
     * Size of events displayed in widget. Required if `dataSource` is `eventStream`. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * List of indexes.
     */
    indexes?: string[];
    /**
     * Widget query.
     */
    queryString?: string;
    /**
     * The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
     */
    sort?: outputs.PowerpackWidgetListStreamDefinitionRequestQuerySort;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetLogStreamDefinition {
    /**
     * Stringified list of columns to use, for example: `["column1","column2","column3"]`.
     */
    columns?: string[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
     */
    messageDisplay?: string;
    /**
     * The query to use in the widget.
     */
    query?: string;
    /**
     * If the date column should be displayed.
     */
    showDateColumn?: boolean;
    /**
     * If the message column should be displayed.
     */
    showMessageColumn?: boolean;
    /**
     * The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
     */
    sort?: outputs.PowerpackWidgetLogStreamDefinitionSort;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetLogStreamDefinitionSort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetManageStatusDefinition {
    /**
     * Whether to colorize text or background. Valid values are `background`, `text`.
     */
    colorPreference?: string;
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * A Boolean indicating whether to hide empty categories.
     */
    hideZeroCounts?: boolean;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * A Boolean indicating whether to show when monitors/groups last triggered.
     */
    showLastTriggered?: boolean;
    /**
     * Whether to show the priorities column.
     */
    showPriority?: boolean;
    /**
     * The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
     */
    sort?: string;
    /**
     * The summary type to use. Valid values are `monitors`, `groups`, `combined`.
     */
    summaryType?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetNoteDefinition {
    /**
     * The background color of the note.
     */
    backgroundColor?: string;
    /**
     * The content of the note.
     */
    content: string;
    /**
     * The size of the text.
     */
    fontSize?: string;
    /**
     * Whether to add padding or not. Defaults to `true`.
     */
    hasPadding?: boolean;
    /**
     * Whether to show a tick or not.
     */
    showTick?: boolean;
    /**
     * The alignment of the widget's text. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
     */
    tickEdge?: string;
    /**
     * When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tickPos = "50%"` is centered alignment.
     */
    tickPos?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface PowerpackWidgetQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequest {
    /**
     * The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The alias for the column name (defaults to metric name).
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormula[];
    /**
     * The number of lines to show in the table.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQuery;
    /**
     * The sort order for the rows. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * The environment name.
     */
    env: string;
    /**
     * The operation name associated with the service.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * The service name.
     */
    service: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * A user-assigned alias for the column.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The column name.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the tile.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetQueryValueDefinitionRequest[];
    /**
     * The alignment of the widget's text. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequest {
    /**
     * The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    yaxis?: outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetRunWorkflowDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetRunWorkflowDefinitionCustomLink[];
    /**
     * Array of workflow inputs to map to dashboard template variables.
     */
    inputs?: outputs.PowerpackWidgetRunWorkflowDefinitionInput[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Workflow ID
     */
    workflowId: string;
}

export interface PowerpackWidgetRunWorkflowDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetRunWorkflowDefinitionInput {
    /**
     * Name of the workflow input.
     */
    name: string;
    /**
     * Dashboard template variable. Can be suffixed with `.value` or `.key`.
     */
    value: string;
}

export interface PowerpackWidgetScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
     */
    request?: outputs.PowerpackWidgetScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.PowerpackWidgetScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    yaxis?: outputs.PowerpackWidgetScatterplotDefinitionYaxis;
}

export interface PowerpackWidgetScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.PowerpackWidgetScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.PowerpackWidgetScatterplotDefinitionRequestY[];
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestX {
    /**
     * Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestY {
    /**
     * Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetServiceLevelObjectiveDefinition {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The global time target of the widget.
     */
    globalTimeTarget?: string;
    /**
     * Whether to show the error budget or not.
     */
    showErrorBudget?: boolean;
    /**
     * The ID of the service level objective used by the widget.
     */
    sloId: string;
    /**
     * A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `weekToDate`, `previousWeek`, `monthToDate`, `previousMonth`, `globalTime`.
     */
    timeWindows: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view mode for the widget. Valid values are `overall`, `component`, `both`.
     */
    viewMode: string;
    /**
     * The type of view to use when displaying the widget. Only `detail` is supported.
     */
    viewType: string;
}

export interface PowerpackWidgetServicemapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetServicemapDefinitionCustomLink[];
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * The ID of the service to map.
     */
    service: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetServicemapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetSloListDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
     */
    request: outputs.PowerpackWidgetSloListDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetSloListDefinitionRequest {
    /**
     * Updated SLO List widget.
     */
    query: outputs.PowerpackWidgetSloListDefinitionRequestQuery;
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface PowerpackWidgetSloListDefinitionRequestQuery {
    /**
     * Maximum number of results to display in the table. Defaults to `100`.
     */
    limit?: number;
    /**
     * Widget query.
     */
    queryString: string;
    /**
     * The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
     */
    sort?: outputs.PowerpackWidgetSloListDefinitionRequestQuerySort;
}

export interface PowerpackWidgetSloListDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinition {
    /**
     * Nested block describing a custom link. Multiple `customLink` blocks are allowed with the structure below.
     */
    customLinks?: outputs.PowerpackWidgetSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.PowerpackWidgetSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.PowerpackWidgetSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `logQuery` or `rumQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title. Default is 16.
     */
    titleSize?: string;
}

export interface PowerpackWidgetSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Whether to hide the values of the groups.
     */
    hideValue?: boolean;
    /**
     * The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
     */
    type: string;
}

export interface PowerpackWidgetSunburstDefinitionLegendTable {
    /**
     * The type of legend (table or none). Valid values are `table`, `none`.
     */
    type: string;
}

export interface PowerpackWidgetSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.PowerpackWidgetSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQuery;
    /**
     * Define style for the widget's request.
     */
    style?: outputs.PowerpackWidgetSunburstDefinitionRequestStyle;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface PowerpackWidgetTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.PowerpackWidgetTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.PowerpackWidgetTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `networkQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.PowerpackWidgetTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetTimeseriesDefinitionYaxis;
}

export interface PowerpackWidgetTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionEvent {
    /**
     * The event query to use in the widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters.
     */
    tagsExecution?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * A label for the line or range.
     */
    label?: string;
    /**
     * A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
     */
    value: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQuery;
    /**
     * How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
     */
    displayType?: string;
    formulas?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.PowerpackWidgetTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery;
    /**
     * The style of the widget graph. Exactly one `style` block is allowed using the structure below.
     */
    style?: outputs.PowerpackWidgetTimeseriesDefinitionRequestStyle;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label of the axis to display on the graph.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the `request` block).
     */
    requests?: outputs.PowerpackWidgetToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQuery;
    /**
     * Define request for the widget's style.
     */
    style?: outputs.PowerpackWidgetToplistDefinitionRequestStyle;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The max number of items in the filter list.
     */
    limit?: number;
    /**
     * Your chosen metric.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestStyle {
    /**
     * A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
     */
    palette?: string;
}

export interface PowerpackWidgetTopologyMapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetTopologyMapDefinitionCustomLink[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `requestType` are required within the request).
     */
    requests?: outputs.PowerpackWidgetTopologyMapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetTopologyMapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetTopologyMapDefinitionRequest {
    /**
     * The query for a Topology request.
     */
    queries: outputs.PowerpackWidgetTopologyMapDefinitionRequestQuery[];
    /**
     * The request type for the Topology request ('topology'). Valid values are `topology`.
     */
    requestType: string;
}

export interface PowerpackWidgetTopologyMapDefinitionRequestQuery {
    /**
     * The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `dataStreams`, `serviceMap`.
     */
    dataSource: string;
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * The ID of the service to map.
     */
    service: string;
}

export interface PowerpackWidgetTraceServiceDefinition {
    /**
     * The number of columns to display. Valid values are `oneColumn`, `twoColumn`, `threeColumn`.
     */
    displayFormat?: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * Whether to show the latency breakdown or not.
     */
    showBreakdown?: boolean;
    /**
     * Whether to show the latency distribution or not.
     */
    showDistribution?: boolean;
    /**
     * Whether to show the error metrics or not.
     */
    showErrors?: boolean;
    /**
     * Whether to show the hits metrics or not
     */
    showHits?: boolean;
    /**
     * Whether to show the latency metrics or not.
     */
    showLatency?: boolean;
    /**
     * Whether to show the resource list or not.
     */
    showResourceList?: boolean;
    /**
     * The size of the widget. Valid values are `small`, `medium`, `large`.
     */
    sizeFormat?: string;
    /**
     * APM span name
     */
    spanName: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetTreemapDefinition {
    /**
     * Nested block describing the request to use when displaying the widget.
     */
    requests?: outputs.PowerpackWidgetTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequest {
    formulas?: outputs.PowerpackWidgetTreemapDefinitionRequestFormula[];
    queries?: outputs.PowerpackWidgetTreemapDefinitionRequestQuery[];
}

export interface PowerpackWidgetTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The options for limiting results returned.
     */
    limit?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    order?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query using formulas and functions.
     */
    processQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Resource Stats queries. Valid values are `apmResourceStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Array of fields to group results by.
     */
    groupBies?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `errors`, `errorRate`, `hits`, `latencyAvg`, `latencyDistribution`, `latencyMax`, `latencyP50`, `latencyP75`, `latencyP90`, `latencyP95`, `latencyP99`.
     */
    stat: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for cloud cost queries. Valid values are `cloudCost`.
     */
    dataSource: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `securitySignals`, `profiles`, `audit`, `events`, `ciTests`, `ciPipelines`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The metric used for sorting group by results.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for process queries. Valid values are `process`, `container`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The number of hits to return.
     */
    limit?: number;
    /**
     * The process metric name.
     */
    metric: string;
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for SLO queries. Valid values are `slo`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of query for use in formulas.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
     */
    y: number;
}

export interface RestrictionPolicyBinding {
    /**
     * An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
     */
    principals: string[];
    /**
     * The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
     */
    relation: string;
}

export interface RolePermission {
    /**
     * ID of the permission to assign.
     */
    id: string;
    /**
     * Name of the permission.
     */
    name: string;
}

export interface SecurityMonitoringDefaultRuleCase {
    /**
     * Notification targets for each rule case.
     */
    notifications: string[];
    /**
     * Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SecurityMonitoringDefaultRuleFilter {
    /**
     * The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface SecurityMonitoringDefaultRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`. Defaults to `false`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
}

export interface SecurityMonitoringFilterExclusionFilter {
    /**
     * Exclusion filter name.
     */
    name: string;
    /**
     * Exclusion filter query. Logs that match this query are excluded from the security filter.
     */
    query: string;
}

export interface SecurityMonitoringRuleCase {
    /**
     * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
     */
    condition?: string;
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SecurityMonitoringRuleFilter {
    /**
     * The type of filtering action. Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface SecurityMonitoringRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`. Defaults to `false`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
    /**
     * The detection method. Valid values are `threshold`, `newValue`, `anomalyDetection`, `impossibleTravel`, `hardcoded`, `thirdParty`. Defaults to `"threshold"`.
     */
    detectionMethod?: string;
    /**
     * A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
     */
    evaluationWindow?: number;
    /**
     * Options for rules using the impossible travel detection method.
     */
    impossibleTravelOptions?: outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions;
    /**
     * Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
     */
    keepAlive?: number;
    /**
     * A signal will “close” regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
     */
    maxSignalDuration?: number;
    /**
     * New value rules specific options.
     */
    newValueOptions?: outputs.SecurityMonitoringRuleOptionsNewValueOptions;
    /**
     * Options for rules using the third-party detection method.
     */
    thirdPartyRuleOptions?: outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptions;
}

export interface SecurityMonitoringRuleOptionsImpossibleTravelOptions {
    /**
     * If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
     */
    baselineUserLocations?: boolean;
}

export interface SecurityMonitoringRuleOptionsNewValueOptions {
    /**
     * The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
     */
    forgetAfter: number;
    /**
     * The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
     */
    learningDuration?: number;
    /**
     * The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
     */
    learningMethod?: string;
    /**
     * A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
     */
    learningThreshold?: number;
}

export interface SecurityMonitoringRuleOptionsThirdPartyRuleOptions {
    /**
     * Notification targets for the default rule case, when none of the third-party cases match.
     */
    defaultNotifications?: string[];
    /**
     * Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    defaultStatus: string;
    /**
     * Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
     */
    rootQueries: outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery[];
    /**
     * A template for the signal title; if omitted, the title is generated based on the case name.
     */
    signalTitleTemplate?: string;
}

export interface SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery {
    /**
     * Fields to group by. If empty, each log triggers a signal.
     */
    groupByFields?: string[];
    /**
     * Query to filter logs.
     */
    query: string;
}

export interface SecurityMonitoringRuleQuery {
    /**
     * **Deprecated**. It won't be applied anymore. **Deprecated.** `agentRule` has been deprecated in favor of new Agent Rule resource.
     *
     * @deprecated `agentRule` has been deprecated in favor of new Agent Rule resource.
     */
    agentRules?: outputs.SecurityMonitoringRuleQueryAgentRule[];
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `newValue`, `geoData`, `eventCount`, `none`. Defaults to `"count"`.
     */
    aggregation?: string;
    /**
     * Field for which the cardinality is measured. Sent as an array.
     */
    distinctFields?: string[];
    /**
     * Fields to group by.
     */
    groupByFields?: string[];
    /**
     * The target field to aggregate over when using the `sum`, `max`, or `geoData` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     *
     * @deprecated Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     */
    metric?: string;
    /**
     * Group of target fields to aggregate over when using the `sum`, `max`, `geoData`, or `newValue` aggregations. The `sum`, `max`, and `geoData` aggregations only accept one value in this list, whereas the `newValue` aggregation accepts up to five values.
     */
    metrics: string[];
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Query to run on logs.
     */
    query: string;
}

export interface SecurityMonitoringRuleQueryAgentRule {
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    agentRuleId: string;
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    expression: string;
}

export interface SecurityMonitoringRuleSignalQuery {
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `newValue`, `geoData`, `eventCount`, `none`. Defaults to `"eventCount"`.
     */
    aggregation?: string;
    /**
     * Fields to correlate by.
     */
    correlatedByFields?: string[];
    /**
     * Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
     */
    correlatedQueryIndex?: string;
    /**
     * Default Rule ID of the signal to correlate. This value is READ-ONLY.
     */
    defaultRuleId?: string;
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Rule ID of the signal to correlate.
     */
    ruleId: string;
}

export interface SecurityMonitoringRuleThirdPartyCase {
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * A query to associate a third-party event to this case.
     */
    query?: string;
    /**
     * Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SensitiveDataScannerGroupFilter {
    /**
     * Query to filter the events.
     */
    query: string;
}

export interface SensitiveDataScannerRuleIncludedKeywordConfiguration {
    /**
     * Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
     */
    characterCount: number;
    /**
     * Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
     */
    keywords: string[];
}

export interface SensitiveDataScannerRuleTextReplacement {
    /**
     * Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
     */
    numberOfChars?: number;
    /**
     * Required if type == 'replacement_string'.
     */
    replacementString?: string;
    /**
     * Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacementString`, `partialReplacementFromBeginning`, `partialReplacementFromEnd`.
     */
    type: string;
}

export interface ServiceLevelObjectiveQuery {
    /**
     * The sum of the `total` events.
     */
    denominator: string;
    /**
     * The sum of all the `good` events.
     */
    numerator: string;
}

export interface ServiceLevelObjectiveSliSpecification {
    /**
     * The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold. Optionally, a fourth part, the query interval, can be provided.
     */
    timeSlice: outputs.ServiceLevelObjectiveSliSpecificationTimeSlice;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSlice {
    /**
     * The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
     */
    query: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQuery;
    /**
     * The interval used when querying data, which defines the size of a time slice. Valid values are `60`, `300`. Defaults to `300`.
     */
    queryIntervalSeconds?: number;
    /**
     * The threshold value to which each SLI value will be compared.
     */
    threshold: number;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQuery {
    /**
     * A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
     */
    formula: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula;
    /**
     * A list of data-source-specific queries that are in the formula.
     */
    queries: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery[];
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula {
    /**
     * The formula string, which is an expression involving named queries.
     */
    formulaExpression: string;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery {
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery {
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface ServiceLevelObjectiveThreshold {
    /**
     * The objective's target in `(0,100)`.
     */
    target: number;
    /**
     * A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
     */
    targetDisplay: string;
    /**
     * The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
     */
    timeframe: string;
    /**
     * The objective's warning value in `(0,100)`. This must be greater than the target value.
     */
    warning?: number;
    /**
     * A string representation of the warning target (see the description of the targetDisplay field for details).
     */
    warningDisplay: string;
}

export interface SpansMetricCompute {
    /**
     * The type of aggregation to use. This field can't be updated after creation.
     */
    aggregationType: string;
    /**
     * Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregationType` is `distribution`.
     */
    includePercentiles?: boolean;
    /**
     * The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
     */
    path?: string;
}

export interface SpansMetricFilter {
    /**
     * The search query - following the span search syntax. Defaults to `"*"`.
     */
    query: string;
}

export interface SpansMetricGroupBy {
    /**
     * The path to the value the span-based metric will be aggregated over.
     */
    path: string;
    /**
     * Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
     */
    tagName: string;
}

export interface SyntheticsGlobalVariableOptions {
    /**
     * Parameters needed for MFA/TOTP.
     */
    totpParameters?: outputs.SyntheticsGlobalVariableOptionsTotpParameters;
}

export interface SyntheticsGlobalVariableOptionsTotpParameters {
    /**
     * Number of digits for the OTP.
     */
    digits: number;
    /**
     * Interval for which to refresh the token (in seconds).
     */
    refreshInterval: number;
}

export interface SyntheticsGlobalVariableParseTestOptions {
    /**
     * Required when type = `httpHeader`. Defines the header to use to extract the value
     */
    field?: string;
    /**
     * When type is `localVariable`, name of the local variable to use to extract the value.
     */
    localVariableName?: string;
    parser?: outputs.SyntheticsGlobalVariableParseTestOptionsParser;
    /**
     * Defines the source to use to extract the value. Valid values are `httpBody`, `httpHeader`, `localVariable`.
     */
    type: string;
}

export interface SyntheticsGlobalVariableParseTestOptionsParser {
    /**
     * Type of parser to extract the value. Valid values are `raw`, `jsonPath`, `regex`, `xPath`.
     */
    type: string;
    /**
     * Value for the parser to use, required for type `jsonPath` or `regex`.
     */
    value?: string;
}

export interface SyntheticsPrivateLocationMetadata {
    /**
     * A list of role identifiers pulled from the Roles API to restrict read and write access.
     */
    restrictedRoles?: string[];
}

export interface SyntheticsTestApiStep {
    /**
     * Determines whether or not to continue with test if this step fails.
     */
    allowFailure?: boolean;
    /**
     * Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
     */
    assertions?: outputs.SyntheticsTestApiStepAssertion[];
    /**
     * Values to parse and save as variables from the response.
     */
    extractedValues?: outputs.SyntheticsTestApiStepExtractedValue[];
    /**
     * Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allowFailure` is `true`.
     */
    isCritical?: boolean;
    /**
     * The name of the step.
     */
    name: string;
    /**
     * The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
     */
    requestBasicauth?: outputs.SyntheticsTestApiStepRequestBasicauth;
    /**
     * Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
     */
    requestClientCertificate?: outputs.SyntheticsTestApiStepRequestClientCertificate;
    /**
     * The request for the api step.
     */
    requestDefinition?: outputs.SyntheticsTestApiStepRequestDefinition;
    /**
     * Files to be used as part of the request in the test.
     */
    requestFiles?: outputs.SyntheticsTestApiStepRequestFile[];
    /**
     * Header name and value map.
     */
    requestHeaders?: {[key: string]: any};
    /**
     * The proxy to perform the test.
     */
    requestProxy?: outputs.SyntheticsTestApiStepRequestProxy;
    /**
     * Query arguments name and value map.
     */
    requestQuery?: {[key: string]: any};
    retry?: outputs.SyntheticsTestApiStepRetry;
    /**
     * The subtype of the Synthetic multi-step API test step. Valid values are `http`, `grpc`, `wait`. Defaults to `"http"`.
     */
    subtype?: string;
    /**
     * The time to wait in seconds. Minimum value: 0. Maximum value: 180.
     */
    value?: number;
}

export interface SyntheticsTestApiStepAssertion {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * If assertion type is `header`, this is the header name.
     */
    property?: string;
    /**
     * Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
     */
    target?: string;
    /**
     * Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonpath?: outputs.SyntheticsTestApiStepAssertionTargetjsonpath;
    /**
     * Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonschema?: outputs.SyntheticsTestApiStepAssertionTargetjsonschema;
    /**
     * Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
     */
    targetxpath?: outputs.SyntheticsTestApiStepAssertionTargetxpath;
    /**
     * Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
     */
    timingsScope?: string;
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`.
     */
    type: string;
}

export interface SyntheticsTestApiStepAssertionTargetjsonpath {
    /**
     * The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
     */
    elementsoperator?: string;
    /**
     * The JSON path to assert.
     */
    jsonpath: string;
    /**
     * The specific operator to use on the path.
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
}

export interface SyntheticsTestApiStepAssertionTargetjsonschema {
    /**
     * The JSON Schema to validate the body against.
     */
    jsonschema: string;
    /**
     * The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
     */
    metaschema?: string;
}

export interface SyntheticsTestApiStepAssertionTargetxpath {
    /**
     * The specific operator to use on the path.
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
    /**
     * The xpath to assert.
     */
    xpath: string;
}

export interface SyntheticsTestApiStepExtractedValue {
    /**
     * When type is `httpHeader`, name of the header to use to extract the value.
     */
    field?: string;
    name: string;
    parser: outputs.SyntheticsTestApiStepExtractedValueParser;
    /**
     * Determines whether or not the extracted value will be obfuscated.
     */
    secure?: boolean;
    /**
     * Property of the Synthetics Test Response to use for the variable. Valid values are `httpBody`, `httpHeader`, `localVariable`.
     */
    type: string;
}

export interface SyntheticsTestApiStepExtractedValueParser {
    /**
     * Type of parser for a Synthetics global variable from a synthetics test. Valid values are `raw`, `jsonPath`, `regex`, `xPath`.
     */
    type: string;
    /**
     * Regex or JSON path used for the parser. Not used with type `raw`.
     */
    value?: string;
}

export interface SyntheticsTestApiStepRequestBasicauth {
    /**
     * Access key for `SIGV4` authentication.
     */
    accessKey?: string;
    /**
     * Access token url for `oauth-client` or `oauth-rop` authentication.
     */
    accessTokenUrl?: string;
    /**
     * Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    audience?: string;
    /**
     * Client ID for `oauth-client` or `oauth-rop` authentication.
     */
    clientId?: string;
    /**
     * Client secret for `oauth-client` or `oauth-rop` authentication.
     */
    clientSecret?: string;
    /**
     * Domain for `ntlm` authentication.
     */
    domain?: string;
    /**
     * Password for authentication.
     */
    password?: string;
    /**
     * Region for `SIGV4` authentication.
     */
    region?: string;
    /**
     * Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    resource?: string;
    /**
     * Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    scope?: string;
    /**
     * Secret key for `SIGV4` authentication.
     */
    secretKey?: string;
    /**
     * Service name for `SIGV4` authentication.
     */
    serviceName?: string;
    /**
     * Session token for `SIGV4` authentication.
     */
    sessionToken?: string;
    /**
     * Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
     */
    tokenApiAuthentication?: string;
    /**
     * Type of basic authentication to use when performing the test. Defaults to `"web"`.
     */
    type?: string;
    /**
     * Username for authentication.
     */
    username?: string;
    /**
     * Workstation for `ntlm` authentication.
     */
    workstation?: string;
}

export interface SyntheticsTestApiStepRequestClientCertificate {
    cert: outputs.SyntheticsTestApiStepRequestClientCertificateCert;
    key: outputs.SyntheticsTestApiStepRequestClientCertificateKey;
}

export interface SyntheticsTestApiStepRequestClientCertificateCert {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestApiStepRequestClientCertificateKey {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestApiStepRequestDefinition {
    /**
     * Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
     */
    allowInsecure?: boolean;
    /**
     * The request body.
     */
    body?: string;
    /**
     * Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
     */
    bodyType?: string;
    /**
     * The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
     */
    callType?: string;
    /**
     * By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificateDomains`.
     */
    certificateDomains?: string[];
    /**
     * DNS server to use for DNS tests (`subtype = "dns"`).
     */
    dnsServer?: string;
    /**
     * DNS server port to use for DNS tests.
     */
    dnsServerPort?: number;
    /**
     * Determines whether or not the API HTTP test should follow redirects.
     */
    followRedirects?: boolean;
    /**
     * Host name to perform the test with.
     */
    host?: string;
    /**
     * HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
     */
    httpVersion?: string;
    /**
     * For UDP and websocket tests, message to send with the request.
     */
    message?: string;
    /**
     * Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
     */
    method?: string;
    /**
     * Determines whether or not to save the response body.
     */
    noSavingResponseBody?: boolean;
    /**
     * Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
     */
    numberOfPackets?: number;
    /**
     * Persist cookies across redirects.
     */
    persistCookies?: boolean;
    /**
     * The content of a proto file as a string.
     */
    plainProtoFile?: string;
    /**
     * Port to use when performing the test.
     */
    port?: number;
    /**
     * A protobuf JSON descriptor. **Deprecated.** Use `plainProtoFile` instead.
     *
     * @deprecated Use `plainProtoFile` instead.
     */
    protoJsonDescriptor?: string;
    /**
     * For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
     */
    servername?: string;
    /**
     * The gRPC service on which you want to perform the gRPC call.
     */
    service?: string;
    /**
     * This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
     */
    shouldTrackHops?: boolean;
    /**
     * Timeout in seconds for the test. Defaults to `60`.
     */
    timeout?: number;
    /**
     * The URL to send the request to.
     */
    url?: string;
}

export interface SyntheticsTestApiStepRequestFile {
    /**
     * Bucket key of the file.
     */
    bucketKey: string;
    /**
     * Content of the file.
     */
    content?: string;
    /**
     * Name of the file.
     */
    name: string;
    /**
     * Original name of the file.
     */
    originalFileName?: string;
    /**
     * Size of the file.
     */
    size: number;
    /**
     * Type of the file.
     */
    type: string;
}

export interface SyntheticsTestApiStepRequestProxy {
    /**
     * Header name and value map.
     */
    headers?: {[key: string]: any};
    /**
     * URL of the proxy to perform the test.
     */
    url: string;
}

export interface SyntheticsTestApiStepRetry {
    /**
     * Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
     */
    count?: number;
    /**
     * Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
     */
    interval?: number;
}

export interface SyntheticsTestAssertion {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * If assertion type is `header`, this is the header name.
     */
    property?: string;
    /**
     * Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
     */
    target?: string;
    /**
     * Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonpath?: outputs.SyntheticsTestAssertionTargetjsonpath;
    /**
     * Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonschema?: outputs.SyntheticsTestAssertionTargetjsonschema;
    /**
     * Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
     */
    targetxpath?: outputs.SyntheticsTestAssertionTargetxpath;
    /**
     * Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
     */
    timingsScope?: string;
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`.
     */
    type: string;
}

export interface SyntheticsTestAssertionTargetjsonpath {
    /**
     * The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
     */
    elementsoperator?: string;
    /**
     * The JSON path to assert.
     */
    jsonpath: string;
    /**
     * The specific operator to use on the path.
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
}

export interface SyntheticsTestAssertionTargetjsonschema {
    /**
     * The JSON Schema to validate the body against.
     */
    jsonschema: string;
    /**
     * The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
     */
    metaschema?: string;
}

export interface SyntheticsTestAssertionTargetxpath {
    /**
     * The specific operator to use on the path.
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
    /**
     * The xpath to assert.
     */
    xpath: string;
}

export interface SyntheticsTestBrowserStep {
    /**
     * Determines if the step should be allowed to fail.
     */
    allowFailure?: boolean;
    /**
     * Force update of the "element" parameter for the step
     */
    forceElementUpdate?: boolean;
    /**
     * Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allowFailure` is `true`.
     */
    isCritical?: boolean;
    /**
     * Name of the step.
     */
    name: string;
    /**
     * Prevents saving screenshots of the step.
     */
    noScreenshot?: boolean;
    /**
     * Parameters for the step.
     */
    params: outputs.SyntheticsTestBrowserStepParams;
    /**
     * Used to override the default timeout of a step.
     */
    timeout?: number;
    /**
     * Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
     */
    type: string;
}

export interface SyntheticsTestBrowserStepParams {
    /**
     * Name of the attribute to use for an "assert attribute" step.
     */
    attribute?: string;
    /**
     * Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
     */
    check?: string;
    /**
     * Type of click to use for a "click" step.
     */
    clickType?: string;
    /**
     * Javascript code to use for the step.
     */
    code?: string;
    /**
     * Delay between each key stroke for a "type test" step.
     */
    delay?: number;
    /**
     * Element to use for the step, JSON encoded string.
     */
    element?: string;
    /**
     * Custom user selector to use for the step.
     */
    elementUserLocator?: outputs.SyntheticsTestBrowserStepParamsElementUserLocator;
    /**
     * Details of the email for an "assert email" step, JSON encoded string.
     */
    email?: string;
    /**
     * JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
     */
    file?: string;
    /**
     * Details of the files for an "upload files" step, JSON encoded string.
     */
    files?: string;
    /**
     * Modifier to use for a "press key" step.
     */
    modifiers?: string[];
    /**
     * ID of the tab to play the subtest.
     */
    playingTabId?: string;
    /**
     * Request for an API step.
     */
    request?: string;
    /**
     * ID of the Synthetics test to use as subtest.
     */
    subtestPublicId?: string;
    /**
     * Value of the step.
     */
    value?: string;
    /**
     * Details of the variable to extract.
     */
    variable?: outputs.SyntheticsTestBrowserStepParamsVariable;
    /**
     * For "file upload" steps.
     */
    withClick?: boolean;
    /**
     * X coordinates for a "scroll step".
     */
    x?: number;
    /**
     * Y coordinates for a "scroll step".
     */
    y?: number;
}

export interface SyntheticsTestBrowserStepParamsElementUserLocator {
    /**
     * Defaults to `false`.
     */
    failTestOnCannotLocate?: boolean;
    value: outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue;
}

export interface SyntheticsTestBrowserStepParamsElementUserLocatorValue {
    /**
     * Defaults to `"css"`.
     */
    type?: string;
    value: string;
}

export interface SyntheticsTestBrowserStepParamsVariable {
    /**
     * Example of the extracted variable. Defaults to `""`.
     */
    example?: string;
    /**
     * Name of the extracted variable.
     */
    name?: string;
}

export interface SyntheticsTestBrowserVariable {
    /**
     * Example for the variable. Defaults to `""`.
     */
    example?: string;
    /**
     * ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
     */
    id?: string;
    /**
     * Name of the variable.
     */
    name: string;
    /**
     * Pattern of the variable. Defaults to `""`.
     */
    pattern?: string;
    /**
     * Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
     */
    secure?: boolean;
    /**
     * Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
     */
    type: string;
}

export interface SyntheticsTestConfigVariable {
    example?: string;
    /**
     * When type = `global`, ID of the global variable to use.
     */
    id?: string;
    /**
     * Name of the variable.
     */
    name: string;
    pattern?: string;
    /**
     * Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
     */
    secure?: boolean;
    /**
     * Type of test configuration variable. Valid values are `global`, `text`.
     */
    type: string;
}

export interface SyntheticsTestOptionsList {
    /**
     * For SSL test, whether or not the test should allow self signed certificates.
     */
    acceptSelfSigned?: boolean;
    /**
     * Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
     */
    allowInsecure?: boolean;
    /**
     * For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
     */
    checkCertificateRevocation?: boolean;
    /**
     * CI/CD options for a Synthetic test.
     */
    ci?: outputs.SyntheticsTestOptionsListCi;
    /**
     * Disable Cross-Origin Resource Sharing for browser tests.
     */
    disableCors?: boolean;
    /**
     * Disable Content Security Policy for browser tests.
     */
    disableCsp?: boolean;
    /**
     * Determines whether or not the API HTTP test should follow redirects.
     */
    followRedirects?: boolean;
    /**
     * HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
     */
    httpVersion?: string;
    /**
     * Ignore server certificate error for browser tests.
     */
    ignoreServerCertificateError?: boolean;
    /**
     * Timeout before declaring the initial step as failed (in seconds) for browser tests.
     */
    initialNavigationTimeout?: number;
    /**
     * Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
     */
    minFailureDuration?: number;
    /**
     * Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
     */
    minLocationFailed?: number;
    /**
     * The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
     */
    monitorName?: string;
    monitorOptions?: outputs.SyntheticsTestOptionsListMonitorOptions;
    monitorPriority?: number;
    /**
     * Prevents saving screenshots of the steps.
     */
    noScreenshot?: boolean;
    /**
     * A list of role identifiers pulled from the Roles API to restrict read and write access.
     */
    restrictedRoles?: string[];
    retry?: outputs.SyntheticsTestOptionsListRetry;
    /**
     * The RUM data collection settings for the Synthetic browser test.
     */
    rumSettings?: outputs.SyntheticsTestOptionsListRumSettings;
    /**
     * Object containing timeframes and timezone used for advanced scheduling.
     */
    scheduling?: outputs.SyntheticsTestOptionsListScheduling;
    /**
     * How often the test should run (in seconds).
     */
    tickEvery: number;
}

export interface SyntheticsTestOptionsListCi {
    /**
     * Execution rule for a Synthetics test. Valid values are `blocking`, `nonBlocking`, `skipped`.
     */
    executionRule?: string;
}

export interface SyntheticsTestOptionsListMonitorOptions {
    /**
     * Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
     */
    renotifyInterval?: number;
}

export interface SyntheticsTestOptionsListRetry {
    /**
     * Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
     */
    count?: number;
    /**
     * Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
     */
    interval?: number;
}

export interface SyntheticsTestOptionsListRumSettings {
    /**
     * RUM application ID used to collect RUM data for the browser test.
     */
    applicationId?: string;
    /**
     * RUM application API key ID used to collect RUM data for the browser test.
     */
    clientTokenId?: number;
    /**
     * Determines whether RUM data is collected during test runs.
     */
    isEnabled: boolean;
}

export interface SyntheticsTestOptionsListScheduling {
    /**
     * Array containing objects describing the scheduling pattern to apply to each day.
     */
    timeframes: outputs.SyntheticsTestOptionsListSchedulingTimeframe[];
    /**
     * Timezone in which the timeframe is based.
     */
    timezone: string;
}

export interface SyntheticsTestOptionsListSchedulingTimeframe {
    /**
     * Number representing the day of the week
     */
    day: number;
    /**
     * The hour of the day on which scheduling starts.
     */
    from: string;
    /**
     * The hour of the day on which scheduling ends.
     */
    to: string;
}

export interface SyntheticsTestRequestBasicauth {
    /**
     * Access key for `SIGV4` authentication.
     */
    accessKey?: string;
    /**
     * Access token url for `oauth-client` or `oauth-rop` authentication.
     */
    accessTokenUrl?: string;
    /**
     * Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    audience?: string;
    /**
     * Client ID for `oauth-client` or `oauth-rop` authentication.
     */
    clientId?: string;
    /**
     * Client secret for `oauth-client` or `oauth-rop` authentication.
     */
    clientSecret?: string;
    /**
     * Domain for `ntlm` authentication.
     */
    domain?: string;
    /**
     * Password for authentication.
     */
    password?: string;
    /**
     * Region for `SIGV4` authentication.
     */
    region?: string;
    /**
     * Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    resource?: string;
    /**
     * Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    scope?: string;
    /**
     * Secret key for `SIGV4` authentication.
     */
    secretKey?: string;
    /**
     * Service name for `SIGV4` authentication.
     */
    serviceName?: string;
    /**
     * Session token for `SIGV4` authentication.
     */
    sessionToken?: string;
    /**
     * Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
     */
    tokenApiAuthentication?: string;
    /**
     * Type of basic authentication to use when performing the test. Defaults to `"web"`.
     */
    type?: string;
    /**
     * Username for authentication.
     */
    username?: string;
    /**
     * Workstation for `ntlm` authentication.
     */
    workstation?: string;
}

export interface SyntheticsTestRequestClientCertificate {
    cert: outputs.SyntheticsTestRequestClientCertificateCert;
    key: outputs.SyntheticsTestRequestClientCertificateKey;
}

export interface SyntheticsTestRequestClientCertificateCert {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestRequestClientCertificateKey {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestRequestDefinition {
    /**
     * The request body.
     */
    body?: string;
    /**
     * Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
     */
    bodyType?: string;
    /**
     * The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
     */
    callType?: string;
    /**
     * By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificateDomains`.
     */
    certificateDomains?: string[];
    /**
     * DNS server to use for DNS tests (`subtype = "dns"`).
     */
    dnsServer?: string;
    /**
     * DNS server port to use for DNS tests.
     */
    dnsServerPort?: number;
    /**
     * Host name to perform the test with.
     */
    host?: string;
    /**
     * HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`.
     */
    httpVersion?: string;
    /**
     * For UDP and websocket tests, message to send with the request.
     */
    message?: string;
    /**
     * Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
     */
    method?: string;
    /**
     * Determines whether or not to save the response body.
     */
    noSavingResponseBody?: boolean;
    /**
     * Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
     */
    numberOfPackets?: number;
    /**
     * Persist cookies across redirects.
     */
    persistCookies?: boolean;
    /**
     * The content of a proto file as a string.
     */
    plainProtoFile?: string;
    /**
     * Port to use when performing the test.
     */
    port?: number;
    /**
     * A protobuf JSON descriptor. **Deprecated.** Use `plainProtoFile` instead.
     *
     * @deprecated Use `plainProtoFile` instead.
     */
    protoJsonDescriptor?: string;
    /**
     * For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
     */
    servername?: string;
    /**
     * The gRPC service on which you want to perform the gRPC call.
     */
    service?: string;
    /**
     * This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
     */
    shouldTrackHops?: boolean;
    /**
     * Timeout in seconds for the test. Defaults to `60`.
     */
    timeout?: number;
    /**
     * The URL to send the request to.
     */
    url?: string;
}

export interface SyntheticsTestRequestFile {
    /**
     * Bucket key of the file.
     */
    bucketKey: string;
    /**
     * Content of the file.
     */
    content?: string;
    /**
     * Name of the file.
     */
    name: string;
    /**
     * Original name of the file.
     */
    originalFileName?: string;
    /**
     * Size of the file.
     */
    size: number;
    /**
     * Type of the file.
     */
    type: string;
}

export interface SyntheticsTestRequestProxy {
    /**
     * Header name and value map.
     */
    headers?: {[key: string]: any};
    /**
     * URL of the proxy to perform the test.
     */
    url: string;
}

export namespace aws {
    export interface GetIntegrationLogsServicesAwsLogsService {
        /**
         * The id of the AWS log service.
         */
        id: string;
        /**
         * The name of the AWS log service.
         */
        label: string;
    }

}

export namespace slack {
    export interface ChannelDisplay {
        /**
         * Show the main body of the alert event. Defaults to `true`.
         */
        message?: boolean;
        /**
         * Show the list of @-handles in the alert event. Defaults to `true`.
         */
        notified?: boolean;
        /**
         * Show the alert event's snapshot image. Defaults to `true`.
         */
        snapshot?: boolean;
        /**
         * Show the scopes on which the monitor alerted. Defaults to `true`.
         */
        tags?: boolean;
    }

}

// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApmRetentionFilterFilter {
    /**
     * The search query - following the span search syntax. Defaults to `"*"`.
     */
    query: string;
}

export interface ChildOrganizationApiKey {
    /**
     * API key.
     */
    key: string;
    /**
     * Name of your API key.
     */
    name: string;
}

export interface ChildOrganizationApplicationKey {
    /**
     * Hash of an application key.
     */
    hash: string;
    /**
     * Name of an application key.
     */
    name: string;
    /**
     * Owner of an application key.
     */
    owner: string;
}

export interface ChildOrganizationSetting {
    /**
     * Whether or not the organization users can share widgets outside of Datadog.
     */
    privateWidgetShare: boolean;
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
     */
    samlAutocreateAccessRole: string;
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    samlAutocreateUsersDomains: outputs.ChildOrganizationSettingSamlAutocreateUsersDomain[];
    /**
     * Whether or not SAML can be enabled for this organization.
     */
    samlCanBeEnabled: boolean;
    /**
     * Identity provider endpoint for SAML authentication.
     */
    samlIdpEndpoint: string;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpInitiatedLogins: outputs.ChildOrganizationSettingSamlIdpInitiatedLogin[];
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpMetadataUploaded: boolean;
    /**
     * URL for SAML logging.
     */
    samlLoginUrl: string;
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    samlStrictModes: outputs.ChildOrganizationSettingSamlStrictMode[];
    /**
     * SAML properties
     */
    samls: outputs.ChildOrganizationSettingSaml[];
}

export interface ChildOrganizationSettingSaml {
    /**
     * Whether or not SAML is enabled for this organization.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlAutocreateUsersDomain {
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    domains: string[];
    /**
     * Whether or not the automated user creation based on SAML domain is enabled.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlIdpInitiatedLogin {
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    enabled: boolean;
}

export interface ChildOrganizationSettingSamlStrictMode {
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    enabled: boolean;
}

export interface ChildOrganizationUser {
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
     */
    accessRole: string;
    /**
     * The new email of the user.
     */
    email: string;
    /**
     * The name of the user.
     */
    name: string;
}

export interface CloudConfigurationRuleFilter {
    /**
     * The type of filtering action. Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface DashboardListDashItem {
    /**
     * The ID of the dashboard to add
     */
    dashId: string;
    /**
     * The type of this dashboard. Valid values are `customTimeboard`, `customScreenboard`, `integrationScreenboard`, `integrationTimeboard`, `hostTimeboard`.
     */
    type: string;
}

export interface DashboardTemplateVariable {
    /**
     * The list of values that the template variable drop-down is be limited to
     */
    availableValues?: string[];
    /**
     * The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
     *
     * @deprecated Use `defaults` instead.
     */
    default?: string;
    /**
     * One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
     */
    defaults?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
}

export interface DashboardTemplateVariablePreset {
    /**
     * The name of the preset.
     */
    name?: string;
    /**
     * The template variable names and assumed values under the given preset
     */
    templateVariables?: outputs.DashboardTemplateVariablePresetTemplateVariable[];
}

export interface DashboardTemplateVariablePresetTemplateVariable {
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     *
     * @deprecated Use `values` instead.
     */
    value?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values?: string[];
}

export interface DashboardWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.DashboardWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.DashboardWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.DashboardWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.DashboardWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.DashboardWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.DashboardWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.DashboardWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGeomapDefinition;
    /**
     * The definition for a Group widget.
     */
    groupDefinition?: outputs.DashboardWidgetGroupDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.DashboardWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.DashboardWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.DashboardWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.DashboardWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.DashboardWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.DashboardWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.DashboardWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.DashboardWidgetNoteDefinition;
    /**
     * The definition for a Powerpack widget.
     */
    powerpackDefinition?: outputs.DashboardWidgetPowerpackDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.DashboardWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.DashboardWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.DashboardWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.DashboardWidgetSloListDefinition;
    /**
     * The definition for a Split Graph widget.
     */
    splitGraphDefinition?: outputs.DashboardWidgetSplitGraphDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.DashboardWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.DashboardWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.DashboardWidgetWidgetLayout;
}

export interface DashboardWidgetAlertGraphDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
     */
    vizType: string;
}

export interface DashboardWidgetAlertValueDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The unit for the value displayed in the widget.
     */
    unit?: string;
}

export interface DashboardWidgetChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.DashboardWidgetChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface DashboardWidgetChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetCheckStatusDefinition {
    /**
     * The check to use in the widget.
     */
    check: string;
    /**
     * The check group to use in the widget.
     */
    group?: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The kind of grouping to use. Valid values are `check`, `cluster`.
     */
    grouping: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A list of tags to use in the widget.
     */
    tags?: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetDistributionDefinition {
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetDistributionDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetDistributionDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetDistributionDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetDistributionDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetDistributionDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetDistributionDefinitionRequestStyle;
}

export interface DashboardWidgetDistributionDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetDistributionDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetEventStreamDefinition {
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetEventTimelineDefinition {
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetFreeTextDefinition {
    /**
     * The color of the text in the widget.
     */
    color?: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * The text to display in the widget.
     */
    text: string;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
}

export interface DashboardWidgetGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGeomapDefinitionRequest[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.DashboardWidgetGeomapDefinitionView;
}

export interface DashboardWidgetGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGeomapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGeomapDefinitionRequestRumQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGeomapDefinitionStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface DashboardWidgetGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface DashboardWidgetGroupDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The image URL to display as a banner for the group.
     */
    bannerImg?: string;
    /**
     * The layout type of the group. Valid values are `ordered`.
     */
    layoutType: string;
    /**
     * Whether to show the title or not. Defaults to `true`.
     */
    showTitle?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The list of widgets in this group.
     */
    widgets?: outputs.DashboardWidgetGroupDefinitionWidget[];
}

export interface DashboardWidgetGroupDefinitionWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition;
    /**
     * The definition for a Powerpack widget.
     */
    powerpackDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetPowerpackDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinition;
    /**
     * The definition for a Split Graph widget.
     */
    splitGraphDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout;
}

export interface DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
     */
    vizType: string;
}

export interface DashboardWidgetGroupDefinitionWidgetAlertValueDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The unit for the value displayed in the widget.
     */
    unit?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition {
    /**
     * The check to use in the widget.
     */
    check: string;
    /**
     * The check group to use in the widget.
     */
    group?: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The kind of grouping to use. Valid values are `check`, `cluster`.
     */
    grouping: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A list of tags to use in the widget.
     */
    tags?: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinition {
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetEventStreamDefinition {
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition {
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetFreeTextDefinition {
    /**
     * The color of the text in the widget.
     */
    color?: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * The text to display in the widget.
     */
    text: string;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent[];
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink[];
    /**
     * The check group to use in the widget.
     */
    groups?: string[];
    /**
     * A Boolean indicating whether to show ungrouped nodes.
     */
    noGroupHosts?: boolean;
    /**
     * A Boolean indicating whether to show nodes with no metrics.
     */
    noMetricHosts?: boolean;
    /**
     * The type of node used. Valid values are `host`, `container`.
     */
    nodeType?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest;
    /**
     * The list of tags to filter nodes by.
     */
    scopes?: string[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest {
    /**
     * The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    fills?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill[];
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    sizes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize[];
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle {
    /**
     * The max value to use to color the map.
     */
    fillMax?: string;
    /**
     * The min value to use to color the map.
     */
    fillMin?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip?: boolean;
}

export interface DashboardWidgetGroupDefinitionWidgetIframeDefinition {
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
}

export interface DashboardWidgetGroupDefinitionWidgetImageDefinition {
    /**
     * Whether to display a background or not. Defaults to `true`.
     */
    hasBackground?: boolean;
    /**
     * Whether to display a border or not. Defaults to `true`.
     */
    hasBorder?: boolean;
    /**
     * The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
     */
    horizontalAlign?: string;
    /**
     * The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
     */
    margin?: string;
    /**
     * The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
     */
    sizing?: string;
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
    /**
     * The URL in dark mode to use as a data source for the widget.
     */
    urlDarkTheme?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetListStreamDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests: outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest {
    /**
     * Column properties used by the front end for display.
     */
    columns: outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn[];
    /**
     * Updated list stream widget.
     */
    query: outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery;
    /**
     * Widget response format. Valid values are `eventList`.
     */
    responseFormat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn {
    /**
     * Widget column field.
     */
    field: string;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: string;
}

export interface DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * Widget query.
     */
    queryString?: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetLogStreamDefinition {
    /**
     * Column properties used by the front end for display.
     */
    columns?: string[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
     */
    messageDisplay?: string;
    /**
     * The query to use in the widget.
     */
    query?: string;
    /**
     * If the date column should be displayed.
     */
    showDateColumn?: boolean;
    /**
     * If the message column should be displayed.
     */
    showMessageColumn?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetManageStatusDefinition {
    /**
     * Whether to colorize text or background. Valid values are `background`, `text`.
     */
    colorPreference?: string;
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * A Boolean indicating whether to hide empty categories.
     */
    hideZeroCounts?: boolean;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * A Boolean indicating whether to show when monitors/groups last triggered.
     */
    showLastTriggered?: boolean;
    /**
     * Whether to show the priorities column.
     */
    showPriority?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * The summary type to use. Valid values are `monitors`, `groups`, `combined`.
     */
    summaryType?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetNoteDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The content of the note.
     */
    content: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * Whether to add padding or not. Defaults to `true`.
     */
    hasPadding?: boolean;
    /**
     * Whether to show a tick or not.
     */
    showTick?: boolean;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
     */
    tickEdge?: string;
    /**
     * When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tickPos = "50%"` is centered alignment.
     */
    tickPos?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetPowerpackDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The image URL to display as a banner for the group.
     */
    bannerImg?: string;
    /**
     * UUID of the associated powerpack.
     */
    powerpackId: string;
    /**
     * Whether to show the title or not. Defaults to `true`.
     */
    showTitle?: boolean;
    /**
     * The list of template variables for this powerpack.
     */
    templateVariables?: outputs.DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariables;
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariables {
    /**
     * Template variables controlled at the powerpack level.
     */
    controlledByPowerpacks?: outputs.DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack[];
    /**
     * Template variables controlled by the external resource, such as the dashboard this powerpack is on.
     */
    controlledExternallies?: outputs.DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariablesControlledExternally[];
}

export interface DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values: string[];
}

export interface DashboardWidgetGroupDefinitionWidgetPowerpackDefinitionTemplateVariablesControlledExternally {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values: string[];
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest[];
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink[];
    /**
     * Array of workflow inputs to map to dashboard template variables.
     */
    inputs?: outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Workflow ID
     */
    workflowId: string;
}

export interface DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY[];
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The global time target of the widget.
     */
    globalTimeTarget?: string;
    /**
     * Whether to show the error budget or not.
     */
    showErrorBudget?: boolean;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `weekToDate`, `previousWeek`, `monthToDate`, `previousMonth`, `globalTime`.
     */
    timeWindows: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view mode for the widget. Valid values are `overall`, `component`, `both`.
     */
    viewMode: string;
    /**
     * The type of view to use when displaying the widget. Only `detail` is supported.
     */
    viewType: string;
}

export interface DashboardWidgetGroupDefinitionWidgetServicemapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink[];
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSloListDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request: outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest {
    /**
     * Updated SLO List widget.
     */
    query: outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery;
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery {
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * Widget query.
     */
    queryString: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinition {
    /**
     * Normalize y axes across graphs.
     */
    hasUniformYAxes?: boolean;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    size: string;
    /**
     * The original widget we are splitting on.
     */
    sourceWidgetDefinition: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinition;
    /**
     * Encapsulates all user choices about how to split a graph.
     */
    splitConfig: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfig;
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinition {
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinition;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequest[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionView;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormula[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQuery;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequest[];
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestY[];
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestX {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestY {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendTable {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQuery;
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormula[];
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuery[];
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfig {
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSort;
    /**
     * The property by which the graph splits
     */
    splitDimensions: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSplitDimensions;
    /**
     * The property by which the graph splits
     */
    staticSplits?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigStaticSplit[];
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSort {
    /**
     * The compute options.
     */
    compute?: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSortCompute;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSortCompute {
    /**
     * The aggregation method.
     */
    aggregation?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigSplitDimensions {
    /**
     * The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
     */
    oneGraphPer: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigStaticSplit {
    /**
     * The split graph list contains a graph for each value of the split dimension.
     */
    splitVectors: outputs.DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector[];
}

export interface DashboardWidgetGroupDefinitionWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector {
    tagKey: string;
    tagValues: string[];
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery;
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest {
    /**
     * The query for a Topology request.
     */
    queries: outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery[];
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition {
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * Whether to show the latency breakdown or not.
     */
    showBreakdown?: boolean;
    /**
     * Whether to show the latency distribution or not.
     */
    showDistribution?: boolean;
    /**
     * Whether to show the error metrics or not.
     */
    showErrors?: boolean;
    /**
     * Whether to show the hits metrics or not
     */
    showHits?: boolean;
    /**
     * Whether to show the latency metrics or not.
     */
    showLatency?: boolean;
    /**
     * Whether to show the resource list or not.
     */
    showResourceList?: boolean;
    /**
     * The size of the widget. Valid values are `small`, `medium`, `large`.
     */
    sizeFormat?: string;
    /**
     * APM span name
     */
    spanName: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest {
    formulas?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula[];
    queries?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery[];
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetGroupDefinitionWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: number;
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    x: number;
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    y: number;
}

export interface DashboardWidgetHeatmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetHeatmapDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetHeatmapDefinitionEvent[];
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetHeatmapDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetHeatmapDefinitionYaxis;
}

export interface DashboardWidgetHeatmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetHeatmapDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery;
    formulas?: outputs.DashboardWidgetHeatmapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetHeatmapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetHeatmapDefinitionRequestStyle;
}

export interface DashboardWidgetHeatmapDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetHeatmapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHeatmapDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetHeatmapDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetHostmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetHostmapDefinitionCustomLink[];
    /**
     * The check group to use in the widget.
     */
    groups?: string[];
    /**
     * A Boolean indicating whether to show ungrouped nodes.
     */
    noGroupHosts?: boolean;
    /**
     * A Boolean indicating whether to show nodes with no metrics.
     */
    noMetricHosts?: boolean;
    /**
     * The type of node used. Valid values are `host`, `container`.
     */
    nodeType?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetHostmapDefinitionRequest;
    /**
     * The list of tags to filter nodes by.
     */
    scopes?: string[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetHostmapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetHostmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetHostmapDefinitionRequest {
    /**
     * The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    fills?: outputs.DashboardWidgetHostmapDefinitionRequestFill[];
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    sizes?: outputs.DashboardWidgetHostmapDefinitionRequestSize[];
}

export interface DashboardWidgetHostmapDefinitionRequestFill {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSize {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetHostmapDefinitionStyle {
    /**
     * The max value to use to color the map.
     */
    fillMax?: string;
    /**
     * The min value to use to color the map.
     */
    fillMin?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip?: boolean;
}

export interface DashboardWidgetIframeDefinition {
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
}

export interface DashboardWidgetImageDefinition {
    /**
     * Whether to display a background or not. Defaults to `true`.
     */
    hasBackground?: boolean;
    /**
     * Whether to display a border or not. Defaults to `true`.
     */
    hasBorder?: boolean;
    /**
     * The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
     */
    horizontalAlign?: string;
    /**
     * The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
     */
    margin?: string;
    /**
     * The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
     */
    sizing?: string;
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
    /**
     * The URL in dark mode to use as a data source for the widget.
     */
    urlDarkTheme?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetListStreamDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests: outputs.DashboardWidgetListStreamDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetListStreamDefinitionRequest {
    /**
     * Column properties used by the front end for display.
     */
    columns: outputs.DashboardWidgetListStreamDefinitionRequestColumn[];
    /**
     * Updated list stream widget.
     */
    query: outputs.DashboardWidgetListStreamDefinitionRequestQuery;
    /**
     * Widget response format. Valid values are `eventList`.
     */
    responseFormat: string;
}

export interface DashboardWidgetListStreamDefinitionRequestColumn {
    /**
     * Widget column field.
     */
    field: string;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: string;
}

export interface DashboardWidgetListStreamDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * Widget query.
     */
    queryString?: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetListStreamDefinitionRequestQuerySort;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetListStreamDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetLogStreamDefinition {
    /**
     * Column properties used by the front end for display.
     */
    columns?: string[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
     */
    messageDisplay?: string;
    /**
     * The query to use in the widget.
     */
    query?: string;
    /**
     * If the date column should be displayed.
     */
    showDateColumn?: boolean;
    /**
     * If the message column should be displayed.
     */
    showMessageColumn?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetLogStreamDefinitionSort;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetLogStreamDefinitionSort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetManageStatusDefinition {
    /**
     * Whether to colorize text or background. Valid values are `background`, `text`.
     */
    colorPreference?: string;
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * A Boolean indicating whether to hide empty categories.
     */
    hideZeroCounts?: boolean;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * A Boolean indicating whether to show when monitors/groups last triggered.
     */
    showLastTriggered?: boolean;
    /**
     * Whether to show the priorities column.
     */
    showPriority?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * The summary type to use. Valid values are `monitors`, `groups`, `combined`.
     */
    summaryType?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetNoteDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The content of the note.
     */
    content: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * Whether to add padding or not. Defaults to `true`.
     */
    hasPadding?: boolean;
    /**
     * Whether to show a tick or not.
     */
    showTick?: boolean;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
     */
    tickEdge?: string;
    /**
     * When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tickPos = "50%"` is centered alignment.
     */
    tickPos?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface DashboardWidgetPowerpackDefinition {
    /**
     * The background color of the group title, options: `vividBlue`, `vividPurple`, `vividPink`, `vividOrange`, `vividYellow`, `vividGreen`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
     */
    backgroundColor?: string;
    /**
     * The image URL to display as a banner for the group.
     */
    bannerImg?: string;
    /**
     * UUID of the associated powerpack.
     */
    powerpackId: string;
    /**
     * Whether to show the title or not. Defaults to `true`.
     */
    showTitle?: boolean;
    /**
     * The list of template variables for this powerpack.
     */
    templateVariables?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariables;
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariables {
    /**
     * Template variables controlled at the powerpack level.
     */
    controlledByPowerpacks?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack[];
    /**
     * Template variables controlled by the external resource, such as the dashboard this powerpack is on.
     */
    controlledExternallies?: outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally[];
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values: string[];
}

export interface DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
     */
    prefix?: string;
    /**
     * One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
     */
    values: string[];
}

export interface DashboardWidgetQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetQueryTableDefinitionRequestFormula[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetQueryValueDefinitionRequest[];
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetRunWorkflowDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetRunWorkflowDefinitionCustomLink[];
    /**
     * Array of workflow inputs to map to dashboard template variables.
     */
    inputs?: outputs.DashboardWidgetRunWorkflowDefinitionInput[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Workflow ID
     */
    workflowId: string;
}

export interface DashboardWidgetRunWorkflowDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetRunWorkflowDefinitionInput {
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.DashboardWidgetScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetScatterplotDefinitionYaxis;
}

export interface DashboardWidgetScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.DashboardWidgetScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.DashboardWidgetScatterplotDefinitionRequestY[];
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestX {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestY {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetServiceLevelObjectiveDefinition {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The global time target of the widget.
     */
    globalTimeTarget?: string;
    /**
     * Whether to show the error budget or not.
     */
    showErrorBudget?: boolean;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `weekToDate`, `previousWeek`, `monthToDate`, `previousMonth`, `globalTime`.
     */
    timeWindows: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view mode for the widget. Valid values are `overall`, `component`, `both`.
     */
    viewMode: string;
    /**
     * The type of view to use when displaying the widget. Only `detail` is supported.
     */
    viewType: string;
}

export interface DashboardWidgetServicemapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetServicemapDefinitionCustomLink[];
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetServicemapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSloListDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request: outputs.DashboardWidgetSloListDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSloListDefinitionRequest {
    /**
     * Updated SLO List widget.
     */
    query: outputs.DashboardWidgetSloListDefinitionRequestQuery;
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface DashboardWidgetSloListDefinitionRequestQuery {
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * Widget query.
     */
    queryString: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSloListDefinitionRequestQuerySort;
}

export interface DashboardWidgetSloListDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinition {
    /**
     * Normalize y axes across graphs.
     */
    hasUniformYAxes?: boolean;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    size: string;
    /**
     * The original widget we are splitting on.
     */
    sourceWidgetDefinition: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition;
    /**
     * Encapsulates all user choices about how to split a graph.
     */
    splitConfig: outputs.DashboardWidgetSplitGraphDefinitionSplitConfig;
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition {
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinition;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequest[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionView;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequest {
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormula[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQuery;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequest[];
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionYaxis;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    xes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestX[];
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    ys?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestY[];
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestX {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestY {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionLegendTable {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionSunburstDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionYaxis;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQuery;
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionToplistDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequest {
    formulas?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormula[];
    queries?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuery[];
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfig {
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSort;
    /**
     * The property by which the graph splits
     */
    splitDimensions: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions;
    /**
     * The property by which the graph splits
     */
    staticSplits?: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit[];
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSort {
    /**
     * The compute options.
     */
    compute?: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute {
    /**
     * The aggregation method.
     */
    aggregation?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions {
    /**
     * The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
     */
    oneGraphPer: string;
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit {
    /**
     * The split graph list contains a graph for each value of the split dimension.
     */
    splitVectors: outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector[];
}

export interface DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector {
    tagKey: string;
    tagValues: string[];
}

export interface DashboardWidgetSunburstDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.DashboardWidgetSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.DashboardWidgetSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetSunburstDefinitionLegendTable {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface DashboardWidgetSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.DashboardWidgetSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetSunburstDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSunburstDefinitionRequestStyle;
}

export interface DashboardWidgetSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetSunburstDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.DashboardWidgetTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.DashboardWidgetTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.DashboardWidgetTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.DashboardWidgetTimeseriesDefinitionYaxis;
}

export interface DashboardWidgetTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetTimeseriesDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface DashboardWidgetTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery;
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    formulas?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetTimeseriesDefinitionRequestStyle;
}

export interface DashboardWidgetTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface DashboardWidgetToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.DashboardWidgetToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.DashboardWidgetToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.DashboardWidgetToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.DashboardWidgetToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.DashboardWidgetToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetToplistDefinitionRequestStyle;
}

export interface DashboardWidgetToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface DashboardWidgetToplistDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface DashboardWidgetTopologyMapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.DashboardWidgetTopologyMapDefinitionCustomLink[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetTopologyMapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetTopologyMapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface DashboardWidgetTopologyMapDefinitionRequest {
    /**
     * The query for a Topology request.
     */
    queries: outputs.DashboardWidgetTopologyMapDefinitionRequestQuery[];
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface DashboardWidgetTopologyMapDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
}

export interface DashboardWidgetTraceServiceDefinition {
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * Whether to show the latency breakdown or not.
     */
    showBreakdown?: boolean;
    /**
     * Whether to show the latency distribution or not.
     */
    showDistribution?: boolean;
    /**
     * Whether to show the error metrics or not.
     */
    showErrors?: boolean;
    /**
     * Whether to show the hits metrics or not
     */
    showHits?: boolean;
    /**
     * Whether to show the latency metrics or not.
     */
    showLatency?: boolean;
    /**
     * Whether to show the resource list or not.
     */
    showResourceList?: boolean;
    /**
     * The size of the widget. Valid values are `small`, `medium`, `large`.
     */
    sizeFormat?: string;
    /**
     * APM span name
     */
    spanName: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface DashboardWidgetTreemapDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.DashboardWidgetTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface DashboardWidgetTreemapDefinitionRequest {
    formulas?: outputs.DashboardWidgetTreemapDefinitionRequestFormula[];
    queries?: outputs.DashboardWidgetTreemapDefinitionRequestQuery[];
}

export interface DashboardWidgetTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
     */
    value: number;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface DashboardWidgetTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface DashboardWidgetTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface DashboardWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * Widget column width. Valid values are `auto`, `compact`, `full`.
     */
    width: number;
    /**
     * The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    x: number;
    /**
     * The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery`, `apmStatsQuery` or `processQuery` is required within the block).
     */
    y: number;
}

export interface DowntimeRecurrence {
    /**
     * How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
     */
    period?: number;
    /**
     * The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
     */
    rrule?: string;
    /**
     * One of `days`, `weeks`, `months`, `years`, or `rrule`.
     */
    type: string;
    /**
     * The date at which the recurrence should end as a POSIX timestamp. `untilOccurrences` and `untilDate` are mutually exclusive.
     */
    untilDate?: number;
    /**
     * How many times the downtime will be rescheduled. `untilOccurrences` and `untilDate` are mutually exclusive.
     */
    untilOccurrences?: number;
    /**
     * A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
     */
    weekDays?: string[];
}

export interface DowntimeScheduleMonitorIdentifier {
    /**
     * ID of the monitor to prevent notifications.
     */
    monitorId?: number;
    /**
     * A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitorTags` to `[*]` configures the downtime to mute all monitors for the given scope.
     */
    monitorTags?: string[];
}

export interface DowntimeScheduleOneTimeSchedule {
    /**
     * ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
     */
    end?: string;
    /**
     * ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
     */
    start: string;
}

export interface DowntimeScheduleRecurringSchedule {
    recurrences?: outputs.DowntimeScheduleRecurringScheduleRecurrence[];
    /**
     * The timezone in which to schedule the downtime.
     */
    timezone: string;
}

export interface DowntimeScheduleRecurringScheduleRecurrence {
    /**
     * The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
     */
    duration: string;
    /**
     * The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
     */
    rrule: string;
    /**
     * ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
     */
    start: string;
}

export interface GetCloudWorkloadSecurityAgentRulesAgentRule {
    /**
     * The description of the Agent rule.
     */
    description: string;
    /**
     * Whether the Agent rule is enabled.
     */
    enabled: boolean;
    /**
     * The SECL expression of the Agent rule.
     */
    expression: string;
    /**
     * The id of the Agent rule.
     */
    id: string;
    /**
     * The name of the Agent rule.
     */
    name: string;
}

export interface GetHostsHostList {
    aliases: string[];
    apps: string[];
    awsName: string;
    hostName: string;
    id: number;
    isMuted: boolean;
    lastReportedTime: number;
    meta: outputs.GetHostsHostListMeta;
    metrics: outputs.GetHostsHostListMetrics;
    muteTimeout: number;
    name: string;
    sources: string[];
    up: boolean;
}

export interface GetHostsHostListMeta {
    agentVersion: string;
    cpuCores: number;
    gohai: string;
    machine: string;
    platform: string;
    processor: string;
    pythonVersion: string;
    socketFqdn: string;
    socketHostname: string;
}

export interface GetHostsHostListMetrics {
    cpu: number;
    iowait: number;
    load: number;
}

export interface GetLogsIndexesLogsIndex {
    /**
     * The number of log events you can send in this index per day before you are rate-limited.
     */
    dailyLimit: number;
    /**
     * Object containing options to override the default daily limit reset time.
     */
    dailyLimitResets: outputs.GetLogsIndexesLogsIndexDailyLimitReset[];
    /**
     * The percentage threshold of the daily quota at which a Datadog warning event is generated.
     */
    dailyLimitWarningThresholdPercentage: number;
    /**
     * List of exclusion filters.
     */
    exclusionFilters: outputs.GetLogsIndexesLogsIndexExclusionFilter[];
    /**
     * Logs filter
     */
    filters: outputs.GetLogsIndexesLogsIndexFilter[];
    /**
     * The name of the index.
     */
    name: string;
    /**
     * The number of days before logs are deleted from this index.
     */
    retentionDays: number;
}

export interface GetLogsIndexesLogsIndexDailyLimitReset {
    /**
     * String in `HH:00` format representing the time of day the daily limit should be reset. The hours between 00 and 23 (inclusive).
     */
    resetTime: string;
    /**
     * String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours between -12 and +14 (inclusive).
     */
    resetUtcOffset: string;
}

export interface GetLogsIndexesLogsIndexExclusionFilter {
    filters?: outputs.GetLogsIndexesLogsIndexExclusionFilterFilter[];
    /**
     * A boolean stating if the exclusion is active or not.
     */
    isEnabled: boolean;
    /**
     * The name of the exclusion filter.
     */
    name: string;
}

export interface GetLogsIndexesLogsIndexExclusionFilterFilter {
    /**
     * Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
     */
    query: string;
    /**
     * The fraction of logs excluded by the exclusion filter, when active.
     */
    sampleRate: number;
}

export interface GetLogsIndexesLogsIndexFilter {
    /**
     * Logs filter criteria. Only logs matching this filter criteria are considered for this index.
     */
    query: string;
}

export interface GetLogsPipelinesLogsPipeline {
    /**
     * Pipelines filter
     */
    filters: outputs.GetLogsPipelinesLogsPipelineFilter[];
    /**
     * ID of the pipeline
     */
    id: string;
    /**
     * Whether or not the pipeline is enabled.
     */
    isEnabled: boolean;
    /**
     * Whether or not the pipeline can be edited.
     */
    isReadOnly: boolean;
    /**
     * The name of the pipeline.
     */
    name: string;
    /**
     * Whether or not the pipeline can be edited.
     */
    type: string;
}

export interface GetLogsPipelinesLogsPipelineFilter {
    /**
     * Pipeline filter criteria.
     */
    query: string;
}

export interface GetMonitorConfigPoliciesMonitorConfigPolicy {
    /**
     * ID of the monitor config policy
     */
    id: string;
    /**
     * The monitor config policy type
     */
    policyType: string;
    /**
     * Config for a tag policy. Only set if `policyType` is `tag`.
     */
    tagPolicy: outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicy;
}

export interface GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicy {
    /**
     * The key of the tag
     */
    tagKey: string;
    /**
     * If a tag key is required for monitor creation
     */
    tagKeyRequired: boolean;
    /**
     * Valid values for the tag
     */
    validTagValues: string[];
}

export interface GetMonitorMonitorThreshold {
    critical: string;
    criticalRecovery: string;
    ok: string;
    unknown: string;
    warning: string;
    warningRecovery: string;
}

export interface GetMonitorMonitorThresholdWindow {
    recoveryWindow: string;
    triggerWindow: string;
}

export interface GetMonitorSchedulingOption {
    /**
     * Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
     */
    customSchedules: outputs.GetMonitorSchedulingOptionCustomSchedule[];
    /**
     * Configuration options for the evaluation window. If `hourStarts` is set, no other fields may be set. Otherwise, `dayStarts` and `monthStarts` must be set together.
     */
    evaluationWindows: outputs.GetMonitorSchedulingOptionEvaluationWindow[];
}

export interface GetMonitorSchedulingOptionCustomSchedule {
    /**
     * A list of recurrence definitions. Length must be 1.
     */
    recurrences: outputs.GetMonitorSchedulingOptionCustomScheduleRecurrence[];
}

export interface GetMonitorSchedulingOptionCustomScheduleRecurrence {
    /**
     * Must be a valid rrule. See api docs for supported fields
     */
    rrule: string;
    /**
     * Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
     */
    start: string;
    /**
     * 'tz database' format. ex: 'America/New_York' or UTC
     */
    timezone: string;
}

export interface GetMonitorSchedulingOptionEvaluationWindow {
    /**
     * The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
     */
    dayStarts: string;
    /**
     * The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
     */
    hourStarts: number;
    /**
     * The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
     */
    monthStarts: number;
}

export interface GetMonitorsMonitor {
    /**
     * ID of the monitor
     */
    id: number;
    /**
     * Name of the monitor
     */
    name: string;
    /**
     * Type of the monitor.
     */
    type: string;
}

export interface GetRolesRole {
    /**
     * ID of the Datadog role
     */
    id: string;
    /**
     * Name of the Datadog role
     */
    name: string;
    /**
     * Number of users that have this role.
     */
    userCount: number;
}

export interface GetSecurityMonitoringFiltersFilter {
    /**
     * Exclusion filters to exclude some logs from the security filter.
     */
    exclusionFilters?: outputs.GetSecurityMonitoringFiltersFilterExclusionFilter[];
    /**
     * The filtered data type.
     */
    filteredDataType?: string;
    /**
     * Whether the security filter is enabled.
     */
    isEnabled: boolean;
    /**
     * The name of the security filter.
     */
    name: string;
    /**
     * The query of the security filter.
     */
    query: string;
    /**
     * The version of the security filter.
     */
    version: number;
}

export interface GetSecurityMonitoringFiltersFilterExclusionFilter {
    /**
     * Exclusion filter name.
     */
    name: string;
    /**
     * Exclusion filter query. Logs that match this query are excluded from the security filter.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRule {
    /**
     * Cases for generating signals.
     */
    cases?: outputs.GetSecurityMonitoringRulesRuleCase[];
    /**
     * Whether the rule is enabled.
     */
    enabled?: boolean;
    /**
     * Additional queries to filter matched events before they are processed.
     */
    filters?: outputs.GetSecurityMonitoringRulesRuleFilter[];
    /**
     * Whether the notifications include the triggering group-by values in their title.
     */
    hasExtendedTitle?: boolean;
    /**
     * Message for generated signals.
     */
    message: string;
    /**
     * The name of the rule.
     */
    name: string;
    /**
     * Options on rules.
     */
    options?: outputs.GetSecurityMonitoringRulesRuleOptions;
    /**
     * Queries for selecting logs which are part of the rule.
     */
    queries?: outputs.GetSecurityMonitoringRulesRuleQuery[];
    /**
     * Queries for selecting logs which are part of the rule.
     */
    signalQueries?: outputs.GetSecurityMonitoringRulesRuleSignalQuery[];
    /**
     * Tags for generated signals.
     */
    tags?: string[];
    /**
     * Cases for generating signals for third-party rules. Only required and accepted for third-party rules
     */
    thirdPartyCases?: outputs.GetSecurityMonitoringRulesRuleThirdPartyCase[];
    /**
     * The rule type.
     */
    type?: string;
}

export interface GetSecurityMonitoringRulesRuleCase {
    /**
     * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
     */
    condition?: string;
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * Severity of the Security Signal.
     */
    status: string;
}

export interface GetSecurityMonitoringRulesRuleFilter {
    /**
     * The type of filtering action.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
    /**
     * The detection method.
     */
    detectionMethod?: string;
    /**
     * A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
     */
    evaluationWindow?: number;
    /**
     * Options for rules using the impossible travel detection method.
     */
    impossibleTravelOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptions;
    /**
     * Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds).
     */
    keepAlive?: number;
    /**
     * A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp.
     */
    maxSignalDuration?: number;
    /**
     * New value rules specific options.
     */
    newValueOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptions;
    /**
     * Options for rules using the third-party detection method.
     */
    thirdPartyRuleOptions?: outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptions;
}

export interface GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptions {
    /**
     * If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
     */
    baselineUserLocations?: boolean;
}

export interface GetSecurityMonitoringRulesRuleOptionsNewValueOptions {
    /**
     * The duration in days after which a learned value is forgotten.
     */
    forgetAfter: number;
    /**
     * The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
     */
    learningDuration?: number;
    /**
     * The learning method used to determine when signals should be generated for values that weren't learned.
     */
    learningMethod?: string;
    /**
     * A number of occurrences after which signals are generated for values that weren't learned.
     */
    learningThreshold?: number;
}

export interface GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptions {
    /**
     * Notification targets for the default rule case, when none of the third-party cases match.
     */
    defaultNotifications?: string[];
    /**
     * Severity of the default rule case, when none of the third-party cases match.
     */
    defaultStatus: string;
    /**
     * Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
     */
    rootQueries: outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQuery[];
    /**
     * A template for the signal title; if omitted, the title is generated based on the case name.
     */
    signalTitleTemplate?: string;
}

export interface GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQuery {
    /**
     * Fields to group by. If empty, each log triggers a signal.
     */
    groupByFields?: string[];
    /**
     * Query to filter logs.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleQuery {
    /**
     * **Deprecated**. It won't be applied anymore.
     *
     * @deprecated `agentRule` has been deprecated in favor of new Agent Rule resource.
     */
    agentRules?: outputs.GetSecurityMonitoringRulesRuleQueryAgentRule[];
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count.
     */
    aggregation?: string;
    /**
     * Field for which the cardinality is measured. Sent as an array.
     */
    distinctFields?: string[];
    /**
     * Fields to group by.
     */
    groupByFields?: string[];
    /**
     * The target field to aggregate over when using the `sum`, `max`, or `geoData` aggregations.
     *
     * @deprecated Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     */
    metric?: string;
    /**
     * Group of target fields to aggregate over when using the `sum`, `max`, `geoData`, or `newValue` aggregations. The `sum`, `max`, and `geoData` aggregations only accept one value in this list, whereas the `newValue` aggregation accepts up to five values.
     */
    metrics: string[];
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Query to run on logs.
     */
    query: string;
}

export interface GetSecurityMonitoringRulesRuleQueryAgentRule {
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    agentRuleId: string;
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    expression: string;
}

export interface GetSecurityMonitoringRulesRuleSignalQuery {
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count.
     */
    aggregation?: string;
    /**
     * Fields to correlate by.
     */
    correlatedByFields?: string[];
    /**
     * Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
     */
    correlatedQueryIndex?: string;
    /**
     * Default Rule ID of the signal to correlate. This value is READ-ONLY.
     */
    defaultRuleId?: string;
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Rule ID of the signal to correlate.
     */
    ruleId: string;
}

export interface GetSecurityMonitoringRulesRuleThirdPartyCase {
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * A query to associate a third-party event to this case.
     */
    query?: string;
    /**
     * Severity of the Security Signal.
     */
    status: string;
}

export interface GetSecurityMonitoringSuppressionsSuppression {
    description: string;
    enabled: boolean;
    expirationDate: string;
    id: string;
    name: string;
    ruleQuery: string;
    suppressionQuery: string;
}

export interface GetServiceLevelObjectiveQuery {
    /**
     * The sum of the `total` events.
     */
    denominator: string;
    /**
     * The sum of all the `good` events.
     */
    numerator: string;
}

export interface GetServiceLevelObjectivesSlo {
    /**
     * ID of the Datadog service level objective
     */
    id: string;
    /**
     * Name of the Datadog service level objective
     */
    name: string;
    /**
     * The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation page](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object). Available options to choose from are: `metric` and `monitor`.
     */
    type: string;
}

export interface GetTeamMembershipsTeamMembership {
    id: string;
    role: string;
    teamId: string;
    userId: string;
}

export interface GetUsersUser {
    email: string;
    id: string;
    name: string;
}

export interface IpAllowlistEntry {
    /**
     * IP address or range of addresses.
     */
    cidrBlock: string;
    /**
     * Note accompanying IP address.
     */
    note?: string;
}

export interface LogsArchiveAzureArchive {
    /**
     * Your client id.
     */
    clientId: string;
    /**
     * The container where the archive is stored.
     */
    container: string;
    /**
     * The path where the archive is stored.
     */
    path?: string;
    /**
     * The associated storage account.
     */
    storageAccount: string;
    /**
     * Your tenant id.
     */
    tenantId: string;
}

export interface LogsArchiveGcsArchive {
    /**
     * Name of your GCS bucket.
     */
    bucket: string;
    /**
     * Your client email.
     */
    clientEmail: string;
    /**
     * Path where the archive is stored.
     */
    path?: string;
    /**
     * Your project id.
     */
    projectId?: string;
}

export interface LogsArchiveS3Archive {
    /**
     * Your AWS account id.
     */
    accountId: string;
    /**
     * Name of your s3 bucket.
     */
    bucket: string;
    /**
     * Path where the archive is stored.
     */
    path?: string;
    /**
     * Your AWS role name
     */
    roleName: string;
}

export interface LogsCustomPipelineFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessor {
    /**
     * Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
     */
    arithmeticProcessor?: outputs.LogsCustomPipelineProcessorArithmeticProcessor;
    /**
     * Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
     */
    attributeRemapper?: outputs.LogsCustomPipelineProcessorAttributeRemapper;
    /**
     * Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
     */
    categoryProcessor?: outputs.LogsCustomPipelineProcessorCategoryProcessor;
    /**
     * Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
     */
    dateRemapper?: outputs.LogsCustomPipelineProcessorDateRemapper;
    /**
     * Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
     */
    geoIpParser?: outputs.LogsCustomPipelineProcessorGeoIpParser;
    /**
     * Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
     */
    grokParser?: outputs.LogsCustomPipelineProcessorGrokParser;
    /**
     * Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    lookupProcessor?: outputs.LogsCustomPipelineProcessorLookupProcessor;
    /**
     * Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
     */
    messageRemapper?: outputs.LogsCustomPipelineProcessorMessageRemapper;
    pipeline?: outputs.LogsCustomPipelineProcessorPipeline;
    /**
     * Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    referenceTableLookupProcessor?: outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor;
    /**
     * Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
     */
    serviceRemapper?: outputs.LogsCustomPipelineProcessorServiceRemapper;
    /**
     * Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
     */
    statusRemapper?: outputs.LogsCustomPipelineProcessorStatusRemapper;
    /**
     * String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
     */
    stringBuilderProcessor?: outputs.LogsCustomPipelineProcessorStringBuilderProcessor;
    /**
     * Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
     */
    traceIdRemapper?: outputs.LogsCustomPipelineProcessorTraceIdRemapper;
    /**
     * URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
     */
    urlParser?: outputs.LogsCustomPipelineProcessorUrlParser;
    /**
     * User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
     */
    userAgentParser?: outputs.LogsCustomPipelineProcessorUserAgentParser;
}

export interface LogsCustomPipelineProcessorArithmeticProcessor {
    /**
     * Arithmetic operation between one or more log attributes.
     */
    expression: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorAttributeRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Override the target element if already set.
     */
    overrideOnConflict?: boolean;
    /**
     * Remove or preserve the remapped source element.
     */
    preserveSource?: boolean;
    /**
     * Defines where the sources are from (log `attribute` or `tag`).
     */
    sourceType: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
    /**
     * If the `targetType` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `targetType` is `tag`, this parameter may not be specified.
     */
    targetFormat?: string;
    /**
     * Defines if the target is a log `attribute` or `tag`.
     */
    targetType: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessor {
    /**
     * List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
     */
    categories: outputs.LogsCustomPipelineProcessorCategoryProcessorCategory[];
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessorCategory {
    filter: outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter;
    /**
     * Your pipeline name.
     */
    name: string;
}

export interface LogsCustomPipelineProcessorCategoryProcessorCategoryFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorDateRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorGeoIpParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorGrokParser {
    grok: outputs.LogsCustomPipelineProcessorGrokParserGrok;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
     */
    samples?: string[];
    /**
     * Name of the log attribute to parse.
     */
    source: string;
}

export interface LogsCustomPipelineProcessorGrokParserGrok {
    /**
     * Match rules for your grok parser.
     */
    matchRules: string;
    /**
     * Support rules for your grok parser.
     */
    supportRules: string;
}

export interface LogsCustomPipelineProcessorLookupProcessor {
    /**
     * Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
     */
    defaultLookup?: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * List of entries of the lookup table using `key,value` format.
     */
    lookupTables: string[];
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the log attribute to parse.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorMessageRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipeline {
    filters: outputs.LogsCustomPipelineProcessorPipelineFilter[];
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name: string;
    processors?: outputs.LogsCustomPipelineProcessorPipelineProcessor[];
}

export interface LogsCustomPipelineProcessorPipelineFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessor {
    /**
     * Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
     */
    arithmeticProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor;
    /**
     * Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
     */
    attributeRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper;
    /**
     * Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
     */
    categoryProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor;
    /**
     * Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
     */
    dateRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper;
    /**
     * Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
     */
    geoIpParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser;
    /**
     * Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
     */
    grokParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser;
    /**
     * Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    lookupProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor;
    /**
     * Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
     */
    messageRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper;
    /**
     * Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
     */
    referenceTableLookupProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor;
    /**
     * Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
     */
    serviceRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper;
    /**
     * Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
     */
    statusRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper;
    /**
     * String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
     */
    stringBuilderProcessor?: outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor;
    /**
     * Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
     */
    traceIdRemapper?: outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper;
    /**
     * URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
     */
    urlParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser;
    /**
     * User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
     */
    userAgentParser?: outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser;
}

export interface LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor {
    /**
     * Arithmetic operation between one or more log attributes.
     */
    expression: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Override the target element if already set.
     */
    overrideOnConflict?: boolean;
    /**
     * Remove or preserve the remapped source element.
     */
    preserveSource?: boolean;
    /**
     * Defines where the sources are from (log `attribute` or `tag`).
     */
    sourceType: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
    /**
     * If the `targetType` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `targetType` is `tag`, this parameter may not be specified.
     */
    targetFormat?: string;
    /**
     * Defines if the target is a log `attribute` or `tag`.
     */
    targetType: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor {
    /**
     * List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
     */
    categories: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory[];
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory {
    filter: outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter;
    /**
     * Your pipeline name.
     */
    name: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter {
    /**
     * Filter criteria of the category.
     */
    query: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorDateRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorGeoIpParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorGrokParser {
    grok: outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
     */
    samples?: string[];
    /**
     * Name of the log attribute to parse.
     */
    source: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok {
    /**
     * Match rules for your grok parser.
     */
    matchRules: string;
    /**
     * Support rules for your grok parser.
     */
    supportRules: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorLookupProcessor {
    /**
     * Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
     */
    defaultLookup?: string;
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * List of entries of the lookup table using `key,value` format.
     */
    lookupTables: string[];
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the log attribute to parse.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorMessageRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Name of the Reference Table for the source attribute and their associated target attribute values.
     */
    lookupEnrichmentTable: string;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the log attribute to parse.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorServiceRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorStatusRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
    /**
     * The formula with one or more attributes and raw text.
     */
    template: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorPipelineProcessorUrlParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Normalize the ending slashes or not.
     */
    normalizeEndingSlashes?: boolean;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorPipelineProcessorUserAgentParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If the source attribute is URL encoded or not.
     */
    isEncoded?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorReferenceTableLookupProcessor {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Name of the Reference Table for the source attribute and their associated target attribute values.
     */
    lookupEnrichmentTable: string;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the log attribute to parse.
     */
    source: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorServiceRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorStatusRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorStringBuilderProcessor {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
     */
    isReplaceMissing?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
    /**
     * The formula with one or more attributes and raw text.
     */
    template: string;
}

export interface LogsCustomPipelineProcessorTraceIdRemapper {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
}

export interface LogsCustomPipelineProcessorUrlParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * Normalize the ending slashes or not.
     */
    normalizeEndingSlashes?: boolean;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsCustomPipelineProcessorUserAgentParser {
    /**
     * Boolean value to enable your pipeline.
     */
    isEnabled?: boolean;
    /**
     * If the source attribute is URL encoded or not.
     */
    isEncoded?: boolean;
    /**
     * Your pipeline name.
     */
    name?: string;
    /**
     * List of source attributes or tags.
     */
    sources: string[];
    /**
     * Name of the attribute that contains the result of the arithmetic operation.
     */
    target: string;
}

export interface LogsIndexDailyLimitReset {
    /**
     * String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
     */
    resetTime: string;
    /**
     * String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
     */
    resetUtcOffset: string;
}

export interface LogsIndexExclusionFilter {
    filters?: outputs.LogsIndexExclusionFilterFilter[];
    /**
     * A boolean stating if the exclusion is active or not.
     */
    isEnabled?: boolean;
    /**
     * The name of the exclusion filter.
     */
    name?: string;
}

export interface LogsIndexExclusionFilterFilter {
    /**
     * Logs filter criteria. Only logs matching this filter criteria are considered for this index.
     */
    query?: string;
    /**
     * The fraction of logs excluded by the exclusion filter, when active.
     */
    sampleRate?: number;
}

export interface LogsIndexFilter {
    /**
     * Logs filter criteria. Only logs matching this filter criteria are considered for this index.
     */
    query: string;
}

export interface LogsMetricCompute {
    /**
     * The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
     */
    aggregationType: string;
    /**
     * Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregationType` of distribution.
     */
    includePercentiles?: boolean;
    /**
     * The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
     */
    path?: string;
}

export interface LogsMetricFilter {
    /**
     * The search query - following the log search syntax.
     */
    query: string;
}

export interface LogsMetricGroupBy {
    /**
     * The path to the value the log-based metric will be aggregated over.
     */
    path: string;
    /**
     * Name of the tag that gets created.
     */
    tagName: string;
}

export interface MetricTagConfigurationAggregation {
    /**
     * A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
     */
    space: string;
    /**
     * A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
     */
    time: string;
}

export interface MonitorConfigPolicyTagPolicy {
    /**
     * The key of the tag
     */
    tagKey: string;
    /**
     * If a tag key is required for monitor creation
     */
    tagKeyRequired: boolean;
    /**
     * Valid values for the tag
     */
    validTagValues: string[];
}

export interface MonitorMonitorThresholdWindows {
    /**
     * Describes how long an anomalous metric must be normal before the alert recovers.
     */
    recoveryWindow?: string;
    /**
     * Describes how long a metric must be anomalous before an alert triggers.
     */
    triggerWindow?: string;
}

export interface MonitorMonitorThresholds {
    /**
     * The monitor `CRITICAL` threshold. Must be a number.
     */
    critical?: string;
    /**
     * The monitor `CRITICAL` recovery threshold. Must be a number.
     */
    criticalRecovery?: string;
    /**
     * The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
     */
    ok?: string;
    /**
     * The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
     */
    unknown?: string;
    /**
     * The monitor `WARNING` threshold. Must be a number.
     */
    warning?: string;
    /**
     * The monitor `WARNING` recovery threshold. Must be a number.
     */
    warningRecovery?: string;
}

export interface MonitorSchedulingOption {
    /**
     * Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
     */
    customSchedules?: outputs.MonitorSchedulingOptionCustomSchedule[];
    /**
     * Configuration options for the evaluation window. If `hourStarts` is set, no other fields may be set. Otherwise, `dayStarts` and `monthStarts` must be set together.
     */
    evaluationWindows?: outputs.MonitorSchedulingOptionEvaluationWindow[];
}

export interface MonitorSchedulingOptionCustomSchedule {
    /**
     * A list of recurrence definitions. Length must be 1.
     */
    recurrence: outputs.MonitorSchedulingOptionCustomScheduleRecurrence;
}

export interface MonitorSchedulingOptionCustomScheduleRecurrence {
    /**
     * Must be a valid `rrule`. See API docs for supported fields
     */
    rrule: string;
    /**
     * Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
     */
    start?: string;
    /**
     * 'tz database' format. Example: `America/New_York` or `UTC`
     */
    timezone: string;
}

export interface MonitorSchedulingOptionEvaluationWindow {
    /**
     * The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
     */
    dayStarts?: string;
    /**
     * The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
     */
    hourStarts?: number;
    /**
     * The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
     */
    monthStarts?: number;
}

export interface MonitorVariables {
    /**
     * A timeseries formula and functions events query.
     */
    eventQueries?: outputs.MonitorVariablesEventQuery[];
}

export interface MonitorVariablesEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.MonitorVariablesEventQueryCompute[];
    /**
     * The data source for event platform-based queries. Valid values are `rum`, `ciPipelines`, `ciTests`, `audit`, `events`, `logs`, `spans`, `databaseQueries`.
     */
    dataSource: string;
    /**
     * Group by options.
     */
    groupBies?: outputs.MonitorVariablesEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of query for use in formulas.
     */
    name: string;
    /**
     * The search options.
     */
    search: outputs.MonitorVariablesEventQuerySearch;
}

export interface MonitorVariablesEventQueryCompute {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * A time interval in milliseconds.
     */
    interval?: number;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
}

export interface MonitorVariablesEventQueryGroupBy {
    /**
     * The event facet.
     */
    facet: string;
    /**
     * The number of groups to return.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.MonitorVariablesEventQueryGroupBySort;
}

export interface MonitorVariablesEventQueryGroupBySort {
    /**
     * The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
     */
    aggregation: string;
    /**
     * The measurable attribute to compute.
     */
    metric?: string;
    /**
     * Direction of sort. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface MonitorVariablesEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface OrganizationSettingsSettings {
    /**
     * Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
     */
    privateWidgetShare?: boolean;
    /**
     * SAML properties
     */
    saml: outputs.OrganizationSettingsSettingsSaml;
    /**
     * The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
     */
    samlAutocreateAccessRole?: string;
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    samlAutocreateUsersDomains: outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains;
    /**
     * Whether or not SAML can be enabled for this organization.
     */
    samlCanBeEnabled: boolean;
    /**
     * Identity provider endpoint for SAML authentication.
     */
    samlIdpEndpoint: string;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpInitiatedLogin: outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin;
    /**
     * Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
     */
    samlIdpMetadataUploaded: boolean;
    /**
     * URL for SAML logging.
     */
    samlLoginUrl: string;
    /**
     * Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
     */
    samlStrictMode: outputs.OrganizationSettingsSettingsSamlStrictMode;
}

export interface OrganizationSettingsSettingsSaml {
    /**
     * Whether or not SAML is enabled for this organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlAutocreateUsersDomains {
    /**
     * List of domains where the SAML automated user creation is enabled.
     */
    domains?: string[];
    /**
     * Whether or not SAML is enabled for this organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlIdpInitiatedLogin {
    /**
     * Whether or not SAML is enabled for this organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface OrganizationSettingsSettingsSamlStrictMode {
    /**
     * Whether or not SAML is enabled for this organization. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface PowerpackLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
     */
    y: number;
}

export interface PowerpackTemplateVariable {
    /**
     * One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
     */
    defaults?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
}

export interface PowerpackWidget {
    /**
     * The definition for a Alert Graph widget.
     */
    alertGraphDefinition?: outputs.PowerpackWidgetAlertGraphDefinition;
    /**
     * The definition for a Alert Value widget.
     */
    alertValueDefinition?: outputs.PowerpackWidgetAlertValueDefinition;
    /**
     * The definition for a Change widget.
     */
    changeDefinition?: outputs.PowerpackWidgetChangeDefinition;
    /**
     * The definition for a Check Status widget.
     */
    checkStatusDefinition?: outputs.PowerpackWidgetCheckStatusDefinition;
    /**
     * The definition for a Distribution widget.
     */
    distributionDefinition?: outputs.PowerpackWidgetDistributionDefinition;
    /**
     * The definition for a Event Stream widget.
     */
    eventStreamDefinition?: outputs.PowerpackWidgetEventStreamDefinition;
    /**
     * The definition for a Event Timeline widget.
     */
    eventTimelineDefinition?: outputs.PowerpackWidgetEventTimelineDefinition;
    /**
     * The definition for a Free Text widget.
     */
    freeTextDefinition?: outputs.PowerpackWidgetFreeTextDefinition;
    /**
     * The definition for a Geomap widget.
     */
    geomapDefinition?: outputs.PowerpackWidgetGeomapDefinition;
    /**
     * The definition for a Heatmap widget.
     */
    heatmapDefinition?: outputs.PowerpackWidgetHeatmapDefinition;
    /**
     * The definition for a Hostmap widget.
     */
    hostmapDefinition?: outputs.PowerpackWidgetHostmapDefinition;
    /**
     * The ID of the widget.
     */
    id: number;
    /**
     * The definition for an Iframe widget.
     */
    iframeDefinition?: outputs.PowerpackWidgetIframeDefinition;
    /**
     * The definition for an Image widget
     */
    imageDefinition?: outputs.PowerpackWidgetImageDefinition;
    /**
     * The definition for a List Stream widget.
     */
    listStreamDefinition?: outputs.PowerpackWidgetListStreamDefinition;
    /**
     * The definition for an Log Stream widget.
     */
    logStreamDefinition?: outputs.PowerpackWidgetLogStreamDefinition;
    /**
     * The definition for an Manage Status widget.
     */
    manageStatusDefinition?: outputs.PowerpackWidgetManageStatusDefinition;
    /**
     * The definition for a Note widget.
     */
    noteDefinition?: outputs.PowerpackWidgetNoteDefinition;
    /**
     * The definition for a Query Table widget.
     */
    queryTableDefinition?: outputs.PowerpackWidgetQueryTableDefinition;
    /**
     * The definition for a Query Value widget.
     */
    queryValueDefinition?: outputs.PowerpackWidgetQueryValueDefinition;
    /**
     * The definition for a Run Workflow widget.
     */
    runWorkflowDefinition?: outputs.PowerpackWidgetRunWorkflowDefinition;
    /**
     * The definition for a Scatterplot widget.
     */
    scatterplotDefinition?: outputs.PowerpackWidgetScatterplotDefinition;
    /**
     * The definition for a Service Level Objective widget.
     */
    serviceLevelObjectiveDefinition?: outputs.PowerpackWidgetServiceLevelObjectiveDefinition;
    /**
     * The definition for a Service Map widget.
     */
    servicemapDefinition?: outputs.PowerpackWidgetServicemapDefinition;
    /**
     * The definition for an SLO (Service Level Objective) List widget.
     */
    sloListDefinition?: outputs.PowerpackWidgetSloListDefinition;
    /**
     * The definition for a Sunburst widget.
     */
    sunburstDefinition?: outputs.PowerpackWidgetSunburstDefinition;
    /**
     * The definition for a Timeseries widget.
     */
    timeseriesDefinition?: outputs.PowerpackWidgetTimeseriesDefinition;
    /**
     * The definition for a Toplist widget.
     */
    toplistDefinition?: outputs.PowerpackWidgetToplistDefinition;
    /**
     * The definition for a Topology Map widget.
     */
    topologyMapDefinition?: outputs.PowerpackWidgetTopologyMapDefinition;
    /**
     * The definition for a Trace Service widget.
     */
    traceServiceDefinition?: outputs.PowerpackWidgetTraceServiceDefinition;
    /**
     * The definition for a Treemap widget.
     */
    treemapDefinition?: outputs.PowerpackWidgetTreemapDefinition;
    /**
     * The layout of the widget on a 'free' dashboard.
     */
    widgetLayout?: outputs.PowerpackWidgetWidgetLayout;
}

export interface PowerpackWidgetAlertGraphDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
     */
    vizType: string;
}

export interface PowerpackWidgetAlertValueDefinition {
    /**
     * The ID of the monitor used by the widget.
     */
    alertId: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The unit for the value displayed in the widget.
     */
    unit?: string;
}

export interface PowerpackWidgetChangeDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetChangeDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetChangeDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetChangeDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetChangeDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQuery;
    /**
     * Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
     */
    changeType?: string;
    /**
     * Choose from when to compare current data to. Valid values are `hourBefore`, `dayBefore`, `weekBefore`, `monthBefore`.
     */
    compareTo?: string;
    formulas?: outputs.PowerpackWidgetChangeDefinitionRequestFormula[];
    /**
     * A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
     */
    increaseGood?: boolean;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQuery;
    /**
     * What to order by. Valid values are `change`, `name`, `present`, `past`.
     */
    orderBy?: string;
    /**
     * Widget sorting method. Valid values are `asc`, `desc`.
     */
    orderDir?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetChangeDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetChangeDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQuery;
    /**
     * If set to `true`, displays the current value.
     */
    showPresent?: boolean;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetChangeDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetChangeDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetCheckStatusDefinition {
    /**
     * The check to use in the widget.
     */
    check: string;
    /**
     * The check group to use in the widget.
     */
    group?: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The kind of grouping to use. Valid values are `check`, `cluster`.
     */
    grouping: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A list of tags to use in the widget.
     */
    tags?: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetDistributionDefinition {
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetDistributionDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetDistributionDefinitionRequestStyle;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetDistributionDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface PowerpackWidgetEventStreamDefinition {
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetEventTimelineDefinition {
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetFreeTextDefinition {
    /**
     * The color of the text in the widget.
     */
    color?: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * The text to display in the widget.
     */
    text: string;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
}

export interface PowerpackWidgetGeomapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetGeomapDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetGeomapDefinitionRequest[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetGeomapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view of the world that the map should render.
     */
    view: outputs.PowerpackWidgetGeomapDefinitionView;
}

export interface PowerpackWidgetGeomapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequest {
    formulas?: outputs.PowerpackWidgetGeomapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetGeomapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetGeomapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetGeomapDefinitionStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip: boolean;
}

export interface PowerpackWidgetGeomapDefinitionView {
    /**
     * The two-letter ISO code of a country to focus the map on (or `WORLD`).
     */
    focus: string;
}

export interface PowerpackWidgetHeatmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetHeatmapDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.PowerpackWidgetHeatmapDefinitionEvent[];
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetHeatmapDefinitionRequest[];
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetHeatmapDefinitionYaxis;
}

export interface PowerpackWidgetHeatmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetHeatmapDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQuery;
    formulas?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetHeatmapDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetHeatmapDefinitionRequestStyle;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHeatmapDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface PowerpackWidgetHeatmapDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetHostmapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetHostmapDefinitionCustomLink[];
    /**
     * The check group to use in the widget.
     */
    groups?: string[];
    /**
     * A Boolean indicating whether to show ungrouped nodes.
     */
    noGroupHosts?: boolean;
    /**
     * A Boolean indicating whether to show nodes with no metrics.
     */
    noMetricHosts?: boolean;
    /**
     * The type of node used. Valid values are `host`, `container`.
     */
    nodeType?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.PowerpackWidgetHostmapDefinitionRequest;
    /**
     * The list of tags to filter nodes by.
     */
    scopes?: string[];
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetHostmapDefinitionStyle;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetHostmapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequest {
    /**
     * The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    fills?: outputs.PowerpackWidgetHostmapDefinitionRequestFill[];
    /**
     * The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    sizes?: outputs.PowerpackWidgetHostmapDefinitionRequestSize[];
}

export interface PowerpackWidgetHostmapDefinitionRequestFill {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSize {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetHostmapDefinitionStyle {
    /**
     * The max value to use to color the map.
     */
    fillMax?: string;
    /**
     * The min value to use to color the map.
     */
    fillMin?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * A Boolean indicating whether to flip the palette tones.
     */
    paletteFlip?: boolean;
}

export interface PowerpackWidgetIframeDefinition {
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
}

export interface PowerpackWidgetImageDefinition {
    /**
     * Whether to display a background or not. Defaults to `true`.
     */
    hasBackground?: boolean;
    /**
     * Whether to display a border or not. Defaults to `true`.
     */
    hasBorder?: boolean;
    /**
     * The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
     */
    horizontalAlign?: string;
    /**
     * The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
     */
    margin?: string;
    /**
     * The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
     */
    sizing?: string;
    /**
     * The URL to use as a data source for the widget.
     */
    url: string;
    /**
     * The URL in dark mode to use as a data source for the widget.
     */
    urlDarkTheme?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface PowerpackWidgetListStreamDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests: outputs.PowerpackWidgetListStreamDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetListStreamDefinitionRequest {
    /**
     * Column properties used by the front end for display.
     */
    columns: outputs.PowerpackWidgetListStreamDefinitionRequestColumn[];
    /**
     * Updated list stream widget.
     */
    query: outputs.PowerpackWidgetListStreamDefinitionRequestQuery;
    /**
     * Widget response format. Valid values are `eventList`.
     */
    responseFormat: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestColumn {
    /**
     * Widget column field.
     */
    field: string;
    /**
     * The width of the widget.
     */
    width: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The size to use to display an event. Valid values are `s`, `l`.
     */
    eventSize?: string;
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * Widget query.
     */
    queryString?: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetListStreamDefinitionRequestQuerySort;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetListStreamDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetLogStreamDefinition {
    /**
     * Column properties used by the front end for display.
     */
    columns?: string[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
     */
    messageDisplay?: string;
    /**
     * The query to use in the widget.
     */
    query?: string;
    /**
     * If the date column should be displayed.
     */
    showDateColumn?: boolean;
    /**
     * If the message column should be displayed.
     */
    showMessageColumn?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetLogStreamDefinitionSort;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetLogStreamDefinitionSort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetManageStatusDefinition {
    /**
     * Whether to colorize text or background. Valid values are `background`, `text`.
     */
    colorPreference?: string;
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * A Boolean indicating whether to hide empty categories.
     */
    hideZeroCounts?: boolean;
    /**
     * The query to use in the widget.
     */
    query: string;
    /**
     * A Boolean indicating whether to show when monitors/groups last triggered.
     */
    showLastTriggered?: boolean;
    /**
     * Whether to show the priorities column.
     */
    showPriority?: boolean;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * The summary type to use. Valid values are `monitors`, `groups`, `combined`.
     */
    summaryType?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetNoteDefinition {
    /**
     * The background color of the note.
     */
    backgroundColor?: string;
    /**
     * The content of the note.
     */
    content: string;
    /**
     * The size of the text in the widget.
     */
    fontSize?: string;
    /**
     * Whether to add padding or not. Defaults to `true`.
     */
    hasPadding?: boolean;
    /**
     * Whether to show a tick or not.
     */
    showTick?: boolean;
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
     */
    tickEdge?: string;
    /**
     * When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tickPos = "50%"` is centered alignment.
     */
    tickPos?: string;
    /**
     * The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
     */
    verticalAlign?: string;
}

export interface PowerpackWidgetQueryTableDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetQueryTableDefinitionCustomLink[];
    /**
     * Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
     */
    hasSearchBar?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetQueryTableDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetQueryTableDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQuery;
    apmStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayModes?: string[];
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryTableDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormula[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQuery;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetQueryTableDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery {
    /**
     * Column properties used by the front end for display.
     */
    columns?: outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn[];
    /**
     * APM environment.
     */
    env: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The organization's host group name and value.
     */
    primaryTag: string;
    /**
     * The resource name.
     */
    resource?: string;
    /**
     * The level of detail for the request. Valid values are `service`, `resource`, `span`.
     */
    rowType: string;
    /**
     * APM service.
     */
    service: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinition {
    /**
     * A Boolean indicating whether to automatically scale the tile.
     */
    autoscale?: boolean;
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetQueryValueDefinitionCustomLink[];
    /**
     * The unit for the value displayed in the widget.
     */
    customUnit?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The precision to use when displaying the value. Use `*` for maximum precision.
     */
    precision?: number;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetQueryValueDefinitionRequest[];
    /**
     * The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
     */
    textAlign?: string;
    /**
     * Set a timeseries on the widget background.
     */
    timeseriesBackground?: outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackground;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetQueryValueDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequest {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryValueDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetQueryValueDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetQueryValueDefinitionTimeseriesBackground {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis;
}

export interface PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetRunWorkflowDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetRunWorkflowDefinitionCustomLink[];
    /**
     * Array of workflow inputs to map to dashboard template variables.
     */
    inputs?: outputs.PowerpackWidgetRunWorkflowDefinitionInput[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * Workflow ID
     */
    workflowId: string;
}

export interface PowerpackWidgetRunWorkflowDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetRunWorkflowDefinitionInput {
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * A value for the comparator.
     */
    value: string;
}

export interface PowerpackWidgetScatterplotDefinition {
    /**
     * List of groups used for colors.
     */
    colorByGroups?: string[];
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetScatterplotDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request?: outputs.PowerpackWidgetScatterplotDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
     */
    xaxis?: outputs.PowerpackWidgetScatterplotDefinitionXaxis;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetScatterplotDefinitionYaxis;
}

export interface PowerpackWidgetScatterplotDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequest {
    /**
     * Scatterplot request containing formulas and functions.
     */
    scatterplotTables?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTable[];
    /**
     * The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
     */
    xes?: outputs.PowerpackWidgetScatterplotDefinitionRequestX[];
    /**
     * The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
     */
    ys?: outputs.PowerpackWidgetScatterplotDefinitionRequestY[];
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTable {
    formulas?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula[];
    queries?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery[];
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
     */
    dimension: string;
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestX {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestY {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQuery;
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetScatterplotDefinitionXaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetScatterplotDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetServiceLevelObjectiveDefinition {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The global time target of the widget.
     */
    globalTimeTarget?: string;
    /**
     * Whether to show the error budget or not.
     */
    showErrorBudget?: boolean;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `weekToDate`, `previousWeek`, `monthToDate`, `previousMonth`, `globalTime`.
     */
    timeWindows: string[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * The view mode for the widget. Valid values are `overall`, `component`, `both`.
     */
    viewMode: string;
    /**
     * The type of view to use when displaying the widget. Only `detail` is supported.
     */
    viewType: string;
}

export interface PowerpackWidgetServicemapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetServicemapDefinitionCustomLink[];
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetServicemapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetSloListDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    request: outputs.PowerpackWidgetSloListDefinitionRequest;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetSloListDefinitionRequest {
    /**
     * Updated SLO List widget.
     */
    query: outputs.PowerpackWidgetSloListDefinitionRequestQuery;
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface PowerpackWidgetSloListDefinitionRequestQuery {
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * Widget query.
     */
    queryString: string;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetSloListDefinitionRequestQuerySort;
}

export interface PowerpackWidgetSloListDefinitionRequestQuerySort {
    /**
     * The facet path for the column.
     */
    column: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetSunburstDefinitionCustomLink[];
    /**
     * Whether or not to show the total value in the widget.
     */
    hideTotal?: boolean;
    /**
     * Used to configure the inline legend. Cannot be used in conjunction with legend*table.
     */
    legendInline?: outputs.PowerpackWidgetSunburstDefinitionLegendInline;
    /**
     * Used to configure the table legend. Cannot be used in conjunction with legend*inline.
     */
    legendTable?: outputs.PowerpackWidgetSunburstDefinitionLegendTable;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetSunburstDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetSunburstDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetSunburstDefinitionLegendInline {
    /**
     * Whether to hide the percentages of the groups.
     */
    hidePercent?: boolean;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface PowerpackWidgetSunburstDefinitionLegendTable {
    /**
     * Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
     */
    type: string;
}

export interface PowerpackWidgetSunburstDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQuery;
    formulas?: outputs.PowerpackWidgetSunburstDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQuery;
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetSunburstDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetSunburstDefinitionRequestStyle;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetSunburstDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetSunburstDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface PowerpackWidgetTimeseriesDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetTimeseriesDefinitionCustomLink[];
    /**
     * The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
     */
    events?: outputs.PowerpackWidgetTimeseriesDefinitionEvent[];
    /**
     * A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
     */
    legendColumns?: string[];
    /**
     * The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
     */
    legendLayout?: string;
    /**
     * The size of the legend displayed in the widget.
     */
    legendSize?: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tileDef` block.
     */
    markers?: outputs.PowerpackWidgetTimeseriesDefinitionMarker[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetTimeseriesDefinitionRequest[];
    /**
     * A nested block describing the right Y-Axis Controls. See the `onRightYaxis` property for which request will use this axis. The structure of this block is described below.
     */
    rightYaxis?: outputs.PowerpackWidgetTimeseriesDefinitionRightYaxis;
    /**
     * Whether or not to show the legend on this widget.
     */
    showLegend?: boolean;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
    /**
     * A nested block describing the Y-Axis Controls. The structure of this block is described below.
     */
    yaxis?: outputs.PowerpackWidgetTimeseriesDefinitionYaxis;
}

export interface PowerpackWidgetTimeseriesDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionEvent {
    /**
     * The metric query to use for this widget.
     */
    q: string;
    /**
     * The execution method for multi-value filters, options: `and` or `or`.
     */
    tagsExecution?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionMarker {
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * A value for the comparator.
     */
    value: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQuery;
    /**
     * How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
     */
    displayType?: string;
    formulas?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQuery;
    /**
     * Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
     */
    metadatas?: outputs.PowerpackWidgetTimeseriesDefinitionRequestMetadata[];
    /**
     * The query to use for this widget.
     */
    networkQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery;
    /**
     * A Boolean indicating whether the request uses the right or left Y-Axis.
     */
    onRightYaxis?: boolean;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetTimeseriesDefinitionRequestStyle;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestMetadata {
    /**
     * The expression alias.
     */
    aliasName?: string;
    /**
     * The expression name.
     */
    expression: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetTimeseriesDefinitionRequestStyle {
    /**
     * The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
     */
    lineType?: string;
    /**
     * The width of line displayed. Valid values are `normal`, `thick`, `thin`.
     */
    lineWidth?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionRightYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetTimeseriesDefinitionYaxis {
    /**
     * Always include zero or fit the axis to the data range.
     */
    includeZero?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * Specify the maximum value to show on the Y-axis.
     */
    max?: string;
    /**
     * Specify the minimum value to show on the Y-axis.
     */
    min?: string;
    /**
     * Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
     */
    scale?: string;
}

export interface PowerpackWidgetToplistDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetToplistDefinitionCustomLink[];
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetToplistDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetToplistDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetToplistDefinitionRequest {
    /**
     * The query to use for this widget.
     */
    apmQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQuery;
    /**
     * The query to use for this widget.
     */
    auditQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQuery;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetToplistDefinitionRequestConditionalFormat[];
    formulas?: outputs.PowerpackWidgetToplistDefinitionRequestFormula[];
    /**
     * The query to use for this widget.
     */
    logQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetToplistDefinitionRequestProcessQuery;
    /**
     * The metric query to use for this widget.
     */
    q?: string;
    queries?: outputs.PowerpackWidgetToplistDefinitionRequestQuery[];
    /**
     * The query to use for this widget.
     */
    rumQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQuery;
    /**
     * The query to use for this widget.
     */
    securityQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQuery;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetToplistDefinitionRequestStyle;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetToplistDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetToplistDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestProcessQuery {
    /**
     * A list of processes.
     */
    filterBies?: string[];
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * Your chosen search term.
     */
    searchBy?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetToplistDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQuery {
    /**
     * `computeQuery` or `multiCompute` is required. The map keys are listed below.
     */
    computeQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy[];
    /**
     * The name of the index to query.
     */
    index: string;
    /**
     * `computeQuery` or `multiCompute` is required. Multiple `multiCompute` blocks are allowed using the structure below.
     */
    multiComputes?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute[];
    /**
     * The search query to use.
     */
    searchQuery?: string;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy {
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * A list of exactly one element describing the sort query to use.
     */
    sortQuery?: outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order: string;
}

export interface PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The facet name.
     */
    facet?: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
}

export interface PowerpackWidgetToplistDefinitionRequestStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
}

export interface PowerpackWidgetTopologyMapDefinition {
    /**
     * A nested block describing a custom link. Multiple `customLink` blocks are allowed using the structure below.
     */
    customLinks?: outputs.PowerpackWidgetTopologyMapDefinitionCustomLink[];
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetTopologyMapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetTopologyMapDefinitionCustomLink {
    /**
     * The flag for toggling context menu link visibility.
     */
    isHidden?: boolean;
    /**
     * The label for the custom link URL.
     */
    label?: string;
    /**
     * The URL of the custom link.
     */
    link?: string;
    /**
     * The label ID that refers to a context menu link item. When `overrideLabel` is provided, the client request omits the label field.
     */
    overrideLabel?: string;
}

export interface PowerpackWidgetTopologyMapDefinitionRequest {
    /**
     * The query for a Topology request.
     */
    queries: outputs.PowerpackWidgetTopologyMapDefinitionRequestQuery[];
    /**
     * The request type for the SLO List request. Valid values are `sloList`.
     */
    requestType: string;
}

export interface PowerpackWidgetTopologyMapDefinitionRequestQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Your environment and primary tag (or `*` if enabled for your account).
     */
    filters: string[];
    /**
     * APM service.
     */
    service: string;
}

export interface PowerpackWidgetTraceServiceDefinition {
    /**
     * The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
     */
    displayFormat?: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `weekToDate`, `monthToDate`, `1y`, `alert`.
     */
    liveSpan?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * Whether to show the latency breakdown or not.
     */
    showBreakdown?: boolean;
    /**
     * Whether to show the latency distribution or not.
     */
    showDistribution?: boolean;
    /**
     * Whether to show the error metrics or not.
     */
    showErrors?: boolean;
    /**
     * Whether to show the hits metrics or not
     */
    showHits?: boolean;
    /**
     * Whether to show the latency metrics or not.
     */
    showLatency?: boolean;
    /**
     * Whether to show the resource list or not.
     */
    showResourceList?: boolean;
    /**
     * The size of the widget. Valid values are `small`, `medium`, `large`.
     */
    sizeFormat?: string;
    /**
     * APM span name
     */
    spanName: string;
    /**
     * The title of the widget.
     */
    title?: string;
    /**
     * The alignment of the widget's title. Valid values are `center`, `left`, `right`.
     */
    titleAlign?: string;
    /**
     * The size of the widget's title (defaults to 16).
     */
    titleSize?: string;
}

export interface PowerpackWidgetTreemapDefinition {
    /**
     * A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apmQuery`, `logQuery`, `rumQuery`, `securityQuery` or `processQuery` is required within the request block).
     */
    requests?: outputs.PowerpackWidgetTreemapDefinitionRequest[];
    /**
     * The title of the widget.
     */
    title?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequest {
    formulas?: outputs.PowerpackWidgetTreemapDefinitionRequestFormula[];
    queries?: outputs.PowerpackWidgetTreemapDefinitionRequestQuery[];
}

export interface PowerpackWidgetTreemapDefinitionRequestFormula {
    /**
     * An expression alias.
     */
    alias?: string;
    /**
     * A list of display modes for each table cell. Valid values are `number`, `bar`.
     */
    cellDisplayMode?: string;
    /**
     * Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditionalFormats` blocks are allowed using the structure below.
     */
    conditionalFormats?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat[];
    /**
     * A string expression built from queries, formulas, and functions.
     */
    formulaExpression: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaLimit;
    /**
     * Styling options for widget formulas.
     */
    style?: outputs.PowerpackWidgetTreemapDefinitionRequestFormulaStyle;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat {
    /**
     * The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * The color palette to apply to the background, same values available as palette.
     */
    customBgColor?: string;
    /**
     * The color palette to apply to the foreground, same values available as palette.
     */
    customFgColor?: string;
    /**
     * Setting this to True hides values.
     */
    hideValue?: boolean;
    /**
     * Displays an image as the background.
     */
    imageUrl?: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette: string;
    /**
     * Defines the displayed timeframe.
     */
    timeframe?: string;
    /**
     * A value for the comparator.
     */
    value: number;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaLimit {
    /**
     * The number of results to return.
     */
    count?: number;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestFormulaStyle {
    /**
     * The color palette to apply. Valid values are `blue`, `customBg`, `customImage`, `customText`, `grayOnWhite`, `grey`, `green`, `orange`, `red`, `redOnWhite`, `whiteOnGray`, `whiteOnGreen`, `greenOnWhite`, `whiteOnRed`, `whiteOnYellow`, `yellowOnWhite`, `blackOnLightYellow`, `blackOnLightGreen`, `blackOnLightRed`.
     */
    palette?: string;
    /**
     * Index specifying which color to use within the palette.
     */
    paletteIndex?: number;
}

export interface PowerpackWidgetTreemapDefinitionRequestQuery {
    /**
     * The APM Dependency Stats query using formulas and functions.
     */
    apmDependencyStatsQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery;
    /**
     * The APM Resource Stats query using formulas and functions.
     */
    apmResourceStatsQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery;
    /**
     * The Cloud Cost query using formulas and functions.
     */
    cloudCostQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery;
    /**
     * A timeseries formula and functions events query.
     */
    eventQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuery;
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery;
    /**
     * The process query to use in the widget. The structure of this block is described below.
     */
    processQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery;
    /**
     * The SLO query using formulas and functions.
     */
    sloQuery?: outputs.PowerpackWidgetTreemapDefinitionRequestQuerySloQuery;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Determines whether stats for upstream or downstream dependencies should be queried.
     */
    isUpstream?: boolean;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery {
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * APM environment.
     */
    env: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * Name of operation on service.
     */
    operationName?: string;
    /**
     * The name of the second primary tag used within APM; required when `primaryTagValue` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
     */
    primaryTagName?: string;
    /**
     * Filter APM data by the second primary tag. `primaryTagName` must also be specified.
     */
    primaryTagValue?: string;
    /**
     * APM resource.
     */
    resourceName?: string;
    /**
     * APM service.
     */
    service: string;
    /**
     * APM statistic. Valid values are `avgDuration`, `avgRootDuration`, `avgSpansPerTrace`, `errorRate`, `pctExecTime`, `pctOfTraces`, `totalTracesCount`.
     */
    stat: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The cloud cost query definition.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQuery {
    /**
     * The compute options.
     */
    computes: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute[];
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Multiple `groupBy` blocks are allowed using the structure below.
     */
    groupBies?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy[];
    /**
     * An array of index names to query in the stream.
     */
    indexes?: string[];
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The search options.
     */
    search?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch;
    /**
     * Storage location (private beta).
     */
    storage?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * Define the time interval in seconds.
     */
    interval?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy {
    /**
     * The facet name.
     */
    facet: string;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The options for sorting group by results.
     */
    sort?: outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort {
    /**
     * The aggregation method.
     */
    aggregation: string;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric?: string;
    /**
     * Widget sorting methods. Valid values are `asc`, `desc`.
     */
    order?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch {
    /**
     * The events search string.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource?: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The metrics query definition.
     */
    query: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery {
    /**
     * The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
     */
    aggregator?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Whether to normalize the CPU percentages.
     */
    isNormalizedCpu?: boolean;
    /**
     * The maximum number of items in the group.
     */
    limit?: number;
    /**
     * The metric from the request to correlate with this conditional format.
     */
    metric: string;
    /**
     * The name of the powerpack template variable.
     */
    name: string;
    /**
     * The options for sorting group by results.
     */
    sort?: string;
    /**
     * An array of tags to filter by.
     */
    tagFilters?: string[];
    /**
     * The text to use as a filter.
     */
    textFilter?: string;
}

export interface PowerpackWidgetTreemapDefinitionRequestQuerySloQuery {
    /**
     * Additional filters applied to the SLO query.
     */
    additionalQueryFilters?: string;
    /**
     * The data source for APM Dependency Stats queries. Valid values are `apmDependencyStats`.
     */
    dataSource: string;
    /**
     * Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
     */
    groupMode?: string;
    /**
     * SLO measures queries. Valid values are `goodEvents`, `badEvents`, `sloStatus`, `errorBudgetRemaining`, `burnRate`, `errorBudgetBurndown`.
     */
    measure: string;
    /**
     * The name of the powerpack template variable.
     */
    name?: string;
    /**
     * ID of an SLO to query.
     */
    sloId: string;
    /**
     * type of the SLO to query. Valid values are `metric`. Defaults to `"metric"`.
     */
    sloQueryType?: string;
}

export interface PowerpackWidgetWidgetLayout {
    /**
     * The height of the widget.
     */
    height: number;
    /**
     * Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
     */
    isColumnBreak?: boolean;
    /**
     * The width of the widget.
     */
    width: number;
    /**
     * The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
     */
    x: number;
    /**
     * The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
     */
    y: number;
}

export interface RestrictionPolicyBinding {
    /**
     * An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
     */
    principals: string[];
    /**
     * The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
     */
    relation: string;
}

export interface RolePermission {
    /**
     * ID of the permission to assign.
     */
    id: string;
    /**
     * Name of the permission.
     */
    name: string;
}

export interface SecurityMonitoringDefaultRuleCase {
    /**
     * Notification targets for each rule case.
     */
    notifications: string[];
    /**
     * Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SecurityMonitoringDefaultRuleFilter {
    /**
     * The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface SecurityMonitoringDefaultRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`. Defaults to `false`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
}

export interface SecurityMonitoringFilterExclusionFilter {
    /**
     * Exclusion filter name.
     */
    name: string;
    /**
     * Exclusion filter query. Logs that match this query are excluded from the security filter.
     */
    query: string;
}

export interface SecurityMonitoringRuleCase {
    /**
     * A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
     */
    condition?: string;
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SecurityMonitoringRuleFilter {
    /**
     * The type of filtering action. Valid values are `require`, `suppress`.
     */
    action: string;
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface SecurityMonitoringRuleOptions {
    /**
     * If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `logDetection`. Defaults to `false`.
     */
    decreaseCriticalityBasedOnEnv?: boolean;
    /**
     * The detection method. Valid values are `threshold`, `newValue`, `anomalyDetection`, `impossibleTravel`, `hardcoded`, `thirdParty`. Defaults to `"threshold"`.
     */
    detectionMethod?: string;
    /**
     * A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
     */
    evaluationWindow?: number;
    /**
     * Options for rules using the impossible travel detection method.
     */
    impossibleTravelOptions?: outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions;
    /**
     * Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
     */
    keepAlive?: number;
    /**
     * A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
     */
    maxSignalDuration?: number;
    /**
     * New value rules specific options.
     */
    newValueOptions?: outputs.SecurityMonitoringRuleOptionsNewValueOptions;
    /**
     * Options for rules using the third-party detection method.
     */
    thirdPartyRuleOptions?: outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptions;
}

export interface SecurityMonitoringRuleOptionsImpossibleTravelOptions {
    /**
     * If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
     */
    baselineUserLocations?: boolean;
}

export interface SecurityMonitoringRuleOptionsNewValueOptions {
    /**
     * The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
     */
    forgetAfter: number;
    /**
     * The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
     */
    learningDuration?: number;
    /**
     * The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
     */
    learningMethod?: string;
    /**
     * A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
     */
    learningThreshold?: number;
}

export interface SecurityMonitoringRuleOptionsThirdPartyRuleOptions {
    /**
     * Notification targets for the default rule case, when none of the third-party cases match.
     */
    defaultNotifications?: string[];
    /**
     * Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    defaultStatus: string;
    /**
     * Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
     */
    rootQueries: outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery[];
    /**
     * A template for the signal title; if omitted, the title is generated based on the case name.
     */
    signalTitleTemplate?: string;
}

export interface SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery {
    /**
     * Fields to group by. If empty, each log triggers a signal.
     */
    groupByFields?: string[];
    /**
     * Query for selecting logs to apply the filtering action.
     */
    query: string;
}

export interface SecurityMonitoringRuleQuery {
    /**
     * **Deprecated**. It won't be applied anymore. **Deprecated.** `agentRule` has been deprecated in favor of new Agent Rule resource.
     *
     * @deprecated `agentRule` has been deprecated in favor of new Agent Rule resource.
     */
    agentRules?: outputs.SecurityMonitoringRuleQueryAgentRule[];
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `newValue`, `geoData`, `eventCount`, `none`. Defaults to `"count"`.
     */
    aggregation?: string;
    /**
     * Field for which the cardinality is measured. Sent as an array.
     */
    distinctFields?: string[];
    /**
     * Fields to group by.
     */
    groupByFields?: string[];
    /**
     * The target field to aggregate over when using the `sum`, `max`, or `geoData` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     *
     * @deprecated Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
     */
    metric?: string;
    /**
     * Group of target fields to aggregate over when using the `sum`, `max`, `geoData`, or `newValue` aggregations. The `sum`, `max`, and `geoData` aggregations only accept one value in this list, whereas the `newValue` aggregation accepts up to five values.
     */
    metrics: string[];
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Query to run on logs.
     */
    query: string;
}

export interface SecurityMonitoringRuleQueryAgentRule {
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    agentRuleId: string;
    /**
     * **Deprecated**. It won't be applied anymore.
     */
    expression: string;
}

export interface SecurityMonitoringRuleSignalQuery {
    /**
     * The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `newValue`, `geoData`, `eventCount`, `none`. Defaults to `"eventCount"`.
     */
    aggregation?: string;
    /**
     * Fields to correlate by.
     */
    correlatedByFields?: string[];
    /**
     * Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
     */
    correlatedQueryIndex?: string;
    /**
     * Default Rule ID of the signal to correlate. This value is READ-ONLY.
     */
    defaultRuleId?: string;
    /**
     * Name of the query. Not compatible with `newValue` aggregations.
     */
    name?: string;
    /**
     * Rule ID of the signal to correlate.
     */
    ruleId: string;
}

export interface SecurityMonitoringRuleThirdPartyCase {
    /**
     * Name of the case.
     */
    name?: string;
    /**
     * Notification targets for each rule case.
     */
    notifications?: string[];
    /**
     * A query to associate a third-party event to this case.
     */
    query?: string;
    /**
     * Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
     */
    status: string;
}

export interface SensitiveDataScannerGroupFilter {
    /**
     * Query to filter the events.
     */
    query: string;
}

export interface SensitiveDataScannerRuleIncludedKeywordConfiguration {
    /**
     * Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
     */
    characterCount: number;
    /**
     * Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
     */
    keywords: string[];
}

export interface SensitiveDataScannerRuleTextReplacement {
    /**
     * Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
     */
    numberOfChars?: number;
    /**
     * Required if type == 'replacement_string'.
     */
    replacementString?: string;
    /**
     * Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacementString`, `partialReplacementFromBeginning`, `partialReplacementFromEnd`.
     */
    type: string;
}

export interface ServiceLevelObjectiveQuery {
    /**
     * The sum of the `total` events.
     */
    denominator: string;
    /**
     * The sum of all the `good` events.
     */
    numerator: string;
}

export interface ServiceLevelObjectiveSliSpecification {
    /**
     * The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold.
     */
    timeSlice: outputs.ServiceLevelObjectiveSliSpecificationTimeSlice;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSlice {
    /**
     * The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
     */
    comparator: string;
    /**
     * A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
     */
    query: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQuery;
    /**
     * The threshold value to which each SLI value will be compared.
     */
    threshold: number;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQuery {
    /**
     * A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
     */
    formula: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula;
    /**
     * A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
     */
    queries: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery[];
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula {
    /**
     * The formula string, which is an expression involving named queries.
     */
    formulaExpression: string;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery {
    /**
     * A timeseries formula and functions metrics query.
     */
    metricQuery?: outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery;
}

export interface ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery {
    /**
     * The data source for metrics queries. Defaults to `"metrics"`.
     */
    dataSource?: string;
    /**
     * The name of the query for use in formulas.
     */
    name: string;
    /**
     * A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
     */
    query: string;
}

export interface ServiceLevelObjectiveThreshold {
    /**
     * The objective's target in `(0,100)`.
     */
    target: number;
    /**
     * A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
     */
    targetDisplay: string;
    /**
     * The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
     */
    timeframe: string;
    /**
     * The objective's warning value in `(0,100)`. This must be greater than the target value.
     */
    warning?: number;
    /**
     * A string representation of the warning target (see the description of the targetDisplay field for details).
     */
    warningDisplay: string;
}

export interface SpansMetricCompute {
    /**
     * The type of aggregation to use. This field can't be updated after creation.
     */
    aggregationType: string;
    /**
     * Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregationType` is `distribution`.
     */
    includePercentiles?: boolean;
    /**
     * The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
     */
    path?: string;
}

export interface SpansMetricFilter {
    /**
     * The search query - following the span search syntax. Defaults to `"*"`.
     */
    query: string;
}

export interface SpansMetricGroupBy {
    /**
     * The path to the value the span-based metric will be aggregated over.
     */
    path: string;
    /**
     * Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
     */
    tagName: string;
}

export interface SyntheticsGlobalVariableOptions {
    /**
     * Parameters needed for MFA/TOTP.
     */
    totpParameters?: outputs.SyntheticsGlobalVariableOptionsTotpParameters;
}

export interface SyntheticsGlobalVariableOptionsTotpParameters {
    /**
     * Number of digits for the OTP.
     */
    digits: number;
    /**
     * Interval for which to refresh the token (in seconds).
     */
    refreshInterval: number;
}

export interface SyntheticsGlobalVariableParseTestOptions {
    /**
     * Required when type = `httpHeader`. Defines the header to use to extract the value
     */
    field?: string;
    /**
     * When type is `localVariable`, name of the local variable to use to extract the value.
     */
    localVariableName?: string;
    parser?: outputs.SyntheticsGlobalVariableParseTestOptionsParser;
    /**
     * Defines the source to use to extract the value. Valid values are `httpBody`, `httpHeader`, `localVariable`.
     */
    type: string;
}

export interface SyntheticsGlobalVariableParseTestOptionsParser {
    /**
     * Type of parser to extract the value. Valid values are `raw`, `jsonPath`, `regex`, `xPath`.
     */
    type: string;
    /**
     * Value for the parser to use, required for type `jsonPath` or `regex`.
     */
    value?: string;
}

export interface SyntheticsPrivateLocationMetadata {
    /**
     * A list of role identifiers pulled from the Roles API to restrict read and write access.
     */
    restrictedRoles?: string[];
}

export interface SyntheticsTestApiStep {
    /**
     * Determines whether or not to continue with test if this step fails.
     */
    allowFailure?: boolean;
    /**
     * Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
     */
    assertions?: outputs.SyntheticsTestApiStepAssertion[];
    /**
     * Values to parse and save as variables from the response.
     */
    extractedValues?: outputs.SyntheticsTestApiStepExtractedValue[];
    /**
     * Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allowFailure` is `true`.
     */
    isCritical?: boolean;
    /**
     * The name of the step.
     */
    name: string;
    /**
     * The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
     */
    requestBasicauth?: outputs.SyntheticsTestApiStepRequestBasicauth;
    /**
     * Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
     */
    requestClientCertificate?: outputs.SyntheticsTestApiStepRequestClientCertificate;
    /**
     * The request for the api step.
     */
    requestDefinition?: outputs.SyntheticsTestApiStepRequestDefinition;
    /**
     * Header name and value map.
     */
    requestHeaders?: {[key: string]: any};
    /**
     * The proxy to perform the test.
     */
    requestProxy?: outputs.SyntheticsTestApiStepRequestProxy;
    /**
     * Query arguments name and value map.
     */
    requestQuery?: {[key: string]: any};
    retry?: outputs.SyntheticsTestApiStepRetry;
    /**
     * The subtype of the Synthetic multistep API test step. Valid values are `http`, `grpc`. Defaults to `"http"`.
     */
    subtype?: string;
}

export interface SyntheticsTestApiStepAssertion {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * If assertion type is `header`, this is the header name.
     */
    property?: string;
    /**
     * Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
     */
    target?: string;
    /**
     * Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonpath?: outputs.SyntheticsTestApiStepAssertionTargetjsonpath;
    /**
     * Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
     */
    targetxpath?: outputs.SyntheticsTestApiStepAssertionTargetxpath;
    /**
     * Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
     */
    timingsScope?: string;
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
     */
    type: string;
}

export interface SyntheticsTestApiStepAssertionTargetjsonpath {
    /**
     * The JSON path to assert.
     */
    jsonpath: string;
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
}

export interface SyntheticsTestApiStepAssertionTargetxpath {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
    /**
     * The xpath to assert.
     */
    xpath: string;
}

export interface SyntheticsTestApiStepExtractedValue {
    /**
     * When type is `httpHeader`, name of the header to use to extract the value.
     */
    field?: string;
    name: string;
    parser: outputs.SyntheticsTestApiStepExtractedValueParser;
    /**
     * Determines whether or not the extracted value will be obfuscated.
     */
    secure?: boolean;
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
     */
    type: string;
}

export interface SyntheticsTestApiStepExtractedValueParser {
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
     */
    type: string;
    /**
     * Regex or JSON path used for the parser. Not used with type `raw`.
     */
    value?: string;
}

export interface SyntheticsTestApiStepRequestBasicauth {
    /**
     * Access key for `SIGV4` authentication.
     */
    accessKey?: string;
    /**
     * Access token url for `oauth-client` or `oauth-rop` authentication.
     */
    accessTokenUrl?: string;
    /**
     * Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    audience?: string;
    /**
     * Client ID for `oauth-client` or `oauth-rop` authentication.
     */
    clientId?: string;
    /**
     * Client secret for `oauth-client` or `oauth-rop` authentication.
     */
    clientSecret?: string;
    /**
     * Domain for `ntlm` authentication.
     */
    domain?: string;
    /**
     * Password for authentication.
     */
    password?: string;
    /**
     * Region for `SIGV4` authentication.
     */
    region?: string;
    /**
     * Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    resource?: string;
    /**
     * Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    scope?: string;
    /**
     * Secret key for `SIGV4` authentication.
     */
    secretKey?: string;
    /**
     * Service name for `SIGV4` authentication.
     */
    serviceName?: string;
    /**
     * Session token for `SIGV4` authentication.
     */
    sessionToken?: string;
    /**
     * Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
     */
    tokenApiAuthentication?: string;
    /**
     * Type of basic authentication to use when performing the test. Defaults to `"web"`.
     */
    type?: string;
    /**
     * Username for authentication.
     */
    username?: string;
    /**
     * Workstation for `ntlm` authentication.
     */
    workstation?: string;
}

export interface SyntheticsTestApiStepRequestClientCertificate {
    cert: outputs.SyntheticsTestApiStepRequestClientCertificateCert;
    key: outputs.SyntheticsTestApiStepRequestClientCertificateKey;
}

export interface SyntheticsTestApiStepRequestClientCertificateCert {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestApiStepRequestClientCertificateKey {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestApiStepRequestDefinition {
    /**
     * Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
     */
    allowInsecure?: boolean;
    /**
     * The request body.
     */
    body?: string;
    /**
     * Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
     */
    bodyType?: string;
    /**
     * The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
     */
    callType?: string;
    /**
     * By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificateDomains`.
     */
    certificateDomains?: string[];
    /**
     * DNS server to use for DNS tests (`subtype = "dns"`).
     */
    dnsServer?: string;
    /**
     * DNS server port to use for DNS tests.
     */
    dnsServerPort?: number;
    /**
     * Determines whether or not the API HTTP test should follow redirects.
     */
    followRedirects?: boolean;
    /**
     * Host name to perform the test with.
     */
    host?: string;
    /**
     * For UDP and websocket tests, message to send with the request.
     */
    message?: string;
    /**
     * Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
     */
    method?: string;
    /**
     * Determines whether or not to save the response body.
     */
    noSavingResponseBody?: boolean;
    /**
     * Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
     */
    numberOfPackets?: number;
    /**
     * Persist cookies across redirects.
     */
    persistCookies?: boolean;
    /**
     * The content of a proto file as a string.
     */
    plainProtoFile?: string;
    /**
     * Port to use when performing the test.
     */
    port?: number;
    /**
     * A protobuf JSON descriptor. **Deprecated.** Use `plainProtoFile` instead.
     *
     * @deprecated Use `plainProtoFile` instead.
     */
    protoJsonDescriptor?: string;
    /**
     * For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
     */
    servername?: string;
    /**
     * The gRPC service on which you want to perform the gRPC call.
     */
    service?: string;
    /**
     * This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
     */
    shouldTrackHops?: boolean;
    /**
     * Timeout in seconds for the test. Defaults to `60`.
     */
    timeout?: number;
    /**
     * The URL to send the request to.
     */
    url?: string;
}

export interface SyntheticsTestApiStepRequestProxy {
    /**
     * Header name and value map.
     */
    headers?: {[key: string]: any};
    /**
     * URL of the proxy to perform the test.
     */
    url: string;
}

export interface SyntheticsTestApiStepRetry {
    /**
     * Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
     */
    count?: number;
    /**
     * Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
     */
    interval?: number;
}

export interface SyntheticsTestAssertion {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * If assertion type is `header`, this is the header name.
     */
    property?: string;
    /**
     * Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
     */
    target?: string;
    /**
     * Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
     */
    targetjsonpath?: outputs.SyntheticsTestAssertionTargetjsonpath;
    /**
     * Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
     */
    targetxpath?: outputs.SyntheticsTestAssertionTargetxpath;
    /**
     * Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
     */
    timingsScope?: string;
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
     */
    type: string;
}

export interface SyntheticsTestAssertionTargetjsonpath {
    /**
     * The JSON path to assert.
     */
    jsonpath: string;
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
}

export interface SyntheticsTestAssertionTargetxpath {
    /**
     * Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
     */
    operator: string;
    /**
     * Expected matching value.
     */
    targetvalue?: string;
    /**
     * The xpath to assert.
     */
    xpath: string;
}

export interface SyntheticsTestBrowserStep {
    /**
     * Determines if the step should be allowed to fail.
     */
    allowFailure?: boolean;
    /**
     * Force update of the "element" parameter for the step
     */
    forceElementUpdate?: boolean;
    /**
     * Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allowFailure` is `true`.
     */
    isCritical?: boolean;
    /**
     * Name of the step.
     */
    name: string;
    /**
     * Prevents saving screenshots of the step.
     */
    noScreenshot?: boolean;
    /**
     * Parameters for the step.
     */
    params: outputs.SyntheticsTestBrowserStepParams;
    /**
     * Used to override the default timeout of a step.
     */
    timeout?: number;
    /**
     * Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
     */
    type: string;
}

export interface SyntheticsTestBrowserStepParams {
    /**
     * Name of the attribute to use for an "assert attribute" step.
     */
    attribute?: string;
    /**
     * Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
     */
    check?: string;
    /**
     * Type of click to use for a "click" step.
     */
    clickType?: string;
    /**
     * Javascript code to use for the step.
     */
    code?: string;
    /**
     * Delay between each key stroke for a "type test" step.
     */
    delay?: number;
    /**
     * Element to use for the step, json encoded string.
     */
    element?: string;
    /**
     * Custom user selector to use for the step.
     */
    elementUserLocator?: outputs.SyntheticsTestBrowserStepParamsElementUserLocator;
    /**
     * Details of the email for an "assert email" step.
     */
    email?: string;
    /**
     * JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
     */
    file?: string;
    /**
     * Details of the files for an "upload files" step, json encoded string.
     */
    files?: string;
    /**
     * Modifier to use for a "press key" step.
     */
    modifiers?: string[];
    /**
     * ID of the tab to play the subtest.
     */
    playingTabId?: string;
    /**
     * Request for an API step.
     */
    request?: string;
    /**
     * ID of the Synthetics test to use as subtest.
     */
    subtestPublicId?: string;
    /**
     * Regex or JSON path used for the parser. Not used with type `raw`.
     */
    value?: string;
    /**
     * Details of the variable to extract.
     */
    variable?: outputs.SyntheticsTestBrowserStepParamsVariable;
    /**
     * For "file upload" steps.
     */
    withClick?: boolean;
    /**
     * X coordinates for a "scroll step".
     */
    x?: number;
    /**
     * Y coordinates for a "scroll step".
     */
    y?: number;
}

export interface SyntheticsTestBrowserStepParamsElementUserLocator {
    /**
     * Defaults to `false`.
     */
    failTestOnCannotLocate?: boolean;
    /**
     * Regex or JSON path used for the parser. Not used with type `raw`.
     */
    value: outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue;
}

export interface SyntheticsTestBrowserStepParamsElementUserLocatorValue {
    /**
     * Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
     */
    type?: string;
    /**
     * Regex or JSON path used for the parser. Not used with type `raw`.
     */
    value: string;
}

export interface SyntheticsTestBrowserStepParamsVariable {
    /**
     * Example of the extracted variable. Defaults to `""`.
     */
    example?: string;
    /**
     * Name of the extracted variable.
     */
    name?: string;
}

export interface SyntheticsTestBrowserVariable {
    /**
     * Example for the variable. Defaults to `""`.
     */
    example?: string;
    /**
     * ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
     */
    id?: string;
    /**
     * Name of the variable.
     */
    name: string;
    /**
     * Pattern of the variable. Defaults to `""`.
     */
    pattern?: string;
    /**
     * Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
     */
    secure?: boolean;
    /**
     * Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
     */
    type: string;
}

export interface SyntheticsTestConfigVariable {
    example?: string;
    /**
     * When type = `global`, ID of the global variable to use.
     */
    id?: string;
    /**
     * Name of the variable.
     */
    name: string;
    pattern?: string;
    /**
     * Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
     */
    secure?: boolean;
    /**
     * Type of test configuration variable. Valid values are `global`, `text`.
     */
    type: string;
}

export interface SyntheticsTestOptionsList {
    /**
     * For SSL test, whether or not the test should allow self signed certificates.
     */
    acceptSelfSigned?: boolean;
    /**
     * Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
     */
    allowInsecure?: boolean;
    /**
     * For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
     */
    checkCertificateRevocation?: boolean;
    /**
     * CI/CD options for a Synthetic test.
     */
    ci?: outputs.SyntheticsTestOptionsListCi;
    /**
     * Disable Cross-Origin Resource Sharing for browser tests.
     */
    disableCors?: boolean;
    /**
     * Disable Content Security Policy for browser tests.
     */
    disableCsp?: boolean;
    /**
     * Determines whether or not the API HTTP test should follow redirects.
     */
    followRedirects?: boolean;
    /**
     * HTTP version to use for a Synthetics API test. Valid values are `http1`, `http2`, `any`.
     */
    httpVersion?: string;
    /**
     * Ignore server certificate error for browser tests.
     */
    ignoreServerCertificateError?: boolean;
    /**
     * Timeout before declaring the initial step as failed (in seconds) for browser tests.
     */
    initialNavigationTimeout?: number;
    /**
     * Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
     */
    minFailureDuration?: number;
    /**
     * Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
     */
    minLocationFailed?: number;
    /**
     * The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
     */
    monitorName?: string;
    monitorOptions?: outputs.SyntheticsTestOptionsListMonitorOptions;
    monitorPriority?: number;
    /**
     * Prevents saving screenshots of the steps.
     */
    noScreenshot?: boolean;
    /**
     * A list of role identifiers pulled from the Roles API to restrict read and write access.
     */
    restrictedRoles?: string[];
    retry?: outputs.SyntheticsTestOptionsListRetry;
    /**
     * The RUM data collection settings for the Synthetic browser test.
     */
    rumSettings?: outputs.SyntheticsTestOptionsListRumSettings;
    /**
     * Object containing timeframes and timezone used for advanced scheduling.
     */
    scheduling?: outputs.SyntheticsTestOptionsListScheduling;
    /**
     * How often the test should run (in seconds).
     */
    tickEvery: number;
}

export interface SyntheticsTestOptionsListCi {
    /**
     * Execution rule for a Synthetics test. Valid values are `blocking`, `nonBlocking`, `skipped`.
     */
    executionRule?: string;
}

export interface SyntheticsTestOptionsListMonitorOptions {
    /**
     * Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
     */
    renotifyInterval?: number;
}

export interface SyntheticsTestOptionsListRetry {
    /**
     * Number of retries needed to consider a location as failed before sending a notification alert. Defaults to `0`.
     */
    count?: number;
    /**
     * Interval between a failed test and the next retry in milliseconds. Defaults to `300`.
     */
    interval?: number;
}

export interface SyntheticsTestOptionsListRumSettings {
    /**
     * RUM application ID used to collect RUM data for the browser test.
     */
    applicationId?: string;
    /**
     * RUM application API key ID used to collect RUM data for the browser test.
     */
    clientTokenId?: number;
    /**
     * Determines whether RUM data is collected during test runs.
     */
    isEnabled: boolean;
}

export interface SyntheticsTestOptionsListScheduling {
    /**
     * Array containing objects describing the scheduling pattern to apply to each day.
     */
    timeframes: outputs.SyntheticsTestOptionsListSchedulingTimeframe[];
    /**
     * Timezone in which the timeframe is based.
     */
    timezone: string;
}

export interface SyntheticsTestOptionsListSchedulingTimeframe {
    /**
     * Number representing the day of the week
     */
    day: number;
    /**
     * The hour of the day on which scheduling starts.
     */
    from: string;
    /**
     * The hour of the day on which scheduling ends.
     */
    to: string;
}

export interface SyntheticsTestRequestBasicauth {
    /**
     * Access key for `SIGV4` authentication.
     */
    accessKey?: string;
    /**
     * Access token url for `oauth-client` or `oauth-rop` authentication.
     */
    accessTokenUrl?: string;
    /**
     * Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    audience?: string;
    /**
     * Client ID for `oauth-client` or `oauth-rop` authentication.
     */
    clientId?: string;
    /**
     * Client secret for `oauth-client` or `oauth-rop` authentication.
     */
    clientSecret?: string;
    /**
     * Domain for `ntlm` authentication.
     */
    domain?: string;
    /**
     * Password for authentication.
     */
    password?: string;
    /**
     * Region for `SIGV4` authentication.
     */
    region?: string;
    /**
     * Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    resource?: string;
    /**
     * Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
     */
    scope?: string;
    /**
     * Secret key for `SIGV4` authentication.
     */
    secretKey?: string;
    /**
     * Service name for `SIGV4` authentication.
     */
    serviceName?: string;
    /**
     * Session token for `SIGV4` authentication.
     */
    sessionToken?: string;
    /**
     * Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
     */
    tokenApiAuthentication?: string;
    /**
     * Type of basic authentication to use when performing the test. Defaults to `"web"`.
     */
    type?: string;
    /**
     * Username for authentication.
     */
    username?: string;
    /**
     * Workstation for `ntlm` authentication.
     */
    workstation?: string;
}

export interface SyntheticsTestRequestClientCertificate {
    cert: outputs.SyntheticsTestRequestClientCertificateCert;
    key: outputs.SyntheticsTestRequestClientCertificateKey;
}

export interface SyntheticsTestRequestClientCertificateCert {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestRequestClientCertificateKey {
    /**
     * Content of the certificate.
     */
    content: string;
    /**
     * File name for the certificate.
     */
    filename?: string;
}

export interface SyntheticsTestRequestDefinition {
    /**
     * The request body.
     */
    body?: string;
    /**
     * Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
     */
    bodyType?: string;
    /**
     * The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
     */
    callType?: string;
    /**
     * By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificateDomains`.
     */
    certificateDomains?: string[];
    /**
     * DNS server to use for DNS tests (`subtype = "dns"`).
     */
    dnsServer?: string;
    /**
     * DNS server port to use for DNS tests.
     */
    dnsServerPort?: number;
    /**
     * Host name to perform the test with.
     */
    host?: string;
    /**
     * For UDP and websocket tests, message to send with the request.
     */
    message?: string;
    /**
     * Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
     */
    method?: string;
    /**
     * Determines whether or not to save the response body.
     */
    noSavingResponseBody?: boolean;
    /**
     * Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
     */
    numberOfPackets?: number;
    /**
     * Persist cookies across redirects.
     */
    persistCookies?: boolean;
    /**
     * The content of a proto file as a string.
     */
    plainProtoFile?: string;
    /**
     * Port to use when performing the test.
     */
    port?: number;
    /**
     * A protobuf JSON descriptor. **Deprecated.** Use `plainProtoFile` instead.
     *
     * @deprecated Use `plainProtoFile` instead.
     */
    protoJsonDescriptor?: string;
    /**
     * For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
     */
    servername?: string;
    /**
     * The gRPC service on which you want to perform the gRPC call.
     */
    service?: string;
    /**
     * This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
     */
    shouldTrackHops?: boolean;
    /**
     * Timeout in seconds for the test. Defaults to `60`.
     */
    timeout?: number;
    /**
     * The URL to send the request to.
     */
    url?: string;
}

export interface SyntheticsTestRequestProxy {
    /**
     * Header name and value map.
     */
    headers?: {[key: string]: any};
    /**
     * URL of the proxy to perform the test.
     */
    url: string;
}

export namespace aws {
    export interface GetIntegrationLogsServicesAwsLogsService {
        /**
         * The id of the AWS log service.
         */
        id: string;
        /**
         * The name of the AWS log service.
         */
        label: string;
    }

}

export namespace slack {
    export interface ChannelDisplay {
        /**
         * Show the main body of the alert event. Defaults to `true`.
         */
        message?: boolean;
        /**
         * Show the list of @-handles in the alert event. Defaults to `true`.
         */
        notified?: boolean;
        /**
         * Show the alert event's snapshot image. Defaults to `true`.
         */
        snapshot?: boolean;
        /**
         * Show the scopes on which the monitor alerted. Defaults to `true`.
         */
        tags?: boolean;
    }

}
